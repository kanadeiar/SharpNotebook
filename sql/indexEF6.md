# Введение EF 6

В версии .NET 3.5 SP1 был добавлен компонент API-интерфейса ADO.NET под названием Entity Framework (EF). Цель компонента этого - дать возможность взаимодействия с данными из реляционных баз данных в виде объектной модели, отображаемой прямо на бизнес-объекты в приложении. Оперировать коллекцией строго типизированных объектов, называемых сущностями (entity). 

Инфраструктура EF сокращает разрыв между целями и оптимизацией базы данных и целями и оптимизацией объектно-ориентированного программирования. С помощью EF можно работать с базами данных, не сталкиваясь со строками кода SQL. Выполняемая среда EF самостоятельно генерирует подходящие операторы SQL.

## Составные части EF

Строго типизированные классы называемые сущностями - модули физической базы данных, отображаемые на предметную область. Формально - модель сущностных данных (Entity Data Model - EDM). Сущности не обязаны напрямую отображаться на схуму базы данных, обычто так не бывает. Сущностные классы делаются для удовлетворения нужно приложения, затем отображаются на имеющеюся базу данных.

За кулисами работы с EF инфраструктура создает и открывает подключение к базе данных, генерируется и выполняется подходящий оператор SQL, подключение освобождается и закрывается. Обрабатывается без участия человека.

Инфраструктура и ядро EF при работе использует ADO.NET. Требуется поставщик данных, поддерживающий эту инфраструктуру. Например System.Data.Entity для Microsoft SQL Server. 

Класс DbContext используется для запрашивания базы данных и объединения изменений, записивыемых обратно в базу данных в виде одинойной еденицы работы. Класс предоставляет дочерним службы для сохранения изменений, настройку строки подключения, удаление объектов, вызов хранимых процедур и прочее.

Некоторые члены DbContext:

Член                     | Описание
-------------------------|-------------------------
DbContext()              | Конструктор, применяемый в производном контекстном классе. В строковом параметре - либо имя базы данных, либо строка подключения в файле *.config.
Entry() Entry<TEntity>() | Извлекает объект System.Data.Entity.Infrastructure.DbEntityEntry, предоставляющий доступ к информации и возможность выполнения действий над сущностью.
GetValidationErrors()    | Проверяет достоверность обрабатываемых сущностей и возвращает коллекцию объектов System.Data.Entity.Validation.DbEntityValidationResult
SaveChanges() SaveChangesAsync() | Сохраняет в базе данных все изменения контекста, вертает кол-во затронутых записей.
Configuration()          | Доступ к свойствам конфигурации контекста
Database                 | Дает механизм для создания/удаления/проверки существования лежащей в основе базы данных, для выполнения хранимых процедур и низкоуровневых опереторов SQL над базой данных и для доступа работы с транзакциями.

Событие                  | Описание
-------------------------|-------------------------
ObjectMaterialized       | Инициируется при создании нового сущностного объекта из хранилища данных запросом выборки или загрузкой
SavingChanges            | Происходит при сохранении изменений в базе данных, но перед моментом окончательной записи изменений в базу данных

### Парадигма Code First

Класс DbContext предоставляет основную функциональность во время работы со средством CodeFirst инфраструктуры EF. Это не означает невозможность примеения EF с существующей базой данных. Можно как использовать Code First с существующей базой данных или создать новую базу данных на основе сущностей с помощью миграций EF.

### Производный контекстный класс

Пример производного класса от DbContext специфичной предметной области, с переданной строкой подключения:
```csharp
public class SampleEntities : DbContext
{
    public SampleEntities() : base("name = SampleConnection")
    { }
    protected override void Dispose(bool disposing)
    { }
}
```

### Свойство типа DBSet<T>

Для каждой таблицы в объектной модели нужно предусмотреть свойство типа DbSet<T>. Для перевода свойств в режим ленивой загрузки эти свойства должны быть виртуальными.
    
Некоторые члены DBSet<T>:

Член                     | Описание
-------------------------|-------------------------
Add() AddRange()         | Позволяют вставлять в коллекцию новый объект (или пачку). Они получают статус EntityState.Added и будут добавлены в базу от SaveChanges() на DbContext
Attach()                 | Ассоциирует объект с DbContext. Применяется в автономных приложениях ASP.NET|MVC
Create() Create<T>()     | Новый экземпляр указанного сущностного типа
Find() FindAsync()       | Находит строку данных по первичному ключу и возвращает объект, представляющий эту строку.
Remove() RemoveRange()   | Помечает объект - или группу - для последующего удаления
SqlQuery()               | Создает низкоуровневый запрос SQL, возвращяющий сущности в этом наборе
    
### Транзакции

Все EF помещают свои вызовы SaveChanges()/SaveChangesAsync() внутрь транзакции. Начиная с версии EF 6, внутрь неявной транзакции помещается и ExecuteSqlCommand().

### Состояние сущности

Любые изменения в данных будут отслеживатся и записываться при вызове SaveShanges().

Значения перечисления EntityState:

Значение                 | Описание
-------------------------|-------------------------
Detached                 | Объект есть, но не отслеживается. Сущность после создания и перед добавление ее к объектному контексту.
Unchanged                | Объект не изменился с момента присоединения к контексту, или с последнего SaveChanges()
Added                    | Объект - новый и добавлен в объектный контекст, метод SaveChanges() не вызывался
Deleted                  | Объект удален из контекста, но еще не удален из хранилища данных
Modified                 | Одно из скалярных свойств было изменено, но метод SaveChanges() не вызывался

Проверка состояния объекта:
```csharp
EntityState state = context.Entry(entity).State;
```

### Аннотации данных

Аннотации данных C# применяются для придания формы сущностям. Доступно множество аннотаций данных для уточнения модели и добавления проверок достоверности.

Некоторые аннотации данных, поддерживаемых EF:

Аннотация данных         | Описание
-------------------------|-------------------------
Key                      | Первичный ключ для модели. Необящательно, если свойство ключа именовано как Id, или комбинация имени с Id (MyId). При составном ключе нужно добавить атрибут Column с параметром нужным (Column[My=1] Column[My=2]). Являются неявно [Required]
Required                 | Объявляет свойство как не допускающие null
ForeignKey               | Свойство, применяемое как внешний ключ для навигационного свойства
StringLength             | Минимальная и максимальная длина строкового свойства
NotMapped                | Свойство, которое не отображается на поле базы данных
ConcurrencyCheck         | Поле, используемое при проверке парралелизма, когда сервер выполняет обновления, вставку или удаление данных.
TimeStamp                | Тип как версию строки или отметку времени
Table Column             | Именование классов и полей моделей не так, как они объявлены в базе данных. Атрибут Table - спецификацию схемы.
DatabaseGenerated        | Указание, что поле сгенерировано базой данных - Computed, Identity, None.
Index                    | Указание, что столбец должен иметь индекс, возможно указать кластеризацию, уникальность, имя, порядок

## Создание модели сущностных классов

? Запуск VS под админиcтратором

? Добавить в проект ссылку на System.Data.Entity.

? Установить пакет NuGet EntityFramework 6.

В папку добавить новый элемент - "Данные" -> "Модель ADO.NET EDM" - название "*Entities".

Выбрать "CodeFirst из базы данных".

Выбрать подключение к базе данных - сохранить - установить название "*Connection".

Отметить все интересующие таблицы, кроме "sysdiagrams", отметить галку "Формировать имена объектов во множественном или единственном числе".

Исследовать полученные классы и модифицировать их под задачу. В файле "App.config" - новый элемент "EntityFramework" и строка подключения к базе данных.

Добавление новых возможностей в сгенерированные классы доступно только путем создания дополнительных файлов с таким названием класса и "partial", т.к. все сгенерированные классы "partial" и когда классы будут генерироватся повторно, не возникнет риска потери изменений. Например файл "CarPartial.cs":
```csharp
public partial class Inventory
{
    public override string ToString()
    {
        return $"{this.Name ?? "<без имени>"} цвета {this.Color} марки {this.Make} c Id {this.CarId}";
    }
}
```

## Использование этой модели

Добавление новой записи сводится к добавлению записей в DbSet<T> и вызову SaveChanges(). 
    
Пример:
```csharp
private static int AddNewRecord()
{
    using (var context = new AutoLotEntities())
    {
        try
        {
            var car = new Inventory() { Make = "Yugo", Color = "White", Name = "Green" };
            context.Inventories.Add(car);
            context.SaveChanges();
            return car.CarId;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.InnerException?.Message);
            return 0;
        }
    }
}
int carId = AddNewRecord();
```

Пример добавления можножества записей:
```csharp
private static void AddNewRecords(IEnumerable<Inventory> cars)
{
    using (var context = new AutoLotEntities())
    {
        context.Inventories.AddRange(cars);
        context.SaveChanges();
    }
}
Inventory[] inventories =
{
    new Inventory{Make = "Test1", Color = "Bl1", Name = "HotName1"},
    new Inventory{Make = "Test2", Color = "Bl2", Name = "HotName2"},
};
AddNewRecords(inventories);
```

