# Типы

## Видимость типа

При определении типа его можно сделать открытым или внутренним испльзуя ключевые слова, без явно указанного ключевого слова видимости тип - внутренний.

Можно указать другие сборки, которые она будет считать дружественными - атрибут InernalsVisibleTo, в параметрах передать - имя и ее открытый ключ. 

## Статические классы

Компилятор налагает на статические классы ограничения:

- класс должен быть прямым потомком System.Object

- не должен реализовывать интерфейсы

- можно определять только статические члены

- нельзя использовать в качестве поля

Определение класса ключевым словом static заставляет компилятор делать класс абстрактным, запечатанным и без конструктора экземпляров. 

## Частичный тип

Помеченный ключевым словом partial тип во всех файлах с определением типа заставляет компилятор собирать из этих нескольких файлов один тип.

## Компоненты

Современные приложения состоят из множества компонентов, разработанных множеством компаний. Компоненты объединяются вместе в рамках парадигмы ООП. 

Важные ключевые слова C#, позволяющие управлять версиями компонентов в рамках ООП:

Слово C# | Тип | Метод/Свойство/Событие | Константа/Поле
---------|-----|------------------------|-------------
abstract | Экземпляры такого типа создавать нельзя | Необоходимо реализовать этот член в производном типе | запрещено
virtual | запрещено | Член может переопределяться в производном типе | запрещено
override | запрещено | Член переопределяется в производном типе | запрещено
sealed | Нельзя использовать в качестве базового при наследовании | Член нельзя переопределить в производном типе | запрещено
new | вложенный тип не связан с похожим базового | вложенный не связан с похожим базового | вложенный не связан с похожим базового

## Полиморфизм

Методы типа содержат код действий над типом или экземпляра типа. У метода есть: имя, сигнатура, вертаемый тип (void-пусто). У типа может быть несколько методов с одинаковым имененем, но с разным числом параметров. 

В CLR есть две инструкции для вызова метода:

- call: для вызова статических (указывается тип, в котором определен метод), экземплярных и виртуальных (необходимо указать переменную, ссылающуюся на объект, причем она не равна null, тип переменной указывает, в каком типе определен необходимый метод) методов. 

- callvirt: для вызова экземплярных и виртуальных (указывается переменная, ссылающаяся на объект) методов. При вызове невиртуального экземплрного метода, тип переменной показывает, где определен метод. При вызовае виртуального - CLR определяет настоящий тип объекта, на который ссылается переменная и вызывает метод полиморфно. Callvirt выполняется немного медленне, чем call изза дополнительных проверок на null.

При вызове экземплярного или виртуального метода инструкции call и callvirt всегда в первом параметре получают скрытый аргумент this, ссылающийся на объект, с которым производятся действия.

Компиляторы стремятся использовать команду call при вызове методов в значимых типах, поскольку они запечатаны, вызов выполняется быстрее. Для вызова виртуального метода в значимом типе нужно его упаковывать, а это нагрузка.

## Использование модификаторов доступа

Полезно использовать запечатанные классы вместо обычных. Запечатанный всегда можно сделать обычным, а обратное - невозможно. Все определения незапечатанных виртуальных мутодов базового класса следует соблюдать в новых версиях. Невиртуальные методы вызываются быстрее виртуальных, но для запечатанного класса может быть создат более эффективный код. Если класс не запечатан, то производный класс может изменить его состояние и нарушить безопасность.

Если класс не предназначен для наследования, его желаетльно объявлять запечатанным. При отсутствии необходимости доступа этому классу из других сборок его следует объявить внутренним. При переопределении класса следует переопределать и запечатывать все виртуальные методы, которые наследует класс.

Все поля класса - закрытые. 

Методы, свойства и события класса следует объявлять закрытыми и невиртуальными. Некоторые методы, свойства и события должны быть открытыми, но лучше не защищенными или внутренними. 

Если реализация алгоритма чрезмерно усложняется, следует сделать их вложенными и закрытыми.


