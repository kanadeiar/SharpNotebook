# Параметры

При определении метода можно некоторым параметрам метода или всем установить значения по умолчанию. Это позволит при вызове методов не указывать их, будут использованы значения по-умолчанию. Еще есть возможность использовать именованные параметры, то есть указать параметры, воспользовавшить их именами.

```csharp
private static int value = 0;
private static void M(int x = 9; string s = "A", DateTime dt=default(DateTime), Guid guid = new Guid()) { ... }
// использование
M();
M(8, "X");
M(5, guid: Guid.NewGuid(), dt: DateTime.Now);
```

Правила использования параметров:

- Значения по умолчанию указываются для параметров методов, конструкторов, параметрических свойств и для являющихся частью определения делегата.

- Параметры со значениями по умолчанию должны следовать за всеми остальными параметрами. Параметр массива params должен быть расположен после всех остальных параметров.

- Задачать значения по умолчанию можно для примитивных типов, перечислимых типов и ссылочных типов, допускающих значение null. Можно использовать как ключевое слово default, так и new. 

- Нельзя переименовывать параметрические переменные.

- Изменение значения по умолчанию опасно. Вызывающий код использует это значение. Лучше использовать значения null или 0.

- Для параметров ref или out значения по умолчанию не задаются.

- Именованные параметры при вызове метода должны находится в конце.

- Передача параметров по имени возможна для параметров, не имеющих значения по умолчанию.

- Между запятыми не могут отсутствовать параметры.

Компилятор C# параметрам со значением по умолчанию назначает специальный атрибут OptionalAttribute и DefaultParameterValueAttrubute, сохраняющийся в метаданных. И затем код, вызывающий метод, проверяет наличие этого атрибута и берет значения из метаданных.

## Передача параметра в метод по ссылке

По умолчанию все значимые типы передаются в метод по значению (передается копия объекта, а исходный экземпляр остается неизменным), а ссылочные типы - по ссылке (передается ссылка на объект, можно влиять на вызывающий код). Метод может изменить переданный объект.

CLR позволяет передавать параметры по ссылке используюя ключевые слова ref и out. Они заставляют компилятор обозначать параметры как передаваемые по ссылке.

Если параметр обозначен ключевым словом out, вызывающий код может не инициализировать его до вызова метода, а вызванный метод должен его записать.

Если параметр обозначен ключевым словом ref, вызывающий код должен инициализировать объект перед его использованием, а вызванный метод может как его читать, так и записывать.

```csharp
private static void GetVal(out int v)
{
    v = 10;
}
private static void AddVal(ref int v)
{
    v += 10;
}
// использование
int x;
GetVal(out x);
AddVal(ref x);
```

Параметр v в таком случае представляет собой указатель на значимый тип Int32 в стеке вызывающего кода.

Код меняющий две ссылки местами:

```csharp
public static void Swap<T>(ref T a, ref T b)
{
    T t = a;
    a = b;
    b = t;
}
// использование
var s1 = "One";
var s2 = "Two";
Swap(ref s1, ref s2);
```

## Передача переменного количества элементов

Ключевым словом params можно пометить только последний караметр метода. Он должен указывать на одномерный массив произвольного типа.

Определение метода, принимающего переменное количество элементов:

```csharp
static int Test(params int[] values)
{
    if (values != null)
    {
        ...
    }
}
//вызов метода
var v = Test();
var v = Test(new int[] {1, 2, 3});
var v = Test(1, 2, 3);
```

При передаче в качестве параметров сразу значений компилятор сам генерирует код, создающий и заполняющий массив.

## Типы параметров и вертаемых значений

Объявляя тип параметров метода, нужно указывать минимальные слабые типы, предпочитая интерфейсы классам. Это делает методы гибче.

```csharp
public void Sample<T>(IEnumerable<T> items) { ... }
public void Add<T>(IList<T> items) { ... }
```

Объявляя тип возвращаемого методом объекта, нужно выбирать максимальные сильные типы, при этом стараться чтоб и они были гибкими. Нужно выбирать самый сильный из самых слабых.

```csharp
public FileStream OpenFile() { ... }
public IList<string> GetCollection() { ... }
```

