# Методы

## Конструктор ссылочных типов

Конструкторы типа - специальные методы, корректно инициализирующие новый экземпляр типа. При создании экземпляра объекта ссылочного типа выделяется память для полей данных, инициализируются служебные поля и затем вызывается конструктор, устанавливающий исходное состояние объекта.

Конструкторы класса не наследуются. Если конструктор явно в классе не задать, то компилятор создаст неявный конструктор без параметров по умолчанию.

Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором защищенный. Для статических классов конструктор по умолчанию не создается. Производные классы от базового должны вызывать констрктор базового.

Всегда вызывается неявно конструктор базового класса System.Object без параметров. Поля, инициализирующиеся при определении неявно инициализируются в конструкторе без параметров.

```csharp
internal sealed class Sample
{
    private Int32 _value = 5;
}
```

Один конструктор может вызывать другой конструктор используя ключевое слово this.

```csharp
internal sealed class Sample
{
    private Int32 _value;
    public Sample()
    {
        _value = 5;
    }
    public Sample(Int32 value) : this() 
    {
        _value = value;
    }
}
```

## Конструктор значимых типов

CLR всегда разрешает создание экземпляров значимых типов. Конструкоры у значимых типов можно не определять. Компилятор не определяет конструктор по умолчанию не имеющий параметров для значимого типа. Поля значимого типа инициализируются нулями / null. 

CLR позволяет определять конструкторы для значимых типов, но они должны вызыватся только при наличии кода, явно вызывающего их.

```csharp
internal struct Test
{
    public Int32 _value;
    public Test(Int32 value)
    {
        _value = value;
    }
}
// использование
_test = new Test(1);
```

Тогда оператор new вызывает конструктор для инициализации полей значимого типа. 

Компилятор не генерирует автоматически код для вызова конструктора по умолчанию для значимого типа даже при наличии конструктора без параметров, нужно его явно вызвать.

Компилятор C# не позволяет определять для значимого типа явные конструкторы без параметров, только конструкторы с параметрами.

В значимый тип нельзя подставлять инициализацию экземплярных полей.

```csharp
internal struct SampleVal
{
    public Int32 _value;
    public SampleVal(Int32 value)
    {
        this = new SampleVal();
        _value = value;
    }
}
```

В конструкторе значимого типа this - экземпляр значимого типа, допускает запись, а в конструкторах ссылочного типа указатель this - только для чтения.

## Конструкторы типов

Также называют статическими конструкторами. Такие конструкторы можно применять к интерфейсам, ссылочным и значимым типам. Первоначально у типа не определено конструктора. Не может быть более 1 конструктора, у таких конструкторов нет параметров.

```csharp
internal sealed class Sample
{
    private static Int32 _value;
    static Sample()
    {     
        _value = 5;
    }
}
internal struct SampleVal
{
    static SampleVal()
    {
    }
}
```

Компилятор такие конструкторы делает зарытыми автоматически. 

>Конструкторы в значимом типе не следует определять, так как CLR не всегда вызывает статический конструктор значимого типа.

CLR старается гарантировать, чтобы конструктор типа выполнялся только раз в каждом домене приложений. Для этого при вызове конструктора типа вызывающий поток в рамках синхронизации потоков получает исключающую блокировку. Только первый поток выполнит код статического конструктора.

>Конструктор типов лучше всего подходит для инициализации всех объектов-одиночек.

Если в конструкторе типа генерируется необработанное исключение, то такой тип становится непригодным. Код из такого конструктора может использовать только статические поля класса.

В значимых типах допускается использовать конструкторы статические.

```csharp
internal struct SampleVal
{
    public Int32 _value;
    static SampleVal()
    {
        _value = value;
    }
}
```
