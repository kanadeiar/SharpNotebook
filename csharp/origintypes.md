# Основы типов

## Наследование

Все типы прямо или косвенно являются производными от System.Object. Все значимые типы наследуются от ValueType, а ValueType - от System.Object.

У класса System.Object есть следующие открытые экземплярные методы:

Equals() - сравнение двух объектов на равенство

GetHashCode() - возвращает хеш-код значения данного объекта

ToString() - возвращает полное имя типа, в некоторых типах переопределен

GetType() - невиртуальный метод возвращает экземпляр объекта, производнго от Type

Защищенные методы:

MemberwiseClone() - невиртуальный метод создает новый экземпляр типа и присваивает полям нового объекта соответствующие значения объекта this

Finalize() - Вызывается, когда уборщик мусора определяет, что объект является мусором, но до возвращения занятой объектом памяти в кучу

## Создание типа

Все объекты ссылочных типов по требованию CLR должны создаваться оператором new. Допустимо для нового значения применять вместо new литерал default. Можно использовать оператор new при создании примитивных типов. Можно не использовать имя типа после new при указании типа объека.

```csharp
Employee e = new Employee();
int myInt = 0;
int myInt = default;
int i = new int();
int i = new();
```

Оператор new выполняет следующие действия:

1. Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа и всех его базовых типов, в том числе System.Object. В каждый объект кучи дополнительно: указатель на объект-тип и индекс блока синхронизации. 

2. Выделение памяти для объекта с резервированием байтов в управляемой куче, инициализируются нулями (0).

3. Инициализация указателя на объект-тип и индекса блока синхронизации.

4. Вызов конструктора экземпляра типа с параметрами.

После этого он возвращает ссылку на вновь созданный объект. Ставшие ненужными или недоступными объекта среда CLR автоматически находит и освобождает.

## Неявно типизированные локальные переменные

C# поддерживает определения типа локальных переменных по типу использованных при их инициализации выражений.

```csharp
var name = "Test";
var x = (String)null;
var nums = new int[] {1,2,3};
var dict = new Dictionary<string, int>() { { "Test", 5 } };
```

В среде разработки Visual Studio при наведении мышки на ключевое слово var появляется предложенный тип.

## Пространства имен

Используя директиву using, можно писать более лаконичный код. Директивой using можно определить превдоним для пространства имен.

```csharp
using Sample.Text = Sample.Text;
```

## Приведение типов

Нет специального синтаксиса для приведения типа объекта к его базовому типу, но для приведения к произвольному от него - нужно ввести операцию явного приведения типов. Язык разрешает неявное приведение типа, если оно "безопасно", не приводит к потере точности данных. Для приведения связанного с потерей точности данных нужно явно указать приведение типа.

```csharp
Object o = new Employee();
Employee e = (Employee) o;
Int64 l = 5;
Byte b = (Byte) 5;
```

Если CLR не в состоянии выполнить приведение типов, то генерирует исключение System.InvalidCastException.

Оператор is проверяет совместимость объекта и типа и выдает булевский результат.

```csharp
if (o is Employee)
{
    Employee e = (Employee) o;
}
```

Можно применять оператор as, который проверяет совместимость типов и возвращяет объект или null.

```csharp
Employee e = o as Employee;
if (e != null)
{

}
```

## Проверяемые и непроверяемые операции

В С# программист сам решает, как обрабатывать переполнение при операциях над простыми типами данных. 

Без проверки:

```csharp
UInt32 invalid = unchecked((UInt32) -1); // OK
```

С проверкой:

```csharp
Byte b = 100; b = checked((Byte) (b + 200)); // OverflowException
```

```csharp
checked { 
    Byte b = 100;
    b += 200;
}
```


