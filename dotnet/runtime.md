# Core Runtime

Общеязыковая среда исполнения CLR это самодостаточная высокоуровневая виртуальная машина разработанная для поддержки разнообразнейших языков программирования и взаимодействия между ними.

Основные языки программирования: C#, C++/CLI, Visual Basic, F#, дополнительные: Iron Python, Iron Ruby, ассемблер Intermediate Laguage (IL). Для каждого языка используется свой компилятор, ориентированный на CLR. Результатом компиляции будет управляемый модуль (сборка). Все CLR компиляторы генерируют промежуточный IL-код (управляемый).

Для работы приложения .NET на целевой машине должен быть установлен .NET Framework, а именно CLR + BCL. BCL располагается в GAC. 

Для работы приложения .NET Core - нужен NET Core = Core CLR + Core FX (новое название для BCL). Иной способ загрузки среды выполнения (CLR). Вместо заголовка в управляемой сборке MyApp.exe в .NET Framework, в .NET Core MyApp.exe сам по себе является нативной программой загрузки Core CLR.

В .NET Core все компоненты программы, которые мы определяем на этапе компиляции, являются зависимостями приложения (включая Core CLR, JIT), которые инфраструктура .NET Core рассматривает как пакеты.

Зависимости в распакованном виде при запуске приложения должны находиться в одной из определенных директорий (папке .NET Core фреймворка — Core FX, папке приложения или любом NuGet-кеше).

## Части управляемого модуля

- Только для .NET Framework модулей создается Заголовок PE32 или PE32+. Файл с заголовком в формате PE32 может выполняться в 32- и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64-разрядной. Заголовок обозначает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран. В модулях, содержащих машинный код, этот заголовок содержит сведения о машинном коде.

- Заголовок CLR. Содержит информацию (интерпретируемую CLR и утилитами), которая превращает этот модуль или сборку в управляемый или управляемую. Заголовок включает нужную версию CLR, метку метаданных MethodDef точки входа в правляемый модуль (метод Main), а также месторасположение/размер метаданных модуля, ресурсов и пр.

- Метаданные. Каждый управляемый модуль содержит таблицы метаданных. Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены,  пределенные в исходном коде этой сборки, и таблицы, описывающие типы данных и их члены, на которые имеются ссылки из исходного кода.

- Код CIL. Код на общем промежуточном языке, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует CIL в машинные команды.

- Ресурсы. Изображения, файлы и прочее.

>Задачей среды выполнения CLR является преобразовать промежуточный код в исполняемый на ходу запуска экзешника программы. А это значит что программа будет работать там, где установлена среда .NET Framework.

## .NET Core Runtime

Для выполнения приложения на целевой должен быть установлен .NET Core Runtime (shared framework) в папку C:\Program Files\dotnet. Файлы фреймворка хранятся в папке C:\Program Files\dotnet\shared.

Можно установить несколько версий.

Состав фреймворка:

- Утилита dotnet.exe для запуска .NET Core приложения - драйвер инфраструктуры .NET Core, точка входа для запуска любых приложений и выполнения команд разработки. Является хост-процессом любог приложения - corehost.

- Runtime-компоненты устанавливаются в отдельную папку фреймворка C:\Program Files\dotnet\shared\[Framework name]\[Framework version].

- Нативная библиотека host framework resolver в папке C:\Program Files\dotnet\host\[версия]\hostfxr.dll. Максимальная версия выполняет разрешение версии фреймворка для последующего выполнения.

Для выполнения Portable-приложения необходимо запустить хост-процесс dotnet.exe и передать ему в качестве аргумента путь к управляемой сборке.

> dotnet path/to/App.dll

В папке приложения (там, где находится [AppName].dll) должен лежать файл [AppName].runtimeconfig.json. В нём указаны имя и версия фреймворка, которые должны быть использованы для выполнения Portable-приложения. Этот файл является обязательным для Portable-приложений.

## .NET Framework Runtime

В отличие от .NET Core старая платформа устанавливается по другому. Главный файл платформы mscoree.dll устанавливается в каталог %SystemRoot%\system32. Однако в 64 разрядных системах версия 32-разрядная лежит в каталоге %SystemRoot%\SysWow64, 64-разрядная - по предидущему пути. А файлы версий платформы .NET Framework должны лежать в каталогах %SystemRoot%\Microsoft.NET\Framework & %SystemRoot%\Microsoft.NET\Framework64. Утилита clrver.exe выводит список всех установленных версий.

## Приложение .NET Core

Состав .NET Core-приложения:

- [AppName].dll — IL-код приложения, точка входа.

- [App dependencies]*.dll — все зависимости приложения, не входящие в состав CoreFX (сборки проектов, сторонние библиотеки, FCL).

- [AppName].runtimeconfig.json — конфигурация среды выполнения, здесь указаны имя и версия .NET Core-фреймворка (runtime-компонентов). Файл является чем-то вроде MyApp.exe.config в .NET Frameowork. Эту конфигурацию можно изменять, если необходимо явно указать конкретный фреймворк.

- [AppName].deps.json — перечень всех зависимостей приложения. Не рекомендуется изменять этот файл, потому что он генерируется при компиляции. Файл не является обязательным, но если его удалить, хост-процесс при запуске не сможет проверить пути всех файлов зависимостей, и выполнение начнется на свой страх и риск.

## Процесс запуска приложения .NET Core

Запуск приложения выполняется при помощи мультплексора (muxer) из командной строки (одинаково на любой ОС).

> dotnet path\to\MyApp.dll

dotnet.exe — переименованный corehost.exe, эта программа является хост-процессом любого .NET Core-приложения, с неё начинается процесс запуска.

Исполняемый файл *.exe выполяет подобно ярлыку, выполняя описанную команду.

### [corehost] Поиск и загрузка Framework Resolver (hostfxr.dll)

На этом этапе dotnet.exe идет в папку [own directory]/host/fxr/. Для Portable-приложений эта библиотека расположена в общей папке C:\Program Files\dotnet\host\fxr\[FXR version]\hostfxr.dll. Если версий будет несколько, dotnet.exe будет всегда использовать последнюю.

После загрузки hostfxr.dll (Framework Resolver) процесс запуска переходит в рамки этой библиотеки.

### [hostfxr] Определение режима выполнения (standalone, muxer, split/FX)

Первая задача hostfxr — определить режим, в котором будет работать хост процесс и таким образом тип приложения — Portable (FDD) или Standalone (SCD). В Portable (FDD)-режиме он также определяет: это запускаемое приложение или команда SDK.

### [hostfxr] Определение .NET Core Runtime

Первым делом hostfxr определяет и загружает файлы конфигурации deps и runtimeconfig. Если ничего не переопределено в аргументах, эти файлы берутся из папки приложения.

### [hostfxr] Поиск и загрузка hostpolicy.dll

На текущем этапе всё готово для определения путей runtime-компонентов. Этой задачей занимается библиотека hostpolicy.dll, которая называется Host library.

Как только опеределена hostpolicy.dll, hostfxr загружает эту библиотеку и передает ей управление.

### [hostpolicy] Определение списка зависимостей

Библиотека hostpolicy.dll отвечает за определение абсолютных путей всех зависимостей приложения.

### [hostpolicy] Определение путей TPA, Core CLR и CLR Jit

Далее Dependency resolver составляет список абсолютных путей файлов управляемых сборок — зависимостей приложения. Этот список называется TPA (Trusted Platform Assemblies) и передается Core CLR для настройки AppDomain. Также составляется список абсолютных путей директорий, в которых находятся остальных файлы зависимостей (кроме coreclr, corejit).

Далее управление переходит к coreclr.dll.

### Заключение

- Компонентная модель .NET Core (Runtime, BCL) полностью состоит из NuGet-пакетов.

- Существует два типа развертывания — FDD и SCD. По возможности рекомендуется использовать Framework Dependent-развертывание, чтобы избежать сложностей с платформозависимыми компонентами и не поставлять лишние зависимости.

- Есть достаточно много возможностей повлиять на процесс запуска на целевой машине, и при необходимости переопределить/пропатчить файлы зависимостей, а также добавить неявные (динамически запускаемые) зависимости.

- Не рекомендуется без особых причин удалять или изменять файл Dependency manifest (*.deps.json) .

- Используя --additional-deps и --additionalprobepaths мы можем размещать runtime-компоненты в нужной нам файловой структуре.

- Используя Exec mode можно переопределить файлы конфигурации приложения.

[Источник](https://habr.com/ru/company/nix/blog/327686/)

## Процесс запуска .NET Framework

При запуске исполняемого файла Windows анализирует заголовок исполняемого файла для определения того, какое именно адресное пространство необходимо для его работы - 64-разрядное или 32-разрядное. 

Далее основной поток вызывает определенный в библиотеке mscoree.dll метод, который инициализирует CLR, загружает сборку exe и вызывает метод Main(), в котором содержится точка входа.

## Компилятор среды CLR

Перед исполнением метода Main() CLR находит все типы данных, на которые ссылается код метода Main(). 

Код преобразует из одного вида в другой специальный JIT (точно в срок - jit on time)-компилятор среды CLR. При запуске экзешника исполняемого файла среда CLR активирует JIT компилятор и он уже преобразует код IL в машинный код, ориентированный на конктектную процессорную архитектуру, например x86, x64 или ARM. Программа как бы выполняется как собственный код, при это обеспечивается переносимость превдокода IL.

JIT-компилятор хранит машинные команды в динамической памяти.

## Взаимодействие методов во время выполнения

Вначале был один процесс операционной системы с загруженной в него средой CLR. У процесса может быть несколько потоков. Потоку выделяется стек размером в 1 мегабайт. Выделенная память используется для передачи параметров в методы и хранения локальных переменных методов. Стек заполняется от области верхней памяти к обласи нижней памяти (от старших к младшим адресам). Вначале в стеке потока уже есть какие-то данные.

![Стек потока 1](../img/thread_stack_1.png) 

Все методы содержат входной код инициализации и выходной код очистки, чтобы возвратить управление вызывающей программе. Вначале выполнения метода M1 выходной код выделяет в стеке память для переменной локальной test.

![Стек потока 2](../img/thread_stack_2.png) 

Метод М1 вызывает метод М2, передавая в качестве параметра локальную переменную. При этом адрес переменной заталкивается в стек. Внутри метода М2 местоположение стека хранится в переменной s. При вызове метода адрес возврата в вызывающий метод М1 также заталкивается в стек.

![Стек потока 3](../img/thread_stack_3.png) 

Вначале выполнения метода М2 его входной код выделяет в стеке потока память для локальных переменных len & tally. 

![Стек потока 4](../img/thread_stack_4.png) 

После выполнения кода метода команда возврата записывает в указатель команд процессора адрес возврата из стека, и стековый кадр возращается в состояние без переменных метода М2. Продолжается выполнение кода М1, следующий за вызовом метода М2, а стековый кадр возвращается в состояние, необходимое для работы метода М1. 

![Стек потока 5](../img/thread_stack_5.png) 

После выполнения метода М1 команда возврата устанавливает указатель команд на адрес возврата, которая находится над переменнтой test в стеке. Продолжается выполнение кода сразу за вызовом метода М1 в вызывающей программе, стековый кадр находится в состоянии, необходимом для его работы.

![Стек потока 1](../img/thread_stack_1.png) 

## Взаимодействие классов во время выполнения

Определены следующие класса:

```csharp
internal class Employee 
{
    public Int32 GetYearsEmployed() {}
    public virtual String GetProgressReport() {}
    public static Employee Lookup(String name) {}
}
internal sealed class Manager : Employee
{
    public override String GetProgressReport() {}
}
```

Все объекты в куче содержать два дополнительных члена - указатель на объект-тип и индекс блока синхронизации. Статические поля данных выделяются в составе самих объектов-типов. У каждого объекта-типа есть таблица методов с входными точками всех методов, определенных в типе. В типе Employee - три метода, а в типе Manager - один метод.

Вначале был один процесс операционной системы с загруженной в него средой CLR. Инициализирована управляемая куча, создан поток с 1 мб памяти в стеке. Из внешней программы вызывается метод М3. 

![Стек потока 1](../img/heap_1.png) 

В процессе преобразования IL-кода метода М3 в машинные команды JIT-компилятор выявляет все типы, на которые есть ссылки в М3. CLR обеспечивает заргузку в домент приложений всех сборок с этими типами. Затем на основе метаданных сборки CLR создает структуры данных, представляющие эти типы.

![Стек потока 2](../img/heap_2.png) 

После создания всех необходимых для метода объекты-типы и компилирования кода метода М3 CLR начинает выполнять код М3. Вначале в стеке потока выделяется память для локальных переменых. CLR автоматически инициализирует все локальные переменные значением null или 0.

![Стек потока 3](../img/heap_3.png) 
