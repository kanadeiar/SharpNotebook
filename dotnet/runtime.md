# Среда исполнения

Общеязыковая среда исполнения CLR это самодостаточная высокоуровневая виртуальная машина разработанная для поддержки разнообразнейших языков программирования и взаимодействия между ними.

Основные языки программирования: C#, C++/CLI, Visual Basic, F#, дополнительные: Iron Python, Iron Ruby, ассемблер Intermediate Laguage (IL). Для каждого языка используется свой компилятор, ориентированный на CLR. Результатом компиляции будет управляемый модуль (сборка). Все CLR компиляторы генерируют промежуточный IL-код (управляемый).

Для работы приложения .NET Framework на целевой машине должен быть установлен .NET Framework, а именно CLR + BCL. BCL располагается в GAC. 

Для работы приложения .NET Core - нужен NET Core = Core CLR + Core FX (новое название для BCL). Иной способ загрузки среды выполнения (CLR). Вместо заголовка в управляемой сборке MyApp.exe в .NET Framework, в .NET Core MyApp.exe сам по себе является нативной программой загрузки Core CLR.

В .NET Core все компоненты программы, которые мы определяем на этапе компиляции, являются зависимостями приложения (включая Core CLR, JIT), которые инфраструктура .NET Core рассматривает как пакеты.

Зависимости в распакованном виде при запуске приложения должны находиться в одной из определенных директорий (папке .NET Core фреймворка — Core FX, папке приложения или любом NuGet-кеше).

## Части управляемого модуля

- Только для .NET Framework модулей создается Заголовок PE32 или PE32+. Файл с заголовком в формате PE32 может выполняться в 32- и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64-разрядной. Заголовок обозначает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран. В модулях, содержащих машинный код, этот заголовок содержит сведения о машинном коде.

- Заголовок CLR. Содержит информацию (интерпретируемую CLR и утилитами), которая превращает эту сборку в управляемую. Заголовок включает информацию: название нужной версии CLR, метку метаданных MethodDef, указатель на точку входа в управляемый модуль (метод Main), а также месторасположение/размер метаданных модуля, ресурсов и пр.

- Метаданные. Каждый управляемый модуль содержит таблицы метаданных. Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены, пределенные в исходном коде этой сборки, и таблицы, описывающие типы данных и их члены, на которые имеются ссылки из исходного кода.

- Код CIL. Код на общем промежуточном языке, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует CIL в машинные команды.

- Ресурсы. Изображения, файлы и прочее.

>Задачей среды выполнения CLR является преобразовать промежуточный код в исполняемый на ходу запуска исполняемого файла программы. А это значит что программа будет работать там, где установлена среда .NET.

## .NET Core Runtime

Для выполнения приложения на целевой должен быть установлен .NET Core Runtime (shared framework) в папку C:\Program Files\dotnet. Файлы фреймворка хранятся в папке C:\Program Files\dotnet\shared.

Можно установить несколько версий.

Состав фреймворка:

- Утилита dotnet.exe для запуска .NET Core приложения - драйвер инфраструктуры .NET Core, точка входа для запуска любых приложений и выполнения команд разработки. Является хост-процессом любого приложения - corehost.

- Runtime-компоненты устанавливаются в отдельную папку фреймворка C:\Program Files\dotnet\shared\[Framework name]\[Framework version].

- Нативная библиотека host framework resolver в папке C:\Program Files\dotnet\host\[версия]\hostfxr.dll. Максимальная версия выполняет разрешение версии фреймворка для последующего выполнения.

Для выполнения Portable-приложения необходимо запустить хост-процесс dotnet.exe и передать ему в качестве аргумента путь к управляемой сборке.

> dotnet path/to/App.dll

В папке приложения (там, где находится [AppName].dll) должен лежать файл [AppName].runtimeconfig.json. В нём указаны имя и версия фреймворка, которые должны быть использованы для выполнения Portable-приложения. Этот файл является обязательным для Portable-приложений.

## .NET Framework Runtime

В отличие от .NET Core старая платформа устанавливается по другому. Главный файл платформы mscoree.dll устанавливается в каталог %SystemRoot%\system32. Однако в 64 разрядных системах версия 32-разрядная лежит в каталоге %SystemRoot%\SysWow64, 64-разрядная - по предидущему пути. А файлы версий платформы .NET Framework должны лежать в каталогах %SystemRoot%\Microsoft.NET\Framework & %SystemRoot%\Microsoft.NET\Framework64. Утилита clrver.exe выводит список всех установленных версий.

## Приложение .NET Core

Состав .NET Core-приложения:

- [AppName].dll — IL-код приложения, точка входа.

- [App dependencies]*.dll — все зависимости приложения, не входящие в состав CoreFX (сборки проектов, сторонние библиотеки, FCL).

- [AppName].runtimeconfig.json — конфигурация среды выполнения, здесь указаны имя и версия .NET Core-фреймворка (runtime-компонентов). Файл является чем-то вроде MyApp.exe.config в .NET Frameowork. Эту конфигурацию можно изменять, если необходимо явно указать конкретный фреймворк.

- [AppName].deps.json — перечень всех зависимостей приложения. Не рекомендуется изменять этот файл, потому что он генерируется при компиляции. Файл не является обязательным, но если его удалить, хост-процесс при запуске не сможет проверить пути всех файлов зависимостей, и выполнение начнется на свой страх и риск.

## Процесс запуска приложения .NET Core

Запуск приложения выполняется при помощи мультплексора (muxer) из командной строки (одинаково на любой ОС).

> dotnet path\to\MyApp.dll

dotnet.exe — переименованный corehost.exe, эта программа является хост-процессом любого .NET Core-приложения, с неё начинается процесс запуска.

Исполняемый файл *.exe выполяет подобно ярлыку, выполняя описанную команду.

### [corehost] Поиск и загрузка Framework Resolver (hostfxr.dll)

На этом этапе dotnet.exe идет в папку [own directory]/host/fxr/. Для Portable-приложений эта библиотека расположена в общей папке C:\Program Files\dotnet\host\fxr\[FXR version]\hostfxr.dll. Если версий будет несколько, dotnet.exe будет всегда использовать последнюю.

После загрузки hostfxr.dll (Framework Resolver) процесс запуска переходит в рамки этой библиотеки.

### [hostfxr] Определение режима выполнения (standalone, muxer, split/FX)

Первая задача hostfxr — определить режим, в котором будет работать хост процесс и таким образом тип приложения — Portable (FDD) или Standalone (SCD). В Portable (FDD)-режиме он также определяет: это запускаемое приложение или команда SDK.

### [hostfxr] Определение .NET Core Runtime

Первым делом hostfxr определяет и загружает файлы конфигурации deps и runtimeconfig. Если ничего не переопределено в аргументах, эти файлы берутся из папки приложения.

### [hostfxr] Поиск и загрузка hostpolicy.dll

На текущем этапе всё готово для определения путей runtime-компонентов. Этой задачей занимается библиотека hostpolicy.dll, которая называется Host library.

Как только опеределена hostpolicy.dll, hostfxr загружает эту библиотеку и передает ей управление.

### [hostpolicy] Определение списка зависимостей

Библиотека hostpolicy.dll отвечает за определение абсолютных путей всех зависимостей приложения.

### [hostpolicy] Определение путей TPA, Core CLR и CLR Jit

Далее Dependency resolver составляет список абсолютных путей файлов управляемых сборок — зависимостей приложения. Этот список называется TPA (Trusted Platform Assemblies) и передается Core CLR для настройки AppDomain. Также составляется список абсолютных путей директорий, в которых находятся остальных файлы зависимостей (кроме coreclr, corejit).

Далее управление переходит к coreclr.dll.

### Заключение

- Компонентная модель .NET Core (Runtime, BCL) полностью состоит из NuGet-пакетов.

- Существует два типа развертывания — FDD и SCD. По возможности рекомендуется использовать Framework Dependent-развертывание, чтобы избежать сложностей с платформозависимыми компонентами и не поставлять лишние зависимости.

- Есть достаточно много возможностей повлиять на процесс запуска на целевой машине, и при необходимости переопределить/пропатчить файлы зависимостей, а также добавить неявные (динамически запускаемые) зависимости.

- Не рекомендуется без особых причин удалять или изменять файл Dependency manifest (*.deps.json) .

- Используя --additional-deps и --additionalprobepaths мы можем размещать runtime-компоненты в нужной нам файловой структуре.

- Используя Exec mode можно переопределить файлы конфигурации приложения.

[Источник](https://habr.com/ru/company/nix/blog/327686/)

## Процесс запуска .NET Framework

При запуске исполняемого файла Windows анализирует заголовок исполняемого файла для определения того, какое именно адресное пространство необходимо для его работы - 64-разрядное или 32-разрядное. 

Далее основной поток вызывает определенный в библиотеке mscoree.dll метод, который инициализирует CLR, загружает сборку exe и вызывает метод Main(), в котором содержится точка входа.

## Компилятор среды CLR

Перед исполнением метода Main() CLR находит все типы данных, на которые ссылается код метода Main(). 

Код преобразует из одного вида в другой специальный JIT (точно в срок - jit on time)-компилятор среды CLR. При запуске экзешника исполняемого файла среда CLR активирует JIT компилятор и он уже преобразует код IL в машинный код, ориентированный на конктектную процессорную архитектуру, например x86, x64 или ARM. Программа как бы выполняется как собственный код, при это обеспечивается переносимость превдокода IL.

JIT-компилятор хранит машинные команды в динамической памяти.

