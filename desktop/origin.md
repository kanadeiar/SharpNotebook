# Основы

Стандартное Windows Forms приложение при создании пользовательского интерфейса основано на двух системах Windows:

- User32 - обеспечивает знакомый внешний вид и поведение таких элементов, как окна, кнопки, текстовые поля.

- GDI/GDI+ - дают поддержку рисования фигур, текста и изображений за счет дополнительного усложнения.

Лежащая в основе WPF графическая технология - это DirectX. Однако WPF по прежнему полагается на User32 в отношении таких служб, как обработка и маршрутизация ввода, а также определение того, какое приложение какой частью экрана владеет. Но все рисование производится через DirectX.

Программисты .NET имеют единственный симметричный API-интерфейс для всех распространенных потребностей при использовании WPF для разработки графических настрольных приложений.

## Введение

Класс System.Windows.Application - глобальный экземпляр выполняющегося приложения WPF с методом Run() для запуска приложения и набором событий для обработки взаимодействия с приложением.

Методы этого класса:

- Current - Статическое свойство получение доступа к работающему объекта Application из любого места кода

- MainWindow - Свойство главного окна приложения

- Properities - Свойство данных, доступных через все аспекты прилжения WPF

- StartupUri - Свойство указывающее окно или страница для автоматического открытия при запуске приложения

- Windows - Дает объект типа WindowCollection, дающее доступ ко всем окнам, созданным в потоке, создавшем объект Application.

Класс System.Windows.Controls.ContentControl является родительским для класа Window, срабжающий все производные класса способностью размещать в себе одиночный фрагмент содержимого через свойство Content.

Пример:

```csharp
<Button Height="40" Width="80" Content="OK"></Button>
```

Класс System.Windows.Controls.Control является базовым для всех элементов управления WPF, снабжая их основной функциональностью пользовательского интерфейса.

Класс System.Windows.FrameworkElement дает несколько членов применяемых повсюду для раскадровки, привязки данных, именования элементов, получения ресурсов и установки общих измерений производноо типа.

Класс System.Windows.UIElement обеспечивает наибольший объем функциональности, дает производному типу многочисленные события, чтоб мог получать фокус и обрабатывать входные запросы.

Класс System.Windows.Media.Visual дает поддержку визуализации в WPF.

Класс System.Windows.DependencyObject дает поддержку разновидности свойств - свойств зависимости - в WPF.

Класс System.Windows.Threading.DispatcherObject дает поддержку очередни событий в WPF, для организации параллелизма и многопоточности.

Приложения WPF используют однопоточную модель, весь пользовательский интерфейс принадлежит единственному потоку.

Ключевые принципы WPF приложений:

- Аппаратное ускорение. Рисование производится через DirectX.

- Независимость от разрешения. Технология WPF гибкая и подстраивается под разрешение экрана.

- Отсутствие фиксированного внешнего вида элементов управления. Все рисуется посредством механизма визуализации и является полностью настроиваемым.

- Декларативный пользовательский интерфейс. XAML - стандарт языка разметки, который используется для определения пользовательских интерфейсов WPF. Позволяет строить окна без кода.

- Риование на основе объектов. Рисование производится не пикселами, а объектами фигур.

## Разрешение экрана

WPF приложения не зависят от разрешения экрана, они самостоятельно визуализируют все элементы пользовательского интерфейса. На более высоких разрешениях WPF визуализирует все более детализированно, с большим количеством пикселей. 

WPF базирует свое масштабирование на системной установке DPI, а не на DPI физического графического устройства.

Окно WPF и все его элементы измеряются в независимых от устройств еденицах. Ее значение - 1/96 дюйма. 

В зависимости от разрешения графического устройства элементы масштабируются по значению плотности пикселей DPI.

## Инфраструктура

Инфраструктура WPF - коллекция типов, втроенных в сборки .NET.

Инфраструктура WPF определеяет способ отделения внешнего вида и поведения приложения с графическим пользовательским интерфейсом от программной логики. Пользовательский интерйейс пишется на языке XAML через разметку XML - "настольную разметку", с помощью инструментов Microsoft Visual Studio или Microsoft Expression Blend, затем может быть подключена к связанном файлу кода. Допустимо изменять внешний вид элемента управления только с помощью разметки. Модель WPF отличается от других тем, что визуализация графических данных происходит через API-интерфейс DirectX, а GDI не используется. Приложения WPF автоматом получают аппараткую и программную оптимизацию, могут задействовать графические службы без сложностей, присущих программированию напрямую через API DirectX.

WPF - API-интерфейс, предназначенный для построения настольных приложений, который интегрирует разнообразные настольные API-интерфейсы в единую объектную модель и обеспечивает четкое разделение обязанностей через XAML.

Основные функциональные возможности WPF:

- множество диспетчеров компоновки для гибкого контроля над размещением и изменением содержимого

- расширенный механизм привязок данных для связывания содержимого с элементами пользовательского интерфейса

- встроенный механизм стилей, позволяющий определять темы приложения

- векторная графика для автоматического изменения размеров содержимого с целью соответтсвия размерам и разрешению экрана

- поддержка двухмерной и трехмерной графики, анимации, аудио и видео

- типографичкский API-интерфейс, поддерживающий документы XML, фиксированные документы, нефиксированные документы и аннотации в документах

- взаимодействие с унаследованными моделями графических пользовательских интерфейсов

## Строительство приложения

Строительство типичного WPF приложения. После создания проекта WPF по умолчанию утанавливаются ссылки на все сборки WPF (PresentationCore.dll, PresentationFramework.dll, System.Xaml.dll и WindowsBase.dll) в XAML файле и файле кода C#.

В файле App.xaml посредством разметки определен класс приложения. Там определены свойства приложения, такие как StartupUri (окно, подлежащее загружке при запуске), ресурсы уровня приложения и специфические обработчики для событий приложения вроде Startup и Exit. Пример разметки и добавленных обработчиков событий запуска приложения и закрытия приложения:

Файл App.xaml & App.xaml.cs:

```csharp
<Application x:Class="WpfApp1.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:WpfApp1"
             StartupUri="MainWindow.xaml"
             Startup="App_OnStartup" Exit="App_OnExit">
    <Application.Resources>
    </Application.Resources>
</Application>
public partial class App : Application
{
    private void App_OnStartup(object sender, StartupEventArgs e)
    {
    }
    private void App_OnExit(object sender, ExitEventArgs e)
    {
    }
}
```

Утилита msbuild.exe при построении приложения для каждого файла XAML создает в проекте три файла: *.g.cs (g - автогенерируемый), *.g.i.cs (i - IntelliSense) и *.baml (BAML - двоичный язык разметки приложений). Эти файлы сохраняются в папке \obj\Debug.

А в файле BAML - компактное двоичное представление исходных данных XAML. Он встраивается в виде ресурса в скомпилированную сборку, он встраивается в конечное приложение и при каждом выполенеии приложения он извлекается из контейнера ресурсов и применяется для настройки внешнего вида и поведения всех окон и элементов управления.

В файле App.g.cs содержится автоматически сгенерированный метод Main(), инициализирующий и запускающий приложение. Метод InitializeComponent() конфигурирует свойства приложения, запускаемое окно и обрботчики событий.

В классе Application есть свойство Properties, позволяющее определить коллекцию пар "имя/значение" через индексатор типа System.Object. В эту коллекцию можно сохранять все что угодно с целью последующего извлечения по дружественному имени:

```csharp
Application.Current.Properties["Test"] = true;
if ((bool) Application.Current.Properties["Test"])
    MessageBox.Show("Есть!");
```

Инфраструктура WPF предлагает события для выяснения, действительно ли пользователь намерен закрыть окно. Одно из них - Cloaing в сочетании с делегатом CancelEventHandler, а он предоставляет свойство Cancel, установка оного в true предотвращает закрытие окна. А другое событие - Closed - точка, где окно полностью и безвозвратно готово к закрытию.

Пример применения запроса на подтверждение закрытия окна с данными событиями:

```csharp
public MainWindow()
{
    InitializeComponent();
    this.Closing += MainWindow_Closing;
    this.Closed += MainWindow_Closed;
}
private void MainWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
{
    MessageBoxResult result = MessageBox.Show("Действительно закрыть окно?", "Приложение",
        MessageBoxButton.YesNo, MessageBoxImage.Question);
    if (result == MessageBoxResult.No)
        e.Cancel = true; //отмена закрытия окна
}
private void MainWindow_Closed(object sender, EventArgs e)
{
    MessageBox.Show("Пока!");
}
```

Инфраструктура WPF дает несколько событий, помогающих взаимодействоввать с мышью. Определяются связанные с мышью события - MouseMove, MouseUp, MouseDown, MouseEnter, MouseLeave и др. Метод GetPosition() позволяет получать значение (x, y) относительного элемента пользовательского интерфейса в окне.

Пример:

```csharp
public MainWindow()
{
    InitializeComponent();
    this.MouseMove += MainWindow_MouseMove;
}
private void MainWindow_MouseMove(object sender, MouseEventArgs e)
{
    this.Title = e.GetPosition(this).ToString();
}
```

Очень проста обработка клавиатурного ввода окна, на котором находится фокус. Это события - KeyUp, KeyDown, работающие с делегатом System.Windows.Input.KeyEventHandler.

Пример:

```csharp
public MainWindow()
{
    InitializeComponent();
    this.KeyDown += MainWindow_KeyDown;
}
private void MainWindow_KeyDown(object sender, KeyEventArgs e)
{
    this.Title = e.Key.ToString();
}
```

