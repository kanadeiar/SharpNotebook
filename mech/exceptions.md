# Исключения

В .NET и всех языках платформы существует специальный механизм обработки исключений.

При проектировании метода следует учитывать все возможные ситуации. Но это никогда не удается, код может быть использован где угодно и как угодно.

Если член программы не может решить возложенную на него задачу, то программа должна выдать исключение. 

## Структурная обработка исключений

В основе обработки исключений .NET лежит структурная обработка исключений Windows. 

Пример конструкции обработки исключений:

```csharp
try
{
    //код требующий восстановления при сбое и очистки ресурсов
}
catch (IOException ex)
{
    //код восстановления после сбоя
}
catch
{
    throw;
}
finally
{
    //очистка ресурсов
}
//код после основного кода
```

### Блок try

Сюда помещается код, требующий очистки ресурсов и восстановления после сбоя.

### Блок catch

Выражение в скобках после ключевого слова catch называется типом исключения, это как правило класс System.Exception и его производные классы. 

Поиск подходящего блока происходит сверху вниз, сверху - наиболее конкретные типы исключений. Если во всех блоках не было найдено нужного типа в блоке catch, то такое исключение считается необработанным.

После того как код внутренних блоков finally (в секции try) будет выполнен, исполняется код из обрабатывающего блока catch.

Как можно обработать исключение:

- Еще раз сгенерировть исключение для передачи информации о коде вверх по стеку.

- Сгенерировать новое исключение для кода выше по стеку.

- Позволить программному коду выйти из блока catch и продолжить выполнение естественным путем.

В конце происходит переход к блоку finally (если он, конечно, существует). После выполнения всего содержащегося в нем кода управление переходит к расположенной после блока finally инструкции. Если блок finally отсутствует, поток переходит к инструкции, расположенной за последним блоком catch.

В C# после типа перехватываемого исключения можно указать имя переменной, которая будет ссылаться на сгенерированный объект, потомок класса System.Exception. В коде блока catch эту переменную можно использовать для получения информации об исключении.

### Блок finally

Код этого блока выполняется всегда. Сюда следует помещать код освобождения занимаемых ресурсов.

## Класс Exception

Исключения этого класса и производных от него классов должны перехватываться во всех CLS-совместимых языках программирования платформы .NET. 

Этот тип содержит некоторый набор свойств, эти свойства ищут в отчете отладчика или в аварийном дампе памяти после прекращения работы приложения из-за необработанного исключения.

При появлении исключения CLR делает запись с указанием места его возникновения. Когда блок catch получает исключение, CLR записывает, где именно оно было обнаружено.

Нужно так повторно вызывать исключение, чтоб не происходила перезапись стека:

```csharp
catch (Exception e) {
throw; // CLR не меняет информацию о начальной точке исключения.
}
```

В результате трассировки можно обнаружить, что имена некоторых методов отсутствуют. В стеке содержится информация о том, куда должен вернуть управление поток, а не откуда произошло обращение. Компилятор может выполнить подстановку кода методов в вызывающий код, чтоб избежать слишком большого числа вызовов.

## Генерирование исключений

При генерировании исключения следует продумать какой код на верхнем уровне будет обрабатывать исключение. Исходя из этого выбрать подходящий тип, если такого типа нет, то создать новый производный тип от класса System.Exception. Никогда не следует генерировать исключения System.Exception.

Нужно продумать сообщение об ошибке, которое будет подробно сообщать о том, почему метод не смог решить свою задачу. 

## Создание классов исключений

Процесс создания классов исключений трудоемок и может порождать ошибки. 

Базовый обобщенный класс исключений:

```csharp
[Serializable]
public abstract class ExceptionArgs
{
    public virtual string Message => string.Empty;
}
[Serializable]
public sealed class Exception<TArgs> : Exception, ISerializable where TArgs : ExceptionArgs
{
    private const string __args = "Args";
    private readonly TArgs _args;
    public TArgs Args => _args;
    public Exception(string message = null, Exception innerException = null)
    : this(null, message, innerException)
    { }
    public Exception(TArgs args, string message = null, Exception innerException = null)
    : base(message, innerException)
    {
        _args = args;
    }
    [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
    private Exception(SerializationInfo info, StreamingContext content) : base(info, content)
    {
        _args = (TArgs)info.GetValue(__args, typeof(TArgs));
    }
    [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        base.GetObjectData(info, context);
    }
    public override string Message
    {
        get
        {
            var s = base.Message;
            return (_args == null) ? s : s + " (" + _args.Message + ")";
        }
    }
    public override bool Equals(object? obj)
    {
        var other = obj as Exception<TArgs>;
        if (obj == null)
            return false;
        return object.Equals(_args, other._args) && base.Equals(obj);
    }
    public override int GetHashCode() => base.GetHashCode();
}
// пример конкретного класса с данными исключений
[Serializable]
public sealed class SampleExceptionArgs : ExceptionArgs
{
    private readonly string _message;
    public SampleExceptionArgs(string message)
    {
        _message = message;
    }
    public override String Message => _message;
}
```

Этот обобщенный класс и класс сообщения определены в пространстве имен Kanadeiar.Core.Exceptions в библиотеке Kanadeiar.Core.

Пример применения обобщенного исключения:

```csharp
try
{
    throw new Exception<SampleExceptionArgs>(new SampleExceptionArgs("Test"));
}
catch (Exception<SampleExceptionArgs> ex)
{
    Console.WriteLine(ex.Message + " " + ex.Args.Message);
}
```

## Приемы работы с исключениями

При разработке библиотек классов и типов, написанный код не должен решать что есть ошибка, а что - нет, это должен решать вызывающий код.

При разработке приложения нужно определять любую политику обработки исключений, какую нужно.

Нужно активно использовать блок finally.

Не нужно перехватывать все исключения. Перехватывая исключение, вы тем самым заявляете, что ожидали его,понимаете его причины и знаете, как с ним разобраться.

Число необработанных исключений в окончательной версии программы, предназначенной для выполнения в производственной среде, должно быть минимальным, а сама программа должна быть исключительно устойчивой.

Перехват и поглощение (без повторного генерирования) исключения System.Exception недопустимо, так как оно приводит к сокрытию факта сбоя и продолжению работы приложения с непредсказуемыми результатами, что означает нарушение безопасности.

Иногда заранее известно, источником какого исключения может стать метод. Поскольку эти исключения ожидаемы заранее, нужен код, обеспечивающий корректное восстановление приложения в такой ситуации и позволяющий ему продолжить работу.

