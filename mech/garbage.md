# Сборщик мусора

## Управляемая куча

В объектно-ориентированной среде каждый тип идентифицирует доступный программе ресурс. Чтобы им воспользоваться, должна быть выделена память.

Правило 1. Используя ключевое слово new, поместите экземпляр класса в управляемую кучу и забудьте о нем.

Этапы:

- Выделить память для типа, предоставляющего ресурс.

- Инициализировать выделенную память, установив начальное значение ресурса и сделав его пригодным к использованию.

- Использовать ресурс, обращаясь к его членам.

- Уничтожить состояние ресурса в рамках очистки.

- Освободить память, этим занимается сборщик мусора.

В управляемом коде как правило утечки памяти происходят, когда приложение хранит объекты в коллекции, но не удаляет их, когда они становятся ненужными. Чаще всего утечка памяти возникает из-за хранения в статическом поле ссылки на коллекцию, в которую добавляются элементы. 

Для большинства типов очистка ресурсов ненужна, память просто освобождается сборщиком мусора.

Для некоторых типов, требующих специальной очистки, когда очистка ресурса должна произойти как можно раньше, не дожидаясь уборщика мусора, требуется выполнить дополнительный метод (Dispose). Как правило, это типы, использующие низкоуровневые ресурсы - файлы, сокеты, подключения к базе данных.

### Выделение памяти

При инициализации процесса CLR резервирует область адресного пространства под управляемую кучу, а также инициалиирует указатель, показывающий, где в куче будет выделяться память для следующего объекта (изначально указывает на базовый адрес).

По мере ее заполнения CLR увеличивает эту область.

При выполнении оператора new:

- Подсчитывание количества байтов, необходимых для размещения полей типа и всех полей всех базовых классов.

- Прибавка к полученному значению количество байтов, необходимых для размещения системных полей объекта (указатель на объект-тип и индекс блока синхронизации - в 32-х разрядных это 8 байт, в 64-х разрядных это 16 байт).

- Проверка что хватает места в выделенной области для размещения объекта. Если места достаточно, то выделяется память на указателе, байты обнуляются, вызывается конструктор типа и оператор new возвращает ссылку на объект. Указатель кучи смещается дальше, указывать на свободное место для следующего объекта.

Выделение памяти сводится к перемещению указателя, многие объекты находятся вплотную друг к другу, повышая производительность.

## Уборка мусора

Правило 2. Если в управляемой куче не хватает пространства для размещения требуемого объекта, то произойдет сборка мусора.

Когда памяти не хватает CLR выполняет уборку мусора. CLR использует алгоритм отслеживания ссылок. Работает только с переменными ссылочного типа. Все такие переменные называтся корнями.

Когда CLR запускает уборку мусора, она сначала приостанавливает все программные потоки в процессе. 

Затем происходит этап маркировки. CLR устанавливает у всех объектов в куче в поле индекса блока синхронизации значение 0. Затем CLR проверяет все активные корни и объекты, на которые они ссылаются. Если корень ссылается на объект - в его индексе устанавливается бит. После маркировки объекта уже проверяются корни этого объекта и маркируются другие объекты. Маркированные объекты переживут уборку мусора, так как на них ссылается хотяб кто-то. 

Далее следует этам сжатия. В этой фазе CLR перемещает вниз все немусорные объекты в куче, чтоб они плотно располагались. В фазе сжатия CLR вычисляет из каждого корня количество байт, на которое был сдвинут объект. 

Далее указатель кучи устанавливается на первый бит свободного пространства, где будет далее выделяться память для нового объекта. 

После этого возобновляется выполение потоков в процессе.

Как только объект становится недостижим - он становится кандидатом на удаление и не всегда доживает до завершения работы метода.

## Поколения

Особенности сборщика мусора на основе поколений:

- Чем младше объект, тем короче время его жизни;

- Чем старше объект, тем длиннее его время жизни;

- Уборка мусора в части кучи выполняется быстрее, чем во всей куче.

Сразу после инициализации все помещаемые в кучу объекты составляют поколение 0. Как только в результате выделения памяти для нового объекта размер поколения 0 превысит пороговое значение, должна начатся уборка мусора.

Объекты, пережившие сборку мусора, составляют поколение 1. Далее новые добавляемые объекты будут составлять поколение 0. И так пока поколение 0 не превысит пороговое значение. Как только превысит - проверяется превышение порогового значения поколением 1, оно гораздо реже превышается и сборка мусора происходит только в поколении 0.

Поколение 1 постоянно растет. Как только превысит пороговое значение, среди него начинается уборка мусора, и все пережившие уборку объекты из поколения 1 переходят в поколение 2. 

Управляемая куча поддерживает только три поколения. При инициализации устанавливаются пороговые значения для всех трех поколений. В процессе работы уборщик мусора сам самонастраивается.

## Запуск уборщика

Запуск уборки мусора происходит, когда объем поколения 0 достигает порогового значения, либо вызов статического метода GC.Collect(). Если памяти не хватит, то Windows сообщает о нехватке памяти, происходит выгрузка домена приложения, происходит завершение работы CLR.

## Большие объемы

CLR делит объекты на малые и большие. Любые объекты с размером 85 килобайт считаются большими. С такими большими объектами CLR работает по-другому:

- Память для них выделяется в отдельном адресном пространстве процесса.

- К большим объектам не применяется сжатие, так как на их перемещение затратится слишком много времени.

- Большие объекты всегда считаются поколением 2. 

## Режимы уборщика

Существуют два режима уборки мусора:

- Режим рабочей станции. Оптимизирован для минимизации времени остановок, старается не занимать слишком много процессорного времени.

- Режим сервера. Так как не существует других запущенных процессов, можно все ресурсы процессора использовать для сборки мусора. Управляемая куча делиться между процессорами компьютера. Каждый поток выполняется в собственном разделе одновременно с другими процессами.

Кроме этих, у сборщика еще есть режимы работы:

- Параллельный (обычно) - есть дополнительный рабочий поток, выполняющий пометку объектов во время работы. Когда работают все потоки приложения отдельный поток уборщика находит все недоступные объекты в фоновом режиме. 

- Непараллельный.

При параллельной уборке обычно расходуется больше памяти, чем при непараллельной уборке.

## Программное управление уборщиком

Тип System.GC позволяет приложению напрямую управлять уборщиком мусора.

Этот метод запускает уборку мусора:

```csharp
void Collect(Int32 generation, GCCollectionMode mode, Boolean blocking)
```

Можно указать поколение, в котором выполнить сборку мусора, способ уборки и вид уборки - блокирующий или параллельный.

Следует избегать вызова этого метода, так как среда CLR сама выполнит уборку в нужное время.

## Освобождение ресурсов

Есть некоторые типы, которым помимо памяти необходимы системные ресурсы.

Чтобы в ходе сборки мусора системный ресурс не был потерян, применяется механизм финализации, позволяющий объекту выполнить корректную очистку, прежде чем сборщик мусора освободит занимаемую им память. Любой тип с системным ресурсом должен поддерживать финализацию. 

Базовый класс System.Object содержит виртуальный метод Finalize, который вызывается сборщиком мусора. Для определения финализатора в синтаксисе C# нужно перед именем класса поставить знак тильды. Компилятор C# создает специальный защищенный метод Finalize для этого класса.

Так как финализируемый объект должен пережить уборку мусора, он переводится в другое поколение, вследствие
чего такой объект живет намного дольше, чем следует. Ситуация не идеальна в отношении использования памяти, поэтому финализации следует по возможности избегать.

Методы Finalize выполняются при выполнении уборки мусора, которая может произойти тогда, когда ваше приложение запросит дополнительную память. Для вызова методов Finalize CLR использует специальный высокоприоритетный поток.

Пример использования конструкции использования класса, реализующего интерфейс IDisposable:

```csharp
void Method()
{
    using (var file = File.Open("test.txt", FileMode.Open))
    {
        ...
    }
}
```

Компилятор преобразует это в try - finally, в блоке finally - вызов Dispose.

Можно применять объявления using, тогда не нужно помещать код в скобки:

```csharp
void Method()
{
    using var file = File.Open("test.txt", FileMode.Open);
    ...
}
```

## Внутренняя реализация финализации

Когда создается новый объект, оператор new вертает ссылку на новый объект в куче. Если в типе объекта определен метод финализации, то перед вызовом конструктора экземпляра типа указатель на объект помещается в список финализации сборщика мусора. Каждая запись этого списка указывает на объект, для которого нужно будет вызвать метод финализации, прежде чем освободить память. 

Когда уборщик определит объекты как мусор, он сканирует список финализации, и все что найдет - добавит в конец очереди на финализацию. 

В CLR есть особый высокоприоритетный поток, выделенный для вызова методов финализации. Он нужен для предотвращения возможных проблем синхронизации, которые могли бы возникнуть при использовании вместо него одного из потоков приложения с обычным приоритетом.

Если объект недоступен, уборщик считает его мусором. Далее, когда уборщик перемещает ссылку на объект из списка финализации в очередь на финализацию, объект перестает считаться мусором, а это означает, что занятую
им память освобождать нельзя. На этом этапе уборщик завершает поиск мусора, и некоторые объекты, идентифицированные как мусор, перестают считаться таковым — они как бы воскресают.

По мере маркировки объектов из очереди другие объекты, на которые ссылаются их поля ссылочного типа, также рекурсивно помечаются — все эти объекты должны пережить уборку мусора. На этой стадии уборщик мусора завершил выявление мусора, а некоторые объекты, отнесенные к мусору, были воскрешены. Уборщик мусора сжимает освобожденную память, воскрешенные объекты переводятся в более старое поколение, а особый поток CLR очищает очередь на финализацию, выполняя метод финализации для каждого объекта из очереди.

Вызванный снова, уборщик обнаруживает, что финализированные объекты стали мусором, так как ни корни приложения, ни очередь на финализацию больше на них не указывают. Память, занятая этими объектами, попросту освобождается. 

Важно понять, что для освобождения памяти, занятой объектами, требующими финализации, уборку мусора нужно выполнить дважды.



