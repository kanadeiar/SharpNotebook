# Асинхронный конечный автомат

Подробно о преобразовании асинхронного кода, осуществляемом компилятором. Механизм async реализован в компиляторе C# при поддержке со стороны библиотек базовых классов .NET.

При компиляции асинхронный метод компилятор преобразует в структуру конечного автомата с возможностью приостановки и продолжения выполнения.

Такой асинхронный метод:

```csharp
class Sample
{
    public async Task<int> Method()
    {
        int foo = 3;
        await Task.Delay(1_000);
        return foo;
    }
}
```

Будет преобразован в приблизительно такой метод-заглушку, который запускает работу конечного автомата:

```csharp
public Task<int> Method()
{
<Method>d__0 stateMachine = new <Method>d__0();
stateMachine.<>4__this = this; //объект, от имени которого вызвается
stateMachine.<>t__builder = AsyncTaskMethodBuilder<int>.Create(); //создание построителя
stateMachine.<>1__state = -1; //инициализация местонахождения
stateMachine.<>t__builder.Start<<Method>d__0>(ref stateMachine); //запуск конечного автомата
return stateMachine.<>t__builder.Task; //возвращение задания конечного автомата
}
```

Большую часть заглушки составляет инициализация полей структуры с именем <Method>d__0. Эта структура представляет собой конечный автомат, в котором и производится вся трудная работа. Заглушка вызывает метод Start, а затем возвращает объект Task. Чтобы понять, что происходит, нужно изучать саму структуру stateMachine.

Компилятор генерирует структуру, которая играет роль конечного автомата и содержит весь код моего оригинального метода. Делается это для того, чтобы получить объект, способный представить состояние метода, который можно было бы сохранить, когда программа дойдет до await. При достижении await сохраняется вся информация о том, в каком месте метода находится программа, чтобы при возобновлении ее можно было восстановить.

Структура конечного автомата (<Method>d__0) сгенерированная компилятором. Сначала – переменные-члены:

```csharp
public int <>1__state; //поля для построителя конечного автомата (Task)
public int <foo>5__1; //аргумент и локальные переменные становятся полями
public Sample <>4__this;
public AsyncTaskMethodBuilder<int> <>t__builder;
private object <>t__stack;
private TaskAwaiter <>u__$awaiter2; //ссылка на последний выполненный экземпляр await, который завершается асинхронно
```

Первая переменная - <>1__state - сохраняет номер достигнутого оператора await. Изначально значение -1, все операторы await пронумерованы.

Следующая переменная, <foo>5__1, служит для хранения значения оригинальной локальной переменной foo.

Далее следует переменная <>4__this. Она встречается только в конечных автоматах для нестатических асинхронных методов и содержит объект, от имени которого этот метод вызывался.

AsyncTaskMethodBuilder – это вспомогательный тип, в котором инкапсулирована логика, общая для всех конечных автоматов.

Переменная <>t__stack применяется для тех операторов await, которые входят в более сложное выражение. Находящиеся в стеке значения помещаются в эту переменную.

В переменной TaskAwaiter хранится временный объект, который помогает оператору await подписаться на уведомление о завершении задачи Task.

## Метод выполнения кода

В конечном автомате всегда имеется метод MoveNext, в котором находится весь написанный оригинальный код. Этот метод вызывается как при первом входе в наш метод, так и при возобновлении после await.

## Превращение оператора return в код завершения.

Каждое предложение return в оригинальном коде следует преобразовать в код, завершающий задачу Task, возвращенную методом-заглушкой.

Будет создан такой код вместо return:

```csharp
<>t__builder.SetResult(<foo>5__1);
return;
```

## Переход в нужное место

Поскольку MoveNext вызывается как для возобновления после каждого await, так и при первом входе в метод, он должен переходить в нужное место метода. Для этого генерируется примерно
такой же IL-код, как для предложения switch, ветвление по переменной state. Создается такой код:

```csharp
switch (<>1__state)
{
case -1: // При первом входе в метод
<foo>5__1 = 3;
Task t = Task.Delay(500);
// Код, относящийся к await t
case 0: // Есть только один await, его номер равен 0
<>t__builder.SetResult(<foo>5__1);
return;
}
```

## Приостановка в месте встречи await

Здесь используется объект TaskAwaiter для подписки на уведомление о завершении задачи Task, которую мы ждем. Чтобы возобновиться с нужного места, необходимо изменить переменную
state.

```csharp
...
<foo>5__1 = 3;
<>u__$awaiter2 = Task.Delay(500).GetAwaiter();
<>1__state = 0;
<>t__builder.AwaitUnsafeOnCompleted(<>u__$awaiter2, this);
return;
case 0:
...
```

Когда задача Task завершится, метод MoveNext будет вызван снова.

## Возобновление после await

По завершении ожидаемой задачи исполнение оказывается в нужном месте метода MoveNext, но перед исполнением оригинального кода должны еще получить результат задачи.

```csharp
...
case 0:
<>u__$awaiter2.GetResult();
<>t__builder.SetResult(<foo>5__1);
...
```

## Синхронное заверешние

Если await используется для ожидания задачи, которая уже завершилась синхронно, то не следует приостанавливать и возобновлять метод.

```csharp
...
<>u__$awaiter2 = Task.Delay(500).GetAwaiter();
if (<>u__$awaiter2.IsCompleted)
{
goto case 0;
}
<>1__state = 0;
...
```

## Перехват исключений

Если при исполнении async-метода возникло и не было перехвачено в блоке try-catch исключение, то его должен перехватить сгенерированный компилятором код. Это нужно для того, чтобы перевести возвращенный объект Task в состояние «ошибка», не позволив исключению покинуть метод.

```csharp
try
{
... Весь метод
}
catch (Exception e)
{
<>t__builder.SetException(<>t__ex);
return;
}
```

## Более сложный код

Если код более сложен, то компилятор C# корректно генерирует нужные конструкции, поэтому программист не задумывается об этом. Более сложные конструкции:

- блоки try-catch-finally;

- ветвления (if и switch);

- циклы;

- операторы await в середине выражения.

## Итоги

Каждый раз, когда в вашем коде используется оператор await, компилятор берет указанный операнд и пытается вызвать для него метод GetAwaiter. Этот метод может быть как экземплярным методом, так и методом расширения. Объект, возвращаемый при вызове GetAwaiter, называется объектом ожидания (awaiter).

После того как конечный автомат получит объект ожидания, он запрашивает его свойство IsCompleted. Если операция завершается синхронно, возвращается значение true, и в порядке оптимизации конечный автомат просто продолжает выполнение. Он вызывает метод GetResult объекта ожидания, который либо выдает исключение в случае неудачного выполнения операции, либо возвращает результат, если операция прошла успешно. Конечный автомат продолжает выполнение для обработки результата.

Если операция завершается асинхронно, IsCompleted возвращает false. В этом случае конечный автомат вызывает метод OnCompleted объекта ожидания, передавая ему делегата метода MoveNext конечного автомата. И теперь конечный автомат позволяет своему потоку вернуть управление в исходную точку, чтобы тот мог продолжить выполнение другого кода. В будущем объект ожидания, инкапсулирующий Task, узнает о своем заверении и вызывает делегата, что приводит к выполнению MoveNext. По полям конечного автомата определяется способ перехода к правильной точке кода, что создает иллюзию продолжения выполнения метода с того места, с которого он был прерван. На этой стадии код вызывает метод GetResult объекта ожидания и продолжает выполнение для обработки результата.

Так работает модель асинхронных функций, единственная цель которой — упрощение работы программиста по написанию кода без блокировки исполнения.

