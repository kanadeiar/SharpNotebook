# Асинхронность async

Подробно о преобразовании асинхронного кода, осуществляемом компилятором. Механизм async реализован в компиляторе C# при поддержке со
стороны библиотек базовых классов .NET.

Такой асинхронный метод преобразуется:

```csharp
class Sample
{
    public async Task<int> Method()
    {
        int foo = 3;
        await Task.Delay(1000);
        return foo;
    }
}
```

Сам метод преобразуется в приблизительной такой метод-заглушку, этот метод запускает stateMachine:

```csharp
public Task<int> Method()
{
<Method>d__0 stateMachine = new <Method>d__0();
stateMachine.<>4__this = this;
stateMachine.<>t__builder = AsyncTaskMethodBuilder<int>.Create();
stateMachine.<>1__state = -1;
stateMachine.<>t__builder.Start<<Method>d__0>(ref stateMachine);
return stateMachine.<>t__builder.Task;
}
```

Большую часть заглушки составляет инициализация полей структуры с именем <Method>d__0. Эта структура представляет собой конечный автомат, в котором и производится вся трудная работа. Заглушка вызывает метод Start, а затем возвращает объект Task. Чтобы понять, что происходит, нужно изучать саму структуру stateMachine.

Компилятор генерирует структуру, которая играет роль конечного автомата и содержит весь код моего оригинального метода. Делается это для того, чтобы получить объект, способный представить состояние метода, который можно было бы сохранить, когда программа дойдет до await. При достижении await сохраняется вся информация о том, в каком месте метода находится программа, чтобы при возобновлении ее можно было восстановить.

Структура конечного автомата (<AlexsMethod>d__0) сгенерированная компилятором. Сначала – переменные-члены:

```csharp
public int <>1__state;
public int <foo>5__1;
public Sample <>4__this;
public AsyncTaskMethodBuilder<int> <>t__builder;
private object <>t__stack;
private TaskAwaiter <>u__$awaiter2;
```

Первая переменная - <>1__state - сохраняет номер достигрутого оператора await. Изначально значение -1, все операторы await пронумерованы.

Следующая переменная, <foo>5__1, служит для хранения значения оригинальной переменной foo.

Далее следует переменная <>4__this. Она встречается только в конечных автоматах для нестатических асинхронных методов и содержит объект, от имени которого этот метод вызывался.

AsyncTaskMethodBuilder – это вспомогательный тип, в котором инкапсулирована логика, общая для всех конечных автоматов.

Переменная <>t__stack применяется для тех операторов await, которые входят в более сложное выражение. Находящиеся в стеке значения помещаются в эту переменную.

В переменной TaskAwaiter хранится временный объект, который помогает оператору await подписаться на уведомление о завершении задачи Task.

## Метод выполнения кода

В конечном автомате всегда имеется метод MoveNext, в котором находится весь написанный оригинальный код. Этот метод вызывается как при первом входе в наш метод, так и при возобновлении после await.

## Превращение оператора return в код завершения.

Каждое предложение return в оригинальном коде следует преобразовать в код, завершающий задачу Task, возвращенную методом-заглушкой.

Будет создан такой код вместо return:

```csharp
<>t__builder.SetResult(<foo>5__1);
return;
```

## Переход в нужное место

Поскольку MoveNext вызывается как для возобновления после каждого await, так и при первом входе в метод, он должен переходить в нужное место метода. Для этого генерируется примерно
такой же IL-код, как для предложения switch, ветвление по переменной state. Создается такой код:

```csharp
switch (<>1__state)
{
case -1: // При первом входе в метод
<foo>5__1 = 3;
Task t = Task.Delay(500);
// Код, относящийся к await t
case 0: // Есть только один await, его номер равен 0
<>t__builder.SetResult(<foo>5__1);
return;
}
```

## Приостановка в месте встречи await

Здесь используется объект TaskAwaiter для подписки на уведомление о завершении задачи Task, которую мы ждем. Чтобы возобновиться с нужного места, необходимо изменить переменную
state.

```csharp
...
<foo>5__1 = 3;
<>u__$awaiter2 = Task.Delay(500).GetAwaiter();
<>1__state = 0;
<>t__builder.AwaitUnsafeOnCompleted(<>u__$awaiter2, this);
return;
case 0:
...
```

Когда задача Task завершится, метод MoveNext будет вызван снова.

## Возобновление после await

По завершении ожидаемой задачи исполнение оказывается в нужном месте метода MoveNext, но перед исполнением оригинального кода должны еще получить результат задачи.

```csharp
...
case 0:
<>u__$awaiter2.GetResult();
<>t__builder.SetResult(<foo>5__1);
...
```

## Синхронное заверешние

Если await используется для ожидания задачи, которая уже завершилась синхронно, то не следует приостанавливать и возобновлять метод.

```csharp
...
<>u__$awaiter2 = Task.Delay(500).GetAwaiter();
if (<>u__$awaiter2.IsCompleted)
{
goto case 0;
}
<>1__state = 0;
...
```

## Перехват исключений

Если при исполнении async-метода возникло и не было перехвачено в блоке try-catch исключение, то его должен перехватить сгенерированный компилятором код. Это нужно для того, чтобы перевести возвращенный объект Task в состояние «ошибка», не позволив исключению покинуть метод.

```csharp
try
{
... Весь метод
}
catch (Exception e)
{
<>t__builder.SetException(<>t__ex);
return;
}
```

## Более сложный код

Если код более сложен, то компилятор C# корректно генерирует нужные конструкции, поэтому программист не задумывается об этом. Более сложные конструкции:

- блоки try-catch-finally;

- ветвления (if и switch);

- циклы;

- операторы await в середине выражения.


