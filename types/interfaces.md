# Интерфейсы

CLR и язык C# множественное наследование не поддерживают, но допускается использовать ограниченное множественное наследование с использованием интерфейсов. 

Интерфейс представляет собой средство назначения имени набору сигнатур методов. Интерфейс не содержит реализации методов, реализующий интерфейс класс должен явно содержать реализации всех использованных интерфейсов. 

Наследование от интерфесов позволяет подставлять экземпляры типа в любые контексты, где требуются экземпляры этого интерфейса.

## Объявление интерфейса

В интерфейсе можно объявлять набор сигнатур методов, событий, свойств, индексаторов.

Нельзя определять конструкторы и экземплярные поля. C# не позволяет определять в интерфейсе статические методы, поля и конструктор.

В соответствии с соглашением имена интерфейсов начиваются с заглавной буквы I. CLR поддерживает обобщенные интерфейсы и интерфейсные методы.

```csharp
public interface ISample
{
    string GetName();
}
```

Реализация интерфейса:

```csharp
public class Sample : ISample
{
    public string GetName()
    {
        return "Test";
    }
}
```

Предусмотрено множественное наследование среди интерфейсов. А класс, реализующий отдельный интерфейс должен реализовать все методы всех интерфейсов в дереве наследования.

Метод, реализующий интерфейс должен иметь модификатор доступа public. CLR требует, чтобы интерфейсные методы были виртуальными. Если в коде он не обозначен таковым, то будет компилятором C# обозначен виртуальным и запечатанным. Если пометить метод виртуальным, то тогда компилятор не запечатает этот метод, сделает доступным для переопределения.

```csharp
var s = new Sample("Test");
var name = s.GetName();
var name2 = ((ISample)s).GetName();
```

Нет разницы как был вызван метод.

## Подробности интерфейсов

Тип должен реализовывать все методы, объявленные в интерфейсах, которые он реализует. Можно объявлять поля, локальные переменные или параметры, имеющие интерфейсный тип. 

Значимые типы также могут реализовывать ноль и множество интерфейсов. Однако при приведении значимого типа к интерфейсу происходит упаковка, потому что интерфейсная переменная является ссылкой, которая должна указывать на объект в куче, чтобы среда выполнения могла проверить указатель и точно выявить тип объекта. Затем нужно использовать указатель, чтоб найти таблицу методов типа объекта и вызвать нужный метод.

## Явная и неявная реализация интерфейса

Реализовывать интерфейсы можно как явно, так и не явно. 

```csharp
public class Sample : ISample
{
    public string GetName()
    {
        return "Test";
    }
    string ISample.GetName()
    {
        return "Interface";
    }
}
```

Неявно реализованные методы интерфейса вызыватся только при приведении объекта к нужному интерфейсу. Если перед имененем метода указано название интерфейса в котором определен этот метод, то будет создана явная реализация интерфейсного метода. Компилятор устанавливает закрытый модификатор доступа для такого метода, что запрещает любому коду использовать экземпляр класса простым вызовом интерфейсного метода. Единственный путь вызова - через переменную интерфейсного типа.  

```csharp
var s = new Sample("Test");
var name = s.GetName();
var name2 = ((ISample)s).GetName();
```

Теперь вызываются два разных метода. Такой метод интерфейса не может быть виртуальным, его нельзя переопределить.

## Обобщенные интерфейсы

Обобщенные интерфейсы обеспечивают безопасность типов на этапе компиляции кода.

```csharp
int x = 1, y = 2;
IComparable c = x;
var res = c.CompareTo(y); //две упаковки
```

Обобщенные интерфейсы позволяют писать код работы со значимыми типами с меньшим количеством упаковок.

```csharp
int x = 1, y = 2;
IComparable<int> c = x;
var res = c.CompareTo(y); //одна упаковка
```

Класс может реализовать один интерфейс многократно с разными аргументами-типами.

```csharp
interface IGet<T>
{
    T Get(T value);
}
class Number : IGet<int>, IGet<string>
{
    public int Get(int value)
    {
        return value;
    }
    public string Get(string value)
    {
        return value;
    }
}
// использование
var num = new Number();
IGet<int> get1 = num;
IGet<string> get2 = num;
Console.WriteLine($"v = {get1.Get(1)} {get2.Get("name")}");
```

Когда нужно определить тип, реализующий несколько интерфейсов с методами, у которых одинаковые имена и сигнатуры, используют явную реализацию каждого интерфейса. Тогда для вызова каждого из метода нужно будет приводить тип к интерфейсу.

Параметры интерфеса могут быть помечены как ковариантные и контрвариантными, что увеличит их гибкость.

```csharp
interface IGet<in T1, out T2>
{
    T2 Get(T1 value);
}
class Number : IGet<object, string>
{
    public string Get(object value)
    {
        return value.ToString();
    }
}
// использование
var num = new Number();
var digit = num.Get(1);
var name = num.Get("name");
```

## Выбор между базовым классом или интерфейсом

Правила выбора:

- Связь потомка с предком. Если производный тип не может ограничиться случаем "является частным случаем", то следует применять интерфейс, а не базовый тип. Интерфейс подразумевает отношение "поддерживает функциональность". В значимых типах следует использовать интерфейсы.

- Простота использования. Наследовать новый тип от базового проще.

- Четкая реализация. Контракт интерфейса не всегда может быть реализован корректно и правильно.

- Управление версиями. Когда добавляется новый метод к базовому типу, производный тип наследует всю функциональность от базового. 

Потоки и элементы пользовательского интерфейса - на основе использования базовых классов.

Коллекции - на основе интерфейсов.
