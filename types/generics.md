# Обобщения

Обобщения - механизм, поддерживаемый средой CLR с целью многократного использования алгоритмов. Описывается один алгоритм, но не указывается тип данных, с которыми тот работает и это позволяет применять алгоритм к объектам разных типов. А уже другой разработчик применяя готовый алгоритм, должен указать конктетный тип данных.

CLR поддерживает создание как обобщенных ссылочных, так и обобщенных занимых типов, а обобщенные перечисления не поддерживаются. CLR поддерживает обобщенные интерфейсы и обобщенные делегаты. CLR также поддерживает обобщенне методы в ссылочном, значимом типе или интерфейсе.

Символами <T> сразу после имени класса автор обобщенного класса List указал, что класс работает с неопределенным типом данных. Переменные T называются параметрами типа. Т - имя переменной, которое применяется в исходном тексте во всех методах класса.

```csharp
public class MyList<T>
{ ... }
```

Рекомендуется переменные параметров называть T или начинать название с T (TKey, TValue). После определения обобщенного типа List<T> готовый обобщенный алгоритм могут использовать другие разработчики, для этого нужно указывать точный тип данных. Такие типы данных называют аргументами-типами.

Пример использования:

```csharp
List<DateTime> list = new List<DateTime>();
list.Add(DateTime.Now);
list.Add(DateTime.MinValue);
var dt = list[0];
```

Преимущества использования обобщений:

- Защита исходного кода

- Безопасность типов

- Более простой и понятный код

- Повышение производительности

## Обобщения в базовой библиотеке фреймворка BCL

Большинство обобщенных классов можно найти в пространствах имен System.Collections.Generic, System.Collections.ObjectModel, System.Collections.Concurrent. Необобщенные классы коллекций, в отличие от обобщенных, не обеспечивают безопасность типов, простоту и понятность кода. Объектная модель у обобщенных классов лучше, чем у не обобщенных. 

Класс System.Array поддерживает множество статических обобщенных методов. 

## Реализация обобщений

CLR создает внутреннюю структуру данных для каждого типа, называемый объект-тип. Обобщенный тип также считается типом и для него - ссылочного, значимого, интерфейса или делегата CLR создает внутренний объект-тип. Такой тип с обобщенными параметрами-типами называют открытым типом, а в CLR запрещено создание экземпляров открытых типов.

При ссылке на обобщенный тип можно определить набор обобщенных аргументов типа. Если всем аргументам передаются типы данных, то тип становится из отрытого закрытым типом, и на основе такого типа CLR может создавать объекты.

CLR размещает статические поля типа в самом объекте-типа. Это значит что каждый закрытый тип имеет свои статические поля, определенные в типе List<T>. Статический конструктор выполняется для закрытого типа лишь один раз. 

## Наследование

Обобщенный тип может быть поизводным от других типов. Определения аргументов типа не имеет ничего общего с иерархиями наследования. Можно создавать обобщенный класс на основе необобщенного базового класса.

```csharp
internal class Node
{
    protected Node? _next;
    public Node(Node? next)
    {
        _next = next;
    }
}
internal sealed class Node<T> : Node
{
    public T _data;
    public Node(T data) : this(data, null) { }
    public Node(T data, Node? next) : base(next)
    {
        _data = data;
    }
    public override string ToString()
    {
        return _data.ToString() +
            ((_next != null) ? _next.ToString() : null);
    }
}
```

Создание списка:

```csharp
Node head = new Node<char>('.');
head = new Node<DateTime>(DateTime.Now, head);
head = new Node<string>("Сегодня: ", head);
System.Console.WriteLine(head.ToString());
```

C# позволяет использовать упрощенный синтаксис для ссылки на обобщенный закрытый тип, не влияющий на эквивалентность типов. 

```csharp
using DateTimeList = System.Collections.Generic.List<System.DateTime>;
```

## Обобщенные интерфейсы

В CLR поддерживаются обобщенные интерфейсы. Ссылочный и значимый типы реализуют обобщенный интерйес путем задания аргументов-типов или без задания этих аргументов-типов.

```csharp
public sealed class Sample : IEnumerator<int>
{
    private int[] _values;
    ...
}
public sealed class GenericSample<T> : IEnumerator<T>
{
    private T[] _values;
    ...
}
```

## Обобщенные делегаты

Обобщенные делегаты CLR позволяют передавать методам обратного вызова любые типы объектов, обеспечивая при этом безопасность типов.

Пример обобщенного делегата:

```csharp
public delegate TReturn CallTest<TReturn, TValue>(TValue value);
```

Везде, где это возможно, следует использовать обобщенные делегаты Action и Func.

## Контравариантность и ковариантность аргументов-типов в делегатах и интерфейсах

Везде, где возможно каждый из параметров-типов обобщенного делегата следует помечать кк ковариантный или контравариантный. Это позволяет приводить тип переменной обобщенного делегата к томуже типу делегата, но с другим параметром-типом.

Параметры-типы могут быть:

- Инвариантными.

- Контравариантными - обозначение ключевым словом in. Параметр-тип может быть преобразован от класса к классу, производному от него. Контравариантный параметр-тип может появляться только во входной позиции в качестве входного параметра.

- Ковариантными - обозначение ключевым словом out. Параметр-тип может быть преобразован к одному из его базовых классов. Может появляться только в выходной позиции, в качестве возвращаемого значения метода.

```csharp
Func<object, FileStream> fn1 = null;
Func<string, Stream> fn2 = fn1;
```

## Обобщенные методы

CLR позволяет методу иметь собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных. 

```csharp
internal sealed class Sample<T>
{
    private T _value;
    public Sample(T value)
    {
        _value = value;
    }
    public TOutput Converter<TOutput>()
    {
        TOutput result = (TOutput)Convert.ChangeType(_value, typeof(TOutput));
        return result;
    }
}
```

Пример обобщенного метода:

```csharp
private static void Swap<T>(ref T o1, ref T o2)
{
    T temp = o1;
    o1 = o2;
    o2 = temp;
}
//использование
Swap<int>(ref n1, ref n2);
Swap<string>(ref s1, ref s2);
```

## Логическое выведение типов

Компилятор C# предлагает логическое выведение типов при вызове обобщенных методов. Компилятор будет автоматически пытаться определить тип параметра-типа.

```csharp
//использование
Swap(ref n1, ref n2); //вызов Swap<int>
```

## Верификация и ограничения

Компиляторы и CLR поддерживают механизм ограничений. Ограничения сужают перечень типов, которые можно передать в обобщенном аргументе и расширяют возможности по работе с этими типами данных.

```csharp
public static T Min<T>(T o1, T o2) where T : IComparable<T>
{
    if (o1.CompareTo(o2) < 0) return o1;
    return o2;
}
```

Перегрузка типов и методов выполняется только по арности, нет поддержки перегрузки по именам параметров типа или по именам ограничений.

```csharp
internal sealed class Sample { }
internal sealed class Sample<T> { }
internal sealed class Sample<T1, T2> { }
internal sealed class Another
{
    private static void M() {}
    private static void M<T>() {}
    private static void M<T1, T2>() {}
}
```

При переопределении виртуального обобщенного метода в переопределяющем методе должно быть столько-же параметров-типов, они наследуют ограничения от базового типа, можно только переименовывать эти параметры-типы. При реализации интерфейсного типа в нем должно задаваться то же число параметров-типов, что и в интерфейсном методе, причем эти параметры-типы наследуют ограничения, заданные методом интерфейса.

```csharp
internal class Base
{
    public virtual void M<T>() where T : class { }
}
internal sealed class Derived : Base
{
    public override void M<T>() { }
}
```






