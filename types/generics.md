# Обобщения

Обобщения - механизм, поддерживаемый средой CLR с целью многократного использования алгоритмов. Описывается один алгоритм, но не указывается тип данных, с которыми тот работает и это позволяет применять алгоритм к объектам разных типов. А уже другой разработчик применяя готовый алгоритм, должен указать конктетный тип данных.

CLR поддерживает создание как обобщенных ссылочных, так и обобщенных занимых типов, а обобщенные перечисления не поддерживаются. CLR поддерживает обобщенные интерфейсы и обобщенные делегаты. CLR также поддерживает обобщенне методы в ссылочном, значимом типе или интерфейсе.

Символами <T> сразу после имени класса автор обобщенного класса List указал, что класс работает с неопределенным типом данных. Переменные T называются параметрами типа. Т - имя переменной, которое применяется в исходном тексте во всех методах класса.

```csharp
public class MyList<T>
{ ... }
```

Рекомендуется переменные параметров называть T или начинать название с T (TKey, TValue). После определения обобщенного типа List<T> готовый обобщенный алгоритм могут использовать другие разработчики, для этого нужно указывать точный тип данных. Такие типы данных называют аргументами-типами.

Пример использования:

```csharp
List<DateTime> list = new List<DateTime>();
list.Add(DateTime.Now);
list.Add(DateTime.MinValue);
var dt = list[0];
```

Преимущества использования обобщений:

- Защита исходного кода

- Безопасность типов

- Более простой и понятный код

- Повышение производительности

## Обобщения в базовой библиотеке фреймворка BCL

Большинство обобщенных классов можно найти в пространствах имен System.Collections.Generic, System.Collections.ObjectModel, System.Collections.Concurrent. Необобщенные классы коллекций, в отличие от обобщенных, не обеспечивают безопасность типов, простоту и понятность кода. Объектная модель у обобщенных классов лучше, чем у не обобщенных. 

Класс System.Array поддерживает множество статических обобщенных методов. 

## Реализация обобщений

CLR создает внутреннюю структуру данных для каждого типа, называемый объект-тип. Обобщенный тип также считается типом и для него - ссылочного, значимого, интерфейса или делегата CLR создает внутренний объект-тип. Такой тип с обобщенными параметрами-типами называют открытым типом, а в CLR запрещено создание экземпляров открытых типов.

При ссылке на обобщенный тип можно определить набор обобщенных аргументов типа. Если всем аргументам передаются типы данных, то тип становится из отрытого закрытым типом, и на основе такого типа CLR может создавать объекты.

CLR размещает статические поля типа в самом объекте-типа. Это значит что каждый закрытый тип имеет свои статические поля, определенные в типе List<T>. Статический конструктор выполняется для закрытого типа лишь один раз. 

## Наследование

Обобщенный тип может быть поизводным от других типов. Определения аргументов типа не имеет ничего общего с иерархиями наследования. Можно создавать обобщенный класс на основе необобщенного базового класса.

```csharp
internal class Node
{
    protected Node? _next;
    public Node(Node? next)
    {
        _next = next;
    }
}
internal sealed class Node<T> : Node
{
    public T _data;
    public Node(T data) : this(data, null) { }
    public Node(T data, Node? next) : base(next)
    {
        _data = data;
    }
    public override string ToString()
    {
        return _data.ToString() +
            ((_next != null) ? _next.ToString() : null);
    }
}
```

Создание списка:

```csharp
Node head = new Node<char>('.');
head = new Node<DateTime>(DateTime.Now, head);
head = new Node<string>("Сегодня: ", head);
System.Console.WriteLine(head.ToString());
```

C# позволяет использовать упрощенный синтаксис для ссылки на обобщенный закрытый тип, не влияющий на эквивалентность типов. 

```csharp
using DateTimeList = System.Collections.Generic.List<System.DateTime>;
```

## Обобщенные интерфейсы

В CLR поддерживаются обобщенные интерфейсы. Ссылочный и значимый типы реализуют обобщенный интерйес путем задания аргументов-типов или без задания этих аргументов-типов.

```csharp
public sealed class Sample : IEnumerator<int>
{
    private int[] _values;
    ...
}
public sealed class GenericSample<T> : IEnumerator<T>
{
    private T[] _values;
    ...
}
```

## Обобщенные делегаты

Обобщенные делегаты CLR позволяют передавать методам обратного вызова любые типы объектов, обеспечивая при этом безопасность типов.

Пример обобщенного делегата:

```csharp
public delegate TReturn CallTest<TReturn, TValue>(TValue value);
```

Везде, где это возможно, следует использовать определенные в пространсте имен System обобщенные делегаты Action<T>, Func<T, TResult> и Predicate<T>.

```csharp
Action<int> action1 = a => Console.WriteLine(a);
Func<int, int> func1 = a => a + 1;
Predicate<int> predicate1 = (int x) => x > 0;
Func<int, int, string> func2 = (a, b) => $"{a}{b}";
```

## Контравариантность и ковариантность аргументов-типов в делегатах и интерфейсах

Везде, где возможно каждый из параметров-типов обобщенного делегата следует помечать как ковариантный или контравариантный. Это позволяет приводить тип переменной обобщенного делегата к тому-же типу делегата, но с другим параметром-типом.

Параметры-типы могут быть:

- Инвариантными.

- Контравариантными - обозначение ключевым словом in. Параметр-тип может быть преобразован от класса к классу, производному от него. Контравариантный параметр-тип может появляться только во входной позиции в качестве входного параметра.

- Ковариантными - обозначение ключевым словом out. Параметр-тип может быть преобразован к одному из его базовых классов. Может появляться только в выходной позиции, в качестве возвращаемого значения метода.

```csharp
public delegate void Action<in T>(T obj);
public delegate TResult Func<in T, out TResult>(T arg);
Func<object, FileStream> fun1 = null;
Func<string, Stream> fun2 = fun1;
```

## Обобщенные методы

CLR позволяет методу иметь собственные параметры-типы, которые могут применяться для параметров, возвращаемых значений или локальных переменных. 

```csharp
internal sealed class Sample<T>
{
    private T _value;
    public Sample(T value)
    {
        _value = value;
    }
    public TOutput Converter<TOutput>()
    {
        TOutput result = (TOutput)Convert.ChangeType(_value, typeof(TOutput));
        return result;
    }
}
```

Пример обобщенного метода:

```csharp
private static void Swap<T>(ref T o1, ref T o2)
{
    T temp = o1;
    o1 = o2;
    o2 = temp;
}
//использование
Swap<int>(ref n1, ref n2);
Swap<string>(ref s1, ref s2);
```

## Логическое выведение типов

Компилятор C# предлагает логическое выведение типов при вызове обобщенных методов. Компилятор будет автоматически пытаться определить тип параметра-типа.

```csharp
//использование
Swap(ref n1, ref n2); //вызов Swap<int>
```

## Верификация и ограничения

Компиляторы и CLR поддерживают механизм ограничений. Ограничения сужают перечень типов, которые можно передать в обобщенном аргументе и расширяют возможности по работе с этими типами данных.

```csharp
public static T Min<T>(T o1, T o2) where T : IComparable<T>
{
    if (o1.CompareTo(o2) < 0) return o1;
    return o2;
}
```

Перегрузка типов и методов выполняется только по арности, нет поддержки перегрузки по именам параметров типа или по именам ограничений.

```csharp
internal sealed class Sample { }
internal sealed class Sample<T> { }
internal sealed class Sample<T1, T2> { }
internal sealed class Another
{
    private static void M() {}
    private static void M<T>() {}
    private static void M<T1, T2>() {}
}
```

При переопределении виртуального обобщенного метода в переопределяющем методе должно быть столько-же параметров-типов, они наследуют ограничения от базового типа, можно только переименовывать эти параметры-типы. При реализации интерфейсного типа в нем должно задаваться то же число параметров-типов, что и в интерфейсном методе, причем эти параметры-типы наследуют ограничения, заданные методом интерфейса.

```csharp
internal class Base
{
    public virtual void M<T>() where T : class { }
}
internal sealed class Derived : Base
{
    public override void M<T>() { }
}
```

## Основные ограничения

Можно задать в параметре-типе не более одного основного ограничения.

Например, основным ограничением может быть ссылочный тип, указывающий на незапечатанный класс. Это ограничение, что заданный аргумент-тип будет относится либо к типу, указанному в ограничении, либо к производному от него типу.

```csharp
internal sealed class SampleStream<T> where T : Stream
{
    public void M(T stream)
    {
        stream.Close();
    }
}
```

Ограничение class гарантирует компилятору, что указанный аргумент-тип будет иметь ссылочный тип. Под это подпадают все типы-классы, типы-интерфейсы, типы-делегаты и типы-массивы. 

```csharp
internal sealed class Sample<T> where T : class
{
    public void M()
    {
        T temp = null;
    }
}
```

Ограничение struct гарантирует компилятору, что указанный аргумент-тип будет иметь значимый тип или быть перечислением.

```csharp
internal sealed class Sample<T> where T : struct
{
    public static T Factory()
    {
        return new T();
    }
}
```

## Дополнительные ограничения

Для каждого параметра-тип может быть задано ноль и более дополнительных ограничений. При задании интерфейса (или интерфейсов) - гарантия, что аргумент-тип будет определять тип, реализующий этот интерфейс (или всех указанных интерфейсов). 

Есть ограничение параметра типа, позволяющее задать обобщенному типу или методу, что параметры-типы должны быть связаны отношениями. К параметру-типу может быть примененно ноль и более ограничений.

```csharp
private static List<TBase> Convert<T, TBase>(List<T> list) where T : TBase
{
    List<TBase> baseList = new List<TBase>(list.Count);
    for (Int32 index = 0; index < list.Count; index++)
    {
        baseList.Add(list[index]);
    }
    return baseList;
}
// использование
var list = new List<string>();
list.Add("test");
var objs = Convert<string, object>(list);
```

## Ограничения конструктора

Ограничение конструктора new() гарантирует, что аргумент-тип будет неабстрактный и имеет один конструктор без параметров.

```csharp
internal sealed class Sample<T> where T : new()
{
    public static T Factory()
    {
        return new T();
    }
}
```

## Проблемы верификации

Переменная обобщенного типа может быть приведена только к совместимому типу.

```csharp
private static string? Casting<T>(T obj)
{
    string? s1 = (string?)(object?)obj;
    string? s = obj as string;
    return s;
}
```

Присвоение переменной обобщенного типа значения по умолчанию работает так:

```csharp
private static T Sample<T>()
{
    T temp = default(T)!;
    return temp;
}
```

Сравнение переменной обобщенного типа с null операторами == и != допустим:

```csharp
private static void Sample<T>(T obj)
{
    if (obj == null)
    { }
}
```

Сравнение двух переменных обобщенного типа допустимо, если обобщенный параметр типа имеет ссылочный тип:

```csharp
private static void Sample<T>(T o1, T o2) where T : class
{
    if (o1 == o2)
    { }
}
```

Использование переменных обобщенного типа в качестве операндов создает множество проблем, связанных с различными ограничениями.

## Обобщенные коллекции

Для работы с этими коллекциями требуется подключить пространство имен System.Collections.Generic, в этом же пространстве имен содержатся средства обобщения. 

Вместо построения уникальных классов, которые могут хранить объекты людей, автомобилей, и целые числа, можно задействовать класс обобщенных коллекций и указать тип хранимых элементов. Обобщенным образом могут быть записаны только классы, структуры, интерфейса и делегаты, но не перечисления. 

Вот преимущества обобщенных контейнеров по сравнению с их необобщенными аналогами:

- Обобщения обеспечивают лучшую производительность, т.к. лишены накладных расходов по упаковке/распаковке, когда хранят типы значений.

- обобщения безопасны к типам, потому что могут содеражть только объекты указанного типа.

- обобщения значительно сокращают потребность в специальных типах коллекций, поскольку при создании обобщенного контейнера указывается "вид типа".

Некоторые полезные классы это этого пространства имен System.Collections.Generic

Класс                  | Описание, некоторые реализуемые интерфейсы
-----|-----
Dictionary<TKey,TValue> | Обобщенная коллекция ключей и значений Интерфейсы - ICollection<T>, IDictionary<TKey,TValue> IEnumerable<T>
LinkedList<T>          | Двусвязный список Интерфейсы - ICollection<T>, IEnumerable<T>
List<T>                | Последовательный список элементов с динамически изменяемым размером Интерфейсы - ICollection<T>, IEnumerable<T>, IList<T>
Queue<T>               | Обобщенная реализация списка, механизм FIFO - первый вошел - первый вышел Интерфейсы - ICollection, IEnumerable<T>
SortedDictionary <TKey,TValue> | Обобщенная реализация сортированного множества пар "Ключ-значение" Интерфейсы - ICollection<T>, IDictionary<TKey,TValue> IEnumerable<T>
SortedSet<T>           | Коллекция объектов, поддерживаемых в сортированном порядке без дубликатов Интерфейсы - ICollection<T>, IEnumerable<T>, ISet<T>
Stack<T>               | Обобщенная реализация списка, механизм LIFO - последний вошел - первый вышел Интерфейсы - ICollection, IEnumerable<T>

### Инициализация коллекций

Синтаксис инициализации коллекций позволяет наполнять многие контейнеры элементами с применением синтаксиса, похожего на тот, который используется для наполнения базовых массивов.

```csharp
int[] myArr = {0, 1, 2}; //стандартный массив
List<int> myList = new List<int> {1, 2, 3, 5}; //обобщенный List<>
ArrayList myArrList = new ArrayList {1, 3, 4, 2}; //необобщенный с числовыми данными
```

Синтаксис инициализации коллекции смешанный с синтаксисом структур и классов.

```csharp
List<Toy> myToys = new List<Toy>
{
    new Toy { X = 1 },
    new Toy { X = 5 },
};
```

## Класс ObservableCollection<T>

Этот класс удобен своей возможностью информировать внешние объекты, когда его содержимое каким-то образом изменяется. Он поддерживает событие по имени CollectionChanged. Указанное событие будет инициироватся каждый раз, когда вставляется новый элемент, удаляется, перемещается, модифицируется вся коллекция целиком.
    
Использование:

```csharp
private static void UseObserv()
{
    ObservableCollection<Per> pers = new ObservableCollection<Per>
    {
        new Per(1),
        new Per {X = 3},
    };
    pers.CollectionChanged += pers_CollChanged;
    pers.Add(new Per(6));
    pers.RemoveAt(0);
}

static void pers_CollChanged(object sender, 
    NotifyCollectionChangedEventArgs e)
{
    WriteLine($"\nActions = {e.Action}");
    if (e.Action == NotifyCollectionChangedAction.Add)
    {
        Write("New Items:");
        foreach (var el in e.NewItems)
        {
            Write($"{el.ToString()} ");
        }
    }
    if (e.Action == NotifyCollectionChangedAction.Remove)
    {
        Write("Deleted Items:");
        foreach (var el in e.OldItems)
        {
            Write($"{el.ToString()} ");
        }
    }
}
```


