# Абстракции

## Абстрактный класс

Для предотвращения возможности реализации классов их следует объявлять абстрактными. Такой класс - абстрактный базовый класс.

В абстрактном базовом классе можно определить любое число абстрактных членов. Навязывается полиморфный интерфейс каждому наследнику, оставляя им задачу реализации абстрактных членов.

Если метод требует своей конкретный реализации в производном классе, его следует сделать абстрактным. Такие методы являются чистым протоколом.

```csharp
abstract class Abstract
{
    protected int Value { get; set; }
    public virtual string TestAbstract() => "Abstract";
    public abstract string Test();
}

internal class Sample : Abstract
{
    public override string Test() => "Base";
}
```

## Интерфейс

CLR и язык C# множественное наследование не поддерживают, но допускается использовать ограниченное множественное наследование с использованием интерфейсов. 

Интерфейс представляет собой средство назначения имени набору сигнатур методов. Интерфейс как правило не содержит реализации методов, реализующий интерфейс класс должен явно содержать реализации всех использованных интерфейсов. Новые возможности интерфейсов значительно приближают их функциональность к функциональности абстрактных классов с добавочной способностью классов реализовывать множество интерфейсов.

Однако средство стандартных методов интерфейса позволяет интерфейсам содержать реализацию, которая может быть по желанию переопределяться в классе реализации.

Наследование от интерфесов позволяет подставлять экземпляры типа в любые контексты, где требуются экземпляры этого интерфейса.

Интерфейсы могут быть организованы в иерархии. Интерфейсы при этом могут как расширять другие интерфейсы дополнительными абстрактными членами, так и наследуют стандартные реализации, добавляют новые стандартные реализации.

Удобны, когда нужно расширить функциональность базовых классов, не нарушая работу существующих кодовых баз.

## Объявление интерфейса

В интерфейсе можно объявлять набор сигнатур методов, событий, свойств, индексаторов и стандартных методов.

Можно определять экземплярные конструкторы, статические конструкторы, свойства и статические поля и свойства, статические стандартные методы. Нельзя определять экземплярные поля. Статические констрктор и методы имеют доступ только к статическим полями и свойствам.

В соответствии с соглашением имена интерфейсов начиваются с заглавной буквы I. CLR поддерживает обобщенные интерфейсы и интерфейсные методы.

```csharp
public interface ISample
{
    string GetName();
}
```

Реализация интерфейса:

```csharp
public class Sample : ISample
{
    public string GetName()
    {
        return "Test";
    }
}
```

Предусмотрено множественное наследование среди интерфейсов. А класс, реализующий отдельный интерфейс должен реализовать все методы всех интерфейсов в дереве наследования.

Метод, реализующий интерфейс должен иметь модификатор доступа public. CLR требует, чтобы интерфейсные методы были виртуальными. Если в коде он не обозначен таковым, то будет компилятором C# обозначен виртуальным и запечатанным. Если пометить метод виртуальным, то тогда компилятор не запечатает этот метод, сделает доступным для переопределения.

```csharp
var s = new Sample("Test");
var name = s.GetName();
var name2 = ((ISample)s).GetName();
```

Нет разницы как был вызван метод.

## Стандартные реализации интерфейсов

Методы и свойства интерфейса могут иметь стандартные реализации. Однако чтобы использовать такие реализации, класс или структрура должны быть приведены к типу интерфейса.

```csharp
interface ISample
{
    int One { get; set; }
    int Two { get; set; }
    int Sum => One + Two;
}
class Sample : ISample
{
    public int One { get; set; }
    public int Two { get; set; }
}
// использование
ISample sam = new Sample { One = 1, Two = 2 };
var one = sam.Sum;
```

Прежде чем задействовать это средство в своем коде, обязательно оценить где будет использоваться в вызывающем коде - как там будет это использоватся.

Нижерасположенные интерфейсы могут задействовать реализацию из базового интерфейса или создать новую стандартную реализацию.

```csharp
interface ISample
{
    int One { get; set; }
    int Two { get; set; }
    int Sum => One + Two;
}
interface IAdvanced : ISample
{
    new int Sum => One * Two;
}
```

## Статические конструкторы и члены

В интерфейсах можно определять статические конструкторы и члены, которые функционируют аналогично оным в классах. 

```csharp
interface ISample
{
    int One { get; set; }
    int Two { get; set; }
    int Sum => One + Two;
    static string Test { get; set; }
    static ISample() => Test = "Test";
    static string Get() => Test;
}
// использование
ISample.Test = "Onew";
var mini = ISample.Get();
```

## Подробности интерфейсов

Тип должен реализовывать все методы, объявленные в интерфейсах, которые он реализует. Можно объявлять поля, локальные переменные или параметры, имеющие интерфейсный тип. 

Значимые типы также могут реализовывать ноль и множество интерфейсов. Однако при приведении значимого типа к интерфейсу происходит упаковка, потому что интерфейсная переменная является ссылкой, которая должна указывать на объект в куче, чтобы среда выполнения могла проверить указатель и точно выявить тип объекта. Затем нужно использовать указатель, чтоб найти таблицу методов типа объекта и вызвать нужный метод.

## Явная и неявная реализация интерфейса

Реализовывать интерфейсы можно как явно, так и не явно. 

```csharp
public class Sample : ISample
{
    public string GetName()
    {
        return "Test";
    }
    string ISample.GetName()
    {
        return "Interface";
    }
}
```

Неявно реализованные методы интерфейса вызыватся только при приведении объекта к нужному интерфейсу. Если перед имененем метода указано название интерфейса в котором определен этот метод, то будет создана явная реализация интерфейсного метода. Компилятор устанавливает закрытый модификатор доступа для такого метода, что запрещает любому коду использовать экземпляр класса простым вызовом интерфейсного метода. Единственный путь вызова - через переменную интерфейсного типа.  

```csharp
var s = new Sample("Test");
var name = s.GetName();
var name2 = ((ISample)s).GetName();
```

Теперь вызываются два разных метода. Такой метод интерфейса не может быть виртуальным, его нельзя переопределить.

## Обобщенные интерфейсы

Обобщенные интерфейсы обеспечивают безопасность типов на этапе компиляции кода.

```csharp
int x = 1, y = 2;
IComparable c = x;
var res = c.CompareTo(y); //две упаковки
```

Обобщенные интерфейсы позволяют писать код работы со значимыми типами с меньшим количеством упаковок.

```csharp
int x = 1, y = 2;
IComparable<int> c = x;
var res = c.CompareTo(y); //одна упаковка
```

Класс может реализовать один интерфейс многократно с разными аргументами-типами.

```csharp
interface IGet<T>
{
    T Get(T value);
}
class Number : IGet<int>, IGet<string>
{
    public int Get(int value)
    {
        return value;
    }
    public string Get(string value)
    {
        return value;
    }
}
// использование
var num = new Number();
IGet<int> get1 = num;
IGet<string> get2 = num;
Console.WriteLine($"v = {get1.Get(1)} {get2.Get("name")}");
```

Когда нужно определить тип, реализующий несколько интерфейсов с методами, у которых одинаковые имена и сигнатуры, используют явную реализацию каждого интерфейса. Тогда для вызова каждого из метода нужно будет приводить тип к интерфейсу.

Параметры-типы интерфеса могут быть помечены как ковариантные и контрвариантными, что увеличит их гибкость.

- Ковариантность (out) означает, что интерфейс позволяет использовать производный тип заданного изначально.

- Контравариантность (in) означает, что интерфейс позволяет использовать более универсальный тип, чем заданный изначально.

- Инвариантность означает, что интерфейс позволяет использовать только заданный тип.

```csharp
interface IGet<in T1, out T2>
{
    T2 Get(T1 value);
}
class Number : IGet<object, string>
{
    public string Get(object value)
    {
        return value.ToString();
    }
}
// использование
var num = new Number();
object digit = num.Get(1);
object name = num.Get("name");
```

## Выбор между базовым абстрактным классом или интерфейсом

Правила выбора:

- Связь потомка с предком. Если производный тип не может ограничиться случаем "является частным случаем", то следует применять интерфейс, а не базовый тип. Интерфейс подразумевает отношение "поддерживает функциональность". В значимых типах следует использовать интерфейсы.

- Простота использования. Наследовать новый тип от базового проще.

- Четкая реализация. Контракт интерфейса не всегда может быть реализован корректно и правильно.

- Управление версиями. Когда добавляется новый метод к базовому типу, производный тип наследует всю функциональность от базового. 

Потоки и элементы пользовательского интерфейса - на основе использования базовых классов.

Коллекции - на основе интерфейсов.
