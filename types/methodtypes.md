# Поведение типов

## Видимость типа

При определении типа его можно сделать открытым или внутренним используя ключевые слова, без явно указанного ключевого слова видимости тип - внутренний.

Можно указать другие сборки, которые сборка с типом будет считать дружественными (будут видны внутренние типы) - атрибут InernalsVisibleTo, в параметрах передать - имя и ее открытый ключ. 

## Статические классы

Компилятор налагает на статические классы ограничения:

- класс должен быть прямым потомком System.Object

- не должен реализовывать интерфейсы

- можно определять только статические члены

- нельзя использовать в качестве поля

Определение класса ключевым словом static заставляет компилятор делать класс абстрактным, запечатанным и без конструктора экземпляров. 

## Частичный тип

Помеченный ключевым словом partial тип во всех файлах с определением типа заставляет компилятор собирать из этих нескольких файлов один тип.

## Компоненты

Современные приложения состоят из множества компонентов, разработанных множеством компаний. Компоненты объединяются вместе в рамках парадигмы ООП. 

Важные ключевые слова C#, позволяющие управлять версиями компонентов в рамках ООП:

Слово C# | Тип | Метод/Свойство/Событие | Константа/Поле
---------|-----|------------------------|-------------
abstract | Экземпляры такого типа создавать нельзя | Необоходимо реализовать этот член в производном типе | запрещено
virtual | запрещено | Член может переопределяться в производном типе | запрещено
override | запрещено | Член переопределяется в производном типе | запрещено
sealed | Нельзя использовать в качестве базового при наследовании | Член нельзя переопределить в производном типе | запрещено
new | вложенный тип не связан с похожим базового | вложенный не связан с похожим базового | вложенный не связан с похожим базового

## Равенство объектов

В типе System.Object определен метод виртуальный Equals(), возвращающий true, если объекты равны. Можно переопределеять этот метод для сложных типов. Для значимых типов этот метод переопределен. 

При переопределении этого метода нужно:

- Рефлексивность. x.Equals(x) должно возвращать true.

- Симметричность. x.Equals(y) и y.Equals(x) должны возвращать одно и то же значение.

- Транзитивность. если x.Equals(y) возвращает true и y.Equals(z) возвращает true, то x.Equals(z) также должно возвращать true.

- Постоянство. если в двух сравниваемых значениях не произошло изменений, результат сравнения тоже не должен измениться.

- Реализовать в типе метод Equals интерфейса System.IEquatable<T>.

- Перегрузить методы операторов == и !=.

## Хеш-коды объектов

Для того, чтобы иметь возможность добавления в хеш-таблицы экземпляры любых типов в System.Object включен виртуальный метод GetHashCode(), позволяющий для любого объекта вычислить его целочисленный хеш-код. 

При переопределении метода Equals(), нужно также обязательно переопределить метод GetHashCode(). 

Пример:

```csharp
public override int GetHashCode() {
    return _x ^ _y; // Исключающее ИЛИ для _x и _y
}
```

## Полиморфизм

Методы типа содержат код действий над типом или экземпляром типа. У метода есть: имя, сигнатура, вертаемый тип (void-пусто). У типа может быть несколько методов с одинаковым имененем, но с разным числом параметров. 

В CLR есть две инструкции для вызова метода:

- Инструкция call используется для вызова статических, экземплярных и виртуальных методов. Если с помощью этой инструкции вызывается статический метод, необходимо указать тип, в котором определяется метод. При вызове экземплярного или виртуального метода необходимо указать переменную, ссылающуюся на объект, причем в call подразумевается, что эта переменная не равна null. Иначе говоря, сам тип переменной указывает, в каком типе определен необходимый метод. Если в типе переменной метод не определен, проверяются базовые типы. Инструкция call часто служит для невиртуального вызова виртуального метода.

- Инструкция callvirt используется только для вызова экземплярных и виртуальных (но не статических) методов. При вызове необходимо указать переменную, ссылающуюся на объект. Если с помощью этой инструкции вызывается невиртуальный экземплярный метод, тип переменной показывает, где определен необходимый метод. При использовании callvirt для вызова виртуального экземплярного метода CLR определяет настоящий тип объекта, на который ссылается переменная, и вызывает метод полиморфно. При компиляции такого вызова JIT-компилятор генерирует код для проверки значения переменной — если оно равно null, CLR сгенерирует исключение NullReferenceException. Из-за этой дополнительной проверки инструкция callvirt выполняется немного медленнее, чем call. Проверка на null выполняется даже при вызове невиртуального экземплярного метода.

При вызове экземплярного или виртуального метода инструкции call и callvirt всегда в первом параметре получают скрытый аргумент this, ссылающийся на объект, с которым производятся действия.

Компиляторы стремятся использовать команду call при вызове методов в значимых типах, и если они запечатаны, вызов выполняется быстрее. Для вызова виртуального метода в значимом типе нужно его упаковывать, а это нагрузка.

Переопределенный метод производного класс всегда может вызвать базовый метод используя ключевое слово base.

```csharp
internal class Sample
{
    public virtual string Test()
    {
        return "Base";
    }
}
internal sealed class AdvSample : Sample
{
    public sealed override string Test()
    {
        return base.Test() + "Adv";
    }
}
```

## Использование модификаторов доступа

Полезно использовать запечатанные классы вместо обычных. Запечатанный всегда можно сделать обычным, а обратное - невозможно. Все определения незапечатанных виртуальных мутодов базового класса следует соблюдать в новых версиях. Невиртуальные методы вызываются быстрее виртуальных, но для запечатанного класса может быть создан более эффективный код. Если класс не запечатан, то производный класс может изменить его состояние и нарушить безопасность.

Если класс не предназначен для наследования, его желаетльно объявлять запечатанным. При отсутствии необходимости доступа этому классу из других сборок его следует объявить внутренним. При переопределении класса следует переопределать и запечатывать все виртуальные методы, которые наследует класс.

Все поля класса - закрытые. 

Методы, свойства и события класса следует объявлять закрытыми и невиртуальными. Некоторые методы, свойства и события должны быть открытыми, но лучше не защищенными или вообще - внутренними. 

Если реализация алгоритма чрезмерно усложняется, следует сделать классы вложенными и закрытыми.


