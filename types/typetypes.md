# Разновидности типов

>При обозначении переменной можно использовать как системное имя типа .NET, так и сокращенное имя C#.

Примитивные типы данных C#:

Сокращенное | Совместимость с CLS | Системное имя | Диапазон | Описание
-----|-----|-----|-----|----
bool | Да | System.Boolean | true, false | Булево значение (истина или ложь)
sbyte | Нет | System.Sbyte | –128 до 127 | 8-разрядное значение со знаком
byte | Да | System.Byte | 0 до 255 | 8-разрядное значение без знака
short | Да | System.Int16 | –32768 до 32767 | 16-разрядное значение со знаком
ushort | Нет | System.Uint16 | 0 до 65535 | 16-разрядное значение без знака
int | Да | System.Int32 | –2,147,483,648 до 2,147,483,647 | 32-разрядное значение со знаком
uint | Нет | System.Uint32 | 0 до 4,294,967,295 | 32-разрядное значение без знака
long | Да | System.Int64 | –9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 | 64-разрядное значение со знаком
ulong | Нет | System.Uint64 | 0 до 18,446,744,073,709,551,615 | 64-разрядное значение без знака
char | Да | System.Char | U+0000 до U+ffff | 16-разрядный символ Unicode (char никогда не представляет 8-разрядное значение)
float | Да | System.Single | –3.4 10^38 до +3.4 10^38 | 32-разрядное значение с плавающей точкой
double | Да | System.Double | ±5.0 10^324 to ±1.7 10^308 | 64-разрядное значение с плавающей точкой
decimal | Да | System.Decimal | (–7.9 x 1028 to 7.9 x 1028)/(10^(0 до 28)) | 128-разрядное число
string | Да | System.String | Ограничено объемом системной памяти | Массив символов
object | Да | System.Object | Может хранится любой тип данных | Базовый класс для всех типов
dynamic | Да | System.Object | Может хранится любой тип данных | Для CLR идентичен object, а для C# - динамическое разрешение типа

## Ссылочные и значимые типы

CLR поддерживает две разновидности типов - ссылочные и значимые.

Особенности ссылочных типов:

- Память для ссылочных типов выделяется из управляемой кучи

- Каждый объект, помещаемый в куче, нуждается в дополнительной инициализации членов

- Незанятые полезной информацией байты обнуляются

- Размещение объектов в управляемой куче со временем вызывает сборку мусора

Значимые типы размещаются в стеке, хотя могут быть встроены в объект ссылочного типа. Все значимые типы являются производными от типа System.ValueType.

Преимущество значимых типов в том, что они не размещаются в управляемой куче. 

У всякого значимого типа неявно есть открытый конструктор без параметров, а у ссылочных может и не быть открытого конструктора без параметров.

К недостаткам значимых типов можно отнести: 

- существуют в упакованном и неупакованном виде, а ссылочные - только в упакованном; 

- значимые являются производными от ValueType в котором переопределены методы Equals и GetHashCode; 

- при присвоении одного значения к другому происходит копирование значений;

- выделенная память для значимых типов сразу освобождается при выходе из метода.

## Структуры долько для чтения

Структуры можно также помечать как допускающие только чтение, если необходимо, чтобы они были неизменяемыми.

```csharp
readonly struct Values
{
    public int Value { get; }
    public Values(int value)
    {
        Value = value;
    }
}
```

Можно делать не всю структуру только для чтения, а отдельные члены ее помечать readonly.

## Структуры только для стека

При определении структуры появилась возможность применения модификатора ref. Он требует, чтобы все экземпляры структуры находились в стеке и не могли присваиваться свойству другого класса.

```csharp
public ref struct Values
{
    public readonly int Value { get; }
    public Values(int value)
    {
        Value = value;
    }
}
```

## Размещение полей типов в памяти

Для ссылочных типов (классов) по умолчанию устанавливается LayoutKind.Auto (порядок полей устанавливается CLR), а для значимых (структур) - LayoutKind.Sequential (сохранить установленный порядок). 

Параметр LayoutKind.Explicit позволяет разместить поля в памяти, явно задав смещения. Если параметр не указан - порядок выберет компилятор.

```csharp
[StructLayout(LayoutKind.Auto)]
internal struct SomeValType 
{
    private readonly Byte m_b;
}
```

## Упаковка и распаковка типов

Для того, например, чтобы поместить элемент значимого типа в, например, массив, его нужно преобразовать в объект управляемой кучи и передать ссылку в метод.

```csharp
ArrayList a = new ArrayList();
Point p;
a.Add(p);
```

При упаковке происходит следущее:

- в управляемой куче выделяется память для объекта, указателя на объект-тип и индекса блока синхронизации;

- поля значимого типа копируются в память объекта, только что созданного в куче;

- возвращается адрес созданного объекта.

Для того, чтоб обратно получить значимый тип, происходит обратная операция - распаковка. Для этого все поля, содержащиеся в упакованном типе, необходимо скопировать в элемент значимого типа, находящегося в стеке потока. 

Сначала извлекается адрес полей структуры из упакованного объекта. Этот процесс называют распаковкой (unboxing). 

При распаковке происходит следущее:

- Проверка ссылки на упакованный элемент на равенство null и тогда генерирование исключения NullReferenceException

- Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа - генерируется исключение InvalidCastOperation.

Затем значения полей копируются из кучи в экземпляр значимого типа, находящийся в стеке. Распаковка гораздо более ресурсозатранта, чем упаковка.

```csharp
Point p = (Point) a[0];
```

Пример - аж ТРИ операции упаковки и распаковки:

```csharp
public static void Main() 
{
Int32 v = 5; // Создание неупакованной переменной значимого типа o
Object o = v; // указывает на упакованное Int32, содержащее 5
v = 123; // Изменяем неупакованное значение на 123
Console.WriteLine(v + ", " + (Int32) o); // Отображается "123, 5"
}
```

Можно повысить быстродействие, выполнив упаковку вручную:

```csharp
Object o = v; // Упакуем вручную v
```

Вызов невиртуального унаследованного метода GetType & MemberwiseClone требует упаковки значимого типа, так как эти типы определены в System.Object, в методе в this должен быть передан указатель на объект в куче. 

Приведение неупакованного элемента значимого типа к интерфейсу требует, чтобы экземпляр был упакован, так как интерфейсные методы всегда должны содержать this на объект в куче.

Значения в упакованном значимом элементе можно изменить с использованием интерфейса:

```csharp
interface IChangePoint
{
    void Change(int x, int y);
}
struct Point : IChangePoint
{
    ...
    public void Change(int x, int y)
    {
        _x = x; _y = y;
    }
}
var p = new Point(1, 1);
object o = p;
((IChangePoint)o).Change(5, 5);
```

Если метод, например, ToString() переопределен в значимом типе, это предотвращает упаковку. При вызове невиртуального метода GetType() однозначно происходит упаковка, так как используется унаследованный от System.Object метод. Вызов определенного в значимом типе метода CompareTo() с передаваемым в параметрах значимом типе предотвращает упаковку - значение в метод будет передаваться по значению. 

При приведении значимого типа к интерфейсу однозначно необходима упаковка, так как интерфейсы имеют ссылочный тип, GetType указывает на упакованный объект в куче. Приведение упакованного значимого типа или приведенного к интерфейсу типа в значимый элемент производится путем распаковки и копировния значений.

## Записи

В языке C# есть особый вид классов — записи. Записи являются ссылочными или значимыми типами, которые предоставляют синтезированные методы с целью обеспечения семантики значений для эквивалентности. По умолчанию типы записей-классов неизменяемы.

Как и обычные классы record-классы могут наследоваться. Можно определять записи-структуры и записи-классы. Если определяется класс record, то ключевое слово class можно неиспользовать при определении типа.

Пример простой записи:

```csharp
internal record SampleRec
{
    public int Value { get; init; }
    public SampleRec() { }
    public SampleRec(int val)
    {
        Value = val;
    }
}
// использование
var rec = new SampleRec(10);
```

В записях метод ToString() переопределен и формирует более информативную строку о состоянии значений в записи.

Есть более сокращенная форма определения записи:

```csharp
internal record SampleRec(int Value), bool It; //класс-запись
record class SampleRecClass(int Value, bool It) : SampleRec(Value, It); //класс-запись
record struct SampleRecStruct(int Value, bool It); //класс-структура
```

Типы записей ведут себя по-другому. Они неявно переопределяют Equals ( ) , == и !=, чтобы производить результаты так, как если бы они были типами значений. Сравнение записей производится по значению.

Для типов записей присваивание экземпляра такого типа новой переменной создает указатель на ту же самую ссылку, что аналогично поведению классов.

Для создания подлинной копии записи с модифицированным одним или большим числом свойств в C# были введены выражения with. В конструкции with указываются любые подлежащие обновлению свойства вместе с их новыми значениями, а значения свойств, которые не были перечислены, копируются без изменений.

```csharp
internal record SampleRec(int Value, bool It);
//использование
var rec = new SampleRec(10, true);
var same = rec;
var copy = rec with { };
var two = rec with { Value = 10 };
```

Типы записей-структур - изменяемы по умолчанию. Чтобы для подобных свойств структуры record использовался модификатор init вместо обычных сеттеров, такую структуру надо определить с ключевым словом readonly.

```csharp
readonly record struct SampleRecStruct(int Value, bool It);
```



