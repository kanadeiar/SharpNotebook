# Разновидности типов

>При обозначении переменной можно использовать как системное имя типа .NET, так и сокращенное имя C#.

Примитивные типы данных C#:

Сокращенное | Совместимость с CLS | Системное имя | Диапазон | Описание
-----|-----|-----|-----|----
bool | Да | System.Boolean | true, false | Булево значение (истина или ложь)
sbyte | Нет | System.Sbyte | –128 до 127 | 8-разрядное значение со знаком
byte | Да | System.Byte | 0 до 255 | 8-разрядное значение без знака
short | Да | System.Int16 | –32768 до 32767 | 16-разрядное значение со знаком
ushort | Нет | System.Uint16 | 0 до 65535 | 16-разрядное значение без знака
int | Да | System.Int32 | –2,147,483,648 до 2,147,483,647 | 32-разрядное значение со знаком
uint | Нет | System.Uint32 | 0 до 4,294,967,295 | 32-разрядное значение без знака
long | Да | System.Int64 | –9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 | 64-разрядное значение со знаком
ulong | Нет | System.Uint64 | 0 до 18,446,744,073,709,551,615 | 64-разрядное значение без знака
char | Да | System.Char | U+0000 до U+ffff | 16-разрядный символ Unicode (char никогда не представляет 8-разрядное значение)
float | Да | System.Single | –3.4 10^38 до +3.4 10^38 | 32-разрядное значение с плавающей точкой
double | Да | System.Double | ±5.0 10^324 to ±1.7 10^308 | 64-разрядное значение с плавающей точкой
decimal | Да | System.Decimal | (–7.9 x 1028 to 7.9 x 1028)/(10^(0 до 28)) | 128-разрядное число
string | Да | System.String | Ограничено объемом системной памяти | Массив символов
object | Да | System.Object | Может хранится любой тип данных | Базовый класс для всех типов
dynamic | Да | System.Object | Может хранится любой тип данных | Для CLR идентичен object, а для C# - динамическое разрешение типа

## Ссылочные и значимые типы

CLR поддерживает две разновидности типов - ссылочные и значимые.

Особенности ссылочных типов:

- Память для ссылочных типов выделяется из управляемой кучи

- Каждый объект, помещаемый в куче, нуждается в дополнительной инициализации членов

- Незанятые полезной информацией байты обнуляются

- Размещение объектов в управляемой куче со временем вызывает сборку мусора

Значимые типы размещаются в стеке, хотя могут быть встроены в объект ссылочного типа. Все значимые типы являются производными от типа System.ValueType.

Преимущество значимых типов в том, что они не размещаются в управляемой куче. 

У всякого значимого типа неявно есть открытый конструктор без параметров, а у ссылочных может и не быть открытого конструктора без параметров.

К недостаткам значимых типов можно отнести: 

- существуют в упакованном и неупакованном виде, а ссылочные - только в упакованном; 

- значимые являются производными от ValueType в котором переопределены методы Equals и GetHashCode; 

- при присвоении одного значения к другому происходит копирование значений;

- выделенная память для значимых типов сразу освобождается при выходе из метода.

## Структуры долько для чтения

Структуры можно также помечать как допускающие только чтение, если необходимо, чтобы они были неизменяемыми.

```csharp
readonly struct Values
{
    public int Value { get; }
    public Values(int value)
    {
        Value = value;
    }
}
```

Можно делать не всю структуру только для чтения, а отдельные члены ее помечать readonly.

## Структуры только для стека

При определении структуры появилась возможность применения модификатора ref. Он требует, чтобы все экземпляры структуры находились в стеке и не могли присваиваться свойству другого класса.

```csharp
public ref struct Values
{
    public readonly int Value { get; }
    public Values(int value)
    {
        Value = value;
    }
}
```

## Размещение полей типов в памяти

Для ссылочных типов (классов) по умолчанию устанавливается LayoutKind.Auto, а для значимых (структур) - LayoutKind.Sequential.

```csharp
[StructLayout(LayoutKind.Auto)]
internal struct SomeValType 
{
    private readonly Byte m_b;
}
```

## Упаковка и распаковка типов

Для того, например, чтобы поместить элемент значимого типа в, например, массив, его нужно преобразовать в объект управляемой кучи и передать ссылку в метод.

```csharp
ArrayList a = new ArrayList();
Point p;
a.Add(p);
```

При упаковке происходит следущее:

- в управляемой куче выделяется память для объекта, указателя на объект-тип и индекса блока синхронизации;

- поля значимого типа копируются в память объекта, только что созданного в куче;

- возвращается адрес созданного объекта.

Для того, чтоб обратно получить значимый тип, происходит обратная операция - распаковка. Для этого все поля, содержащиеся в упакованном типе, необходимо скопировать в элемент значимого типа, находящегося в стеке потока. Распаковка гораздо более ресурсозатранта, чем упаковка.

```csharp
Point p = (Point) a[0];
```

При распаковке происходит следущее:

- Проверка ссылки на упакованный элемент на равенство null и тогда генерирование исключения NullReferenceException

- Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа - генерируется исключение InvalidCastOperation

- поля ссылочного типа по указателю копируются в память значимого типа, находящегося в стеке;

Три операции упаковки и распаковки:

```csharp
public static void Main() 
{
Int32 v = 5; // Создание неупакованной переменной значимого типа o
Object o = v; // указывает на упакованное Int32, содержащее 5
v = 123; // Изменяем неупакованное значение на 123
Console.WriteLine(v + ", " + (Int32) o); // Отображается "123, 5"
}
```

Можно повысить быстродействие, выполнив упаковку вручную:

```csharp
Object o = v; // Упакуем вручную v
```

Вызов невиртуального унаследованного метода GetType & MemberwiseClone требует упаковки значимого типа, так как эти типы определены в System.Object, в методе в this должен быть передан указатель на объект в куче. 

Приведение неупакованного элемента значимого типа к интерфейсу требует, чтобы экземпляр был упакован, так как интерфейсные методы всегда должны содержать this на объект в куче.

Значения в упакованном значимом элементе можно изменить с использованием интерфейса:

```csharp
interface IChangePoint
{
    void Change(int x, int y);
}
struct Point : IChangePoint
{
    ...
    public void Change(int x, int y)
    {
        _x = x; _y = y;
    }
}
var p = new Point(1, 1);
object o = p;
((IChangePoint)o).Change(5, 5);
```

Если метод, например, ToString() переопределен в значимом типе, это предотвращает упаковку. При вызове невиртуального метода GetType() однозначно происходит упаковка, так как используется унаследованный от System.Object метод. Вызов определенного в значимом типе метода CompareTo() с передаваемым в параметрах значимом типе предотвращает упаковку - значение в метод будет передаваться по значению. 

При приведении значимого типа к интерфейсу однозначно необходима упаковка, так как интерфейсы имеют ссылочный тип, GetType указывает на упакованный объект в куче. Приведение упакованного значимого типа или приведенного к интерфейсу типа в значимый элемент производится путем распаковки и копировния значений.

