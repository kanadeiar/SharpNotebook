# Методы

Методы могут быть реализованы внутри области видимости классов, структур или интерфейсов.

```csharp
модификаторы  тип вертаемого   имя     параметры
    public static void MyFunc(str string)
    {
        ...         тело метода
    }  
```

Пример простого метода, сжатого до выражения:

```csharp
static int Add(int x, int y) => x + y;
```

## Локальные функции

Можно создавать методы (проще назвать локальную функцию) внутри методов.

Пример:
```csharp
PrintBox();
void PrintBox() => WriteLine("Box");
```

Модификатор static. Можно добавлять ключевое слово statiс для гарании что локальная функция не захватывает и не ссылается на переменные в области ее видимости.

```csharp
int var = 25;
PrintBox(45);
static void PrintBox(int var) => WriteLine($"Box {var}"); // Box 45
```

## Конструктор ссылочных типов

Конструкторы типа - специальные методы, корректно инициализирующие новый экземпляр типа. При создании экземпляра объекта ссылочного типа выделяется память для полей данных, инициализируются служебные поля и затем вызывается конструктор, устанавливающий исходное состояние объекта.

Конструкторы класса не наследуются. Если конструктор явно в классе не задать, то компилятор создаст неявный конструктор без параметров по умолчанию.

Для абстрактных классов компилятор создает конструктор по умолчанию с модификатором защищенный. Для статических классов конструктор по умолчанию не создается. Производные классы от базового должны вызывать констрктор базового.

Всегда вызывается неявно конструктор базового класса System.Object без параметров. Поля, инициализирующиеся при определении неявно инициализируются в конструкторе без параметров.

```csharp
internal sealed class Sample
{
    private Int32 _value = 5;
}
```

Один конструктор может вызывать другой конструктор используя ключевое слово this.

```csharp
internal sealed class Sample
{
    private Int32 _value;
    public Sample()
    {
        _value = 5;
    }
    public Sample(Int32 value) : this() 
    {
        _value = value;
    }
}
```

## Конструктор значимых типов

CLR всегда разрешает создание экземпляров значимых типов. Конструкоры у значимых типов можно не определять. Компилятор определяет конструктор по умолчанию не имеющий параметров для значимого типа, в нем поля значимого типа инициализируются значением 0 / null. 

CLR позволяет определять конструкторы для значимых типов, но они должны вызыватся только при наличии кода, явно вызывающего их.

CLR еще позволяет определять конструкторы без параметров для значимых типов. Также можно устанавливать значения по умолчанию для полей и свойств структур, но тогда нужно установить значения для всех полей.

```csharp
internal struct Test
{
    public Int32 _value;
    public Test(Int32 value)
    {
        _value = value;
    }
}
// использование
_test = new Test(1);
```

Тогда оператор new вызывает конструктор для инициализации полей значимого типа. 

Компилятор не генерирует автоматически код для вызова конструктора по умолчанию для значимого типа даже при наличии конструктора без параметров, нужно его явно вызвать.

Компилятор C# позволяет определять для значимого типа как конструкторы без параметров, так и конструкторы с параметрами.

В значимых типам можно задавать инициализацию начальных значений свойств и полей.

```csharp
internal struct SampleVal
{
    public int value = 10;
    public int Val2 { get; set; }
    public SampleVal()
    {
        Val2 = 20;
    }
    public SampleVal(Int32 value)
    {
        this = new SampleVal();
        value = 10;
    }
}
// использование
SampleVal v1 = new();
var v2 = new SampleVal(10);
```

В конструкторе значимого типа this - экземпляр значимого типа, допускает запись, а в конструкторах ссылочного типа указатель this - только для чтения.

## Конструкторы типов

Также называют статическими конструкторами. Такие конструкторы можно применять к интерфейсам, ссылочным и значимым типам. Первоначально у типа не определено конструктора. Не может быть более 1 конструктора, у таких конструкторов нет параметров.

```csharp
internal sealed class Sample
{
    private static Int32 _value;
    static Sample()
    {     
        _value = 5;
    }
}
internal struct SampleVal
{
    static SampleVal()
    {
    }
}
```

Компилятор такие конструкторы делает зарытыми автоматически. 

>Конструкторы в значимом типе не следует определять, так как CLR не всегда вызывает статический конструктор значимого типа.

CLR старается гарантировать, чтобы конструктор типа выполнялся только раз в каждом домене приложений. Для этого при вызове конструктора типа вызывающий поток в рамках синхронизации потоков получает исключающую блокировку. Только первый поток выполнит код статического конструктора.

>Конструктор типов лучше всего подходит для инициализации всех объектов-одиночек.

Если в конструкторе типа генерируется необработанное исключение, то такой тип становится непригодным. Код из такого конструктора может использовать только статические поля класса.

В значимых типах допускается использовать конструкторы статические.

```csharp
internal struct SampleVal
{
    public Int32 _value;
    static SampleVal()
    {
        _value = value;
    }
}
```

## Перегрузка методов

В C# разрешена перегрузка методов. Когда определяется набор идентично именованных методов, которые отличаются друг от друга количеством (или типами) параметров, то говорят, что такой метод был перегружен.

```csharp
public class Sample
{
    static int Add(in int x, in int y)
    {
        var ans = x + y;
        return ans;
    }
    static double Add(in double x, in double y)
    {
        var ans = x + y;
        return ans;
    }
}
```

Модификаторы in, ref и out не считаются частью сигнатуры при перегрузке методов, когда используется более одного модификатора.

## Перегрузка операторов

CLR ничего не известно о перегрузке операторов, для CLR это просто методы, она указывает как языки программирования должны предоставлят доступ к перегруженным операторам. Перегрузка операторов определяется языком программирования.

Перегруженные операторы должны быть открытыми и статическими. 

Пример перегруженного оператора:

```csharp
public static Sample operator+(Sample s1, Sample s2) { ... }
```

Когда компилятор в тексте видит оператор +, он исследует типы его операндов, выясняет существование определения для одного из них специального метода op_XXX со специальным флагом specialname. При нахождении такого метода, компилятор генерирует код вызова этого метода.

Унарные операторы C#:

Оператор C# | Имя специального метода | Рекомендуемое CLS-совместимое имя
----|-----|-----
\+ | op_UnaryPlus | Plus
\- | op_UnaryNegation | Negate
\! | op_LogicalNot | Not
\- | op_OnesComplement | OnesComplement
\+\+ | op_Increment | Increment
\-\- | op_Decrement | Decrement
Нет | op_True | IsTrue { get; }
Нет | op_False | IsFalse { get; }

Бинарные операторы C#:

Оператор C# | Имя специального метода | Рекомендуемое CLS-совместимое имя
----|-----|-----
\+ | op_Addition | Add
\- | op_Subtraction | Subtract
\* | op_Multiply | Multiply
\/ | op_Division | Divide
\% | op_Modulus | Modulus
\& | op_BitwiseAnd | BitwiseAnd
\|\| | op_BitwiseOr | BitwiseOr
\^ | op_ExclusiveOr | Xor
\<\< | op_LeftShift | LeftShift
\>\> | op_RightShift | RightShift
\=\= | op_Equality | Equality
\!\= | op_Inequality | Inequality
\< | op_LessThan | Compare
\> | op_GreatherThan | Compare
\<\= | op_LessThanOrEqual | Compare
\>\= | op_GreatherThanOrEqual | Compare

## Методы операторов преобразования

Когда целевой и требуемый тип являются примитивными, компилятор справляется сам, но если один тип не является примитивным - нужно создать код, заставляющий CLR выполнить приведение типов.

Для этого в типе должны определяться открытые конструкторв, принимающие в качестве параметра экземпляр преобразуемого типа. Язык C# поддерживает перегрузку операторов преобразования. Они определяются с помощью специального синтаксиса.

```csharp
public sealed class Sample
{
    public Sample(Int32 value) { ... }
    public Int32 ToInt32() { ... }
    //Неявное приведение типа
    public static implicit operator Sample(Int32 value) => new Sample(value);
    //Явное приведение типа
    public static explicit operator Int32(Sample sample) => sample.ToInt32();
}
```

Компилятор C# при обнаружении внутренних механизмов генерирует IL-код, вызывающий методы операторов преобразования, определенные в этом типе. Компилятор генерирует по одному методу для каждого оператора преобразования типа.

Если точность при приведении типов не теряется - то следует определять оператор неявного преобразования, иначе - явного. Если попытка явного приведения завешнится неудачей, следует выбрасывать исключение OverflowException или InvalidOperationException. 

>Операторы неявноо преобразования никода не вызываются при использовании операторов is или as.

## Методы расширения

Методы расширения позволяют определить статический метод, который вызывается посредством синтаксиса экземплярного метода.

```csharp
public static class Int32Exts
{
    public static Int32 SumOf(this Int32 one, Int32 two)
    {
        return one + two;
    }
}
// варианты использования
var result = Int32Exts.SumOf(value, 32);
var result = value.SumOf(32);
```

Методы расширения должны быть объявлены в статическом необобщенном классе. Метод должен иметь хотябы один параметр, первый параметр должен быть помечен ключевым словом this. Компилятор ищет C# методы разширения только в статических классах. Если в нескольких статических классах определены несколько одинаковых методов расширения, то тогда выдается сообщение о ошибке (для устранения ошибки нужно применять синтаксис статического метода с указанием имени статического класса).

При расширении одного типа методом расширения все унаследованные типы также будут расширены этим методом. Экземплярный метод с таким-же названием как и метод расширения, имеет приоритет над методом расширения.

Среда CLR при вызове метода расширения не производит проверку объекта на null.

```csharp
String value = null;
var result = value.MyIfIsNull(5); //NullReferenceException не будет
```

Можно определять методы расширения для интерфейсных типов.

```csharp
public static void MyTestItems<T>(this IEnumerable<T> collection)
{
    ...
}
//использование:
"Grant".MyTestItems();
new[] {"One", "Two"}.MyTestItems();
new List<Int32>() {1, 2, 3}.MyTestItems();
```

Можно определять методы расширения для типов делегатов и для перечислимых типов.

В компиляторе C#, при пометке первого параметра статического метода ключевым словом this, компилятор устанавливает специальный атрибут к методу, и к статическому классу. Это позволяет компилятору быстро просканировать все ссылающиеся сборки, чтоб определить, какая из них содержит методы расширения и в дальнейшем быстро находить все расширения.

## Частичные методы

Для решения проблемы переопределения можно применять частичные методы языка C#. Класс может быть запечатанным, статическим или значимым. Код определения двух частичных классов компилируется в один тип. Код базового метода - объявление частичного метода с пометкой partial и не имеет тела. Код обычного метода реализует объявление частиного метода с пометкой partial и имеет тело.

```csharp
internal sealed partial class Base
{
    partial void OnTest();
}
internal sealed partial class Base
{
    partial void OnTest()
    {
        System.Console.WriteLine("OnTest");
    }
}
```

Преимущество такого решения - при отсутствии объявления выполняемого частичного метода компилятор не будет генерировать метаданные частичного метода. Частичные методы могут объявлятся только внутри частичного класса или структуры. Частичные методы должны иметь возвращаемый тип void и не могут иметь параметров out. Частичные метод не существует во время выполнения программы.
