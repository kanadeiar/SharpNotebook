# Свойства

Согласно принципу инкапсуляции данных ООП нельзя открывать доступ внутренних полей класса для чтения и для записи. Поля классов нужно помечать как закрытые, а доступ к полям допускать через специальные методы доступа (аксессоры). Методы доступа могут осуществлять дополнительные проверки правильности данных.
 
>В случае простых методов доступа get и set JIT-компилятор подставляет код метода доступа внутрь кода вызываемого метода и снижения производительности, как в случае вызова метода, не наблюдается. Код метода доступа компилируется вместе с кодом вызывающего метода. Во время отладки этого не производится, только в оптимизированном коде.

```csharp
public sealed class Sample
{
    private int _age;
    public int GetAge()
    {
        return _age;
    }
    public void SetAge(int value)
    {
        if (value < 0)
            throw new ArgumentOutOfRangeException("value");
        _age = value;
    }
}
// использование
e.SetAge(40);
var a = e.GetAge();
```

CLR поддерживает механизм свойств, делающий это более красивым.

```csharp
public sealed class Sample
{
    private int _age;
    public int Age
    {
        get { return _age; }
        set {
            if (value < 0)
                throw new ArgumentOutOfRangeException("value");
            _age = value;
        }
    }
}
// использование
e.Age = 40;
var a = e.Age;
```

CLR поддерживает статические, экземплярные, абстрактные и виртуальные свойства. Свойства могут помечатся модификатором доступа и определяться в интерфейсах. Нельзя перегружать свойства. Можно опускать один из методов get и set, делая свойство доступным только для чтения или только для записи. Можно определять свойства не поддерживающие приватные поля, вычисляющие какое либо значение.

CLR не использует метаданные, генерируемые компилятором C# по поводу свойств, требуя при выполнении только методы доступа.

## Автоматически реализуемые свойства

Для инкапсуляции резервных полей в C# есть упрощенный синтаксис свойств. 

```csharp
public sealed class Sample
{
    public int Age { get; set; }
}
```

Компилятор C# автоматически объявит необходимые закрытые поля и реализует методы get_ и set_ для свойства.

Недостатки автоматически реализуемых свойств:

- Синтаксис может включать инициализацию, а в автоматических - такого нет.

- Нельзя использовать автоматические свойства для типов, подлежащих сериализации и десериализации.

- Во время отладки нельзя установить точку останова в автоматических свойствах.

- Механизм автоматических свойств работает слишком безкомпромиссно.

Недостатки самих свойств:

- Могут быть только для чтения или только для записи. Может случится нежданчик.

- Свойство может вызывать исключения, а поля - нет.

- Свойства нельзя передавать в метод в качестве параметров с ключевым словом ref или out.

- Обращение к свойству может быть медленным.

- Свойству может требоваться дополнительная память или ссылка на объект.

## Инициализаторы объектов

Для упрощения операции создания и установки у созданного объекта некоторых открытых свойств или полей в C# предусмотрен синтаксис инициализации объекта.

```csharp
var s = new Sample() { Value = 10 };
```

Можно опускать круглые скобки перед открывающей фигурной скобкой.

```csharp
var s = new Sample { Value = 10 }.ToString().ToUpper();
```

## Инициализаторы коллекций

В C# доступна инициализация коллекций синтаксисом инициализации объекта. Инициализация коллекци является дополняющей опреацией, а не заменяющей.

```csharp
var list = new List<int> { 1, 2, 3 };
```
Это равносильно этому:
```csharp
var list = new List<int>();
list.Add(1);
list.Add(2);
list.Add(3);
```

Для такой инициализации коллекции объект должен содержать определение метода Add().

Можно инициализировать словарь таким синтаксисом:

```csharp
var dict = new Dictionary<string, int> { {"Test", 1}, {"Sample", 2}, {"Third", 3} };
```

## Анонимные типы

Механизм анонимных типов в C# позволяет автоматически объявить новый тип без названия, содержащих набор свойств, каким-либо образом связанных друг с другом. Значения в анонимных типах неизменны. Экземпляры анонимного типа не должны выходить за пределы метода. В прототипе метода не может содержаться параметр анонимного типа, так как задать анонимный тип невозможно. Метод не может возвращать ссылку на анонимный тип.

Пример определения нового объекта и класса и вывод свойств в консоль:

```csharp
var test = new { One = 1, Two = 2 };
Console.WriteLine($"One = {test.One} Two = {test.Two}");
```

Компилятор C# определяет тип каждого выражения, создает закрытые поля этих типов, для каждого поля создает открытые поля доступа, переопределяет методы Equals, GetHashCode, ToString объекта и создает код этих методов.

Компилятор C# может выводить имена на основании имен переменных.

```csharp
var dt = DateTime.Now;
var test = new { dt.Year };
Console.WriteLine($"Year = {test.Year}");
```

Если компилятор видит определение множества анонимных типов с одинаковой структурой, то он создает одно определение для анонимного типа и множество экземпляров этого типа.

Анонимные типы поддерживают создание из них массивов.

```csharp
var arr = new[] 
{
    new { Value = 1 },
    new { Value = 2 },
    new { Value = 3 },
};
foreach (var item in arr)
{
    Console.WriteLine($"{item.Value}");
};
```

## Кортежи

Определено несколько обобщенных кортежных типов унаследованных от System.Object, которые отличаются количеством обобщенных параметров. 

```csharp
[Serializable]
public class Tuple<T1> 
{
    private T1 m_Item1;
    public Tuple(T1 item1) { m_Item1 = item1; }
    public T1 Item { get { return m_Item1; } }
}
```

Значения в кортежах неизменны. Позволяют использовать CompareTo, Equals, GetHashCode, ToString, Size. 

Пример использования:

```csharp
private static Tuple<int, int> Swap(int a, int b)
{
    return new Tuple<int, int>(b, a);
}
// использование
var vals = Swap(1, 2);
System.Console.WriteLine($"{vals.Item1} {vals.Item2}");
```

В кортежах нельзя именовать свойства, эти названия назначаются автоматически.

## Свойства с параметрами

Свойства с параметрами принимают получают в метод get один или несколько параметров. В языке C# синтаксис свойств с параметрами напоминает синтаксис массивов, это позволяет разработчику перегружать оператор [].

```csharp
public class MyArray
{
    private int[] _array;
    public MyArray()
    {
        _array = new int[] { 1, 2, 3 };
    }
    public int this[int index]
    {
        get => _array[index];
        set => _array[index] = value;
    }
}
// использование
var arr = new MyArray();
for (var i = 0; i < 3; i++)
{
    System.Console.WriteLine(arr[i]);
}
```

У каждого индексатора должен быть хотяб один параметр, но параметров может быть и больше. Тип параметров может быть любым. Тип может иметь множество перегруженных индексаторов при условии, что их сигнатуры различны.

В CLR индесаторы - это методы. Имена создаваемых методов для индексаторов - get_Item и set_Item. 

Обнаружив попытку доступа чтения или записи индексатора, компилятор C# генерирует код вызова нужного метода.

## Модификаторы доступа свойств

Можно назначать различные модификаторы доступа на свойства.

```csharp
public class Sample
{
    private int _value;
    public int Value
    {
        get => _value;
        protected set => _value = value;
    }
}
```

