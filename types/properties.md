# Свойства

Согласно принципу инкапсуляции данных ООП нельзя открывать доступ внутренних полей класса для чтения и для записи. Поля классов нужно помечать как закрытые, а доступ к полям допускать через специальные методы доступа (аксессоры). Методы доступа могут осуществлять дополнительные проверки правильности данных.
 
>В случае простых методов доступа get и set JIT-компилятор подставляет код метода доступа внутрь кода вызываемого метода и снижения производительности, как в случае вызова метода, не наблюдается. Код метода доступа компилируется вместе с кодом вызывающего метода. Во время отладки этого не производится, только в оптимизированном коде.

```csharp
public sealed class Sample
{
    private int _age;
    public int GetAge()
    {
        return _age;
    }
    public void SetAge(int value)
    {
        if (value < 0)
            throw new ArgumentOutOfRangeException("value");
        _age = value;
    }
}
// использование
e.SetAge(40);
var a = e.GetAge();
```

CLR поддерживает механизм свойств, делающий это более красивым.

```csharp
public sealed class Sample
{
    private int _age;
    public int Age
    {
        get { return _age; }
        set {
            if (value < 0)
                throw new ArgumentOutOfRangeException("value");
            _age = value;
        }
    }
}
// использование
e.Age = 40;
var a = e.Age;
```

CLR поддерживает статические, экземплярные, абстрактные и виртуальные свойства. Свойства могут помечатся модификатором доступа и определяться в интерфейсах. Нельзя перегружать свойства. Можно опускать один из методов get и set, делая свойство доступным только для чтения или только для записи. Можно определять свойства не поддерживающие приватные поля, вычисляющие какое либо значение.

CLR не использует метаданные, генерируемые компилятором C# по поводу свойств, требуя при выполнении только методы доступа.

Свойства могут быть записаны в виде членов, сжатых до выражений. Пример:

```csharp
public int Age
{
    get => _empAge;
    set => _empAge = value;
}
```

## Автоматически реализуемые свойства

Для инкапсуляции резервных полей в C# есть упрощенный синтаксис свойств. 

```csharp
public sealed class Sample
{
    public int Age { get; set; }
}
```

Компилятор C# автоматически объявит необходимые закрытые поля и реализует методы get_ и set_ для свойства.

Недостатки автоматически реализуемых свойств:

- Синтаксис может включать инициализацию, а в автоматических - такого нет.

- Нельзя использовать автоматические свойства для типов, подлежащих сериализации и десериализации.

- Во время отладки нельзя установить точку останова в автоматических свойствах.

- Механизм автоматических свойств работает слишком бескомпромиссно.

Недостатки самих свойств:

- Могут быть только для чтения или только для записи.

- Свойство может вызывать исключения, а поля - нет.

- Свойства нельзя передавать в метод в качестве параметров с ключевым словом ref или out.

- Обращение к свойству может быть медленным.

- Свойству может требоваться дополнительная память или ссылка на объект.

## Свойства только для инициализации

Свойства такого типа называются неизменяемыми. Они позволяет устанавливать свойство во время инициализации, но после завершения конструирования объекта свойство становится доступным только для чтения. 

```csharp
internal sealed class Sample
{
    public int Value { get; init; }
    public Sample(int val)
    {
        Value = val;
    }
}
```

## Инициализаторы объектов

Для упрощения операции создания и установки у созданного объекта некоторых открытых свойств или полей в C# предусмотрен синтаксис инициализации объекта.

```csharp
var s = new Sample() { Value = 10 };
```

Можно опускать круглые скобки перед открывающей фигурной скобкой.

```csharp
var s = new Sample { Value = 10 }.ToString().ToUpper();
```

## Инициализаторы коллекций

В C# доступна инициализация коллекций синтаксисом инициализации объекта. Инициализация коллекции является дополняющей опреацией, а не заменяющей.

```csharp
var list = new List<int> { 1, 2, 3 };
```
Это равносильно этому:
```csharp
var list = new List<int>();
list.Add(1);
list.Add(2);
list.Add(3);
```

Для такой инициализации коллекции объект должен содержать определение метода Add().

Можно инициализировать словарь таким синтаксисом:

```csharp
var dict = new Dictionary<string, int> { {"Test", 1}, {"Sample", 2}, {"Third", 3} };
```

## Свойства с параметрами (индексаторы)

Свойства с параметрами принимают получают в метод get один или несколько параметров. В языке C# синтаксис свойств с параметрами напоминает синтаксис массивов, это позволяет разработчику перегружать оператор [].

```csharp
public class MyArray
{
    private int[] _array;
    public MyArray()
    {
        _array = new int[] { 1, 2, 3 };
    }
    public int this[int index]
    {
        get => _array[index];
        set => _array[index] = value;
    }
}
// использование
var arr = new MyArray();
for (var i = 0; i < 3; i++)
{
    System.Console.WriteLine(arr[i]);
}
```

У каждого индексатора должен быть хотяб один параметр, но параметров может быть и больше. Тип параметров может быть любым. Тип может иметь множество перегруженных индексаторов при условии, что их сигнатуры различны.

В CLR индесаторы - это методы. Имена создаваемых методов для индексаторов - get_Item и set_Item. 

Обнаружив попытку доступа чтения или записи индексатора, компилятор C# генерирует код вызова нужного метода.

## Модификаторы доступа свойств

Можно назначать различные модификаторы доступа на свойства.

```csharp
public class Sample
{
    private int _value;
    public int Value
    {
        get => _value;
        protected set => _value = value;
    }
}
```

Могут быть свойства только для чтения:

```csharp
public string Value
{
    get => _value;
}
```

Свойства только для записи:

```csharp
public string Value
{
    set => _value = value;
}
```

## Шаблон свойств

Шаблон свойств позволяет сопоставлять со свойствами объекта. Пример:

```csharp
internal sealed class Sample
{
    public int Value { get; set; }
    public Sample(int val)
    {
        Value = val;
    }
    public void SetValue(int mul)
    {
        Value = this switch
        {
            { Value: 1 } => 10,
            { Value: 2 } => Value + mul,
            { Value: 3 } => Value * mul,
            _ => Value++,
        };
    }
}
```

