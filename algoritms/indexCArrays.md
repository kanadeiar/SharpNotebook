# Массивы

## Массивы

Массив символов - это лишь список символов, имеющий имя. Массив чисел - это список целых чисел, имеющих имя. Вместо ссылки на каждый элемент - ссылка по общему имени массива и выделение нужного элемента в квадратных скобках. Массив может содержать элементы только одного типа.

Чтобы использовать массив, надо его объявить - присвоить ему имя, определить тип входящих в масив переменных и их количество. По этим сведениям компьютер вычислит, сколько места требуется для хранения массива, и выделит в памяти нужное число ячеек.

Объявление массива целых чисел:

    int i[25];

Объявление массива из символов сразу с его инициализацией:

    char name[5] = "Name"; //еще один элемент для нуль-символа

Можно объявлять массивы с резервом для добавления еще других элементов:

    char name[80] = "Name"; 

Объявление целочисленного массива и его инициализация меньшим кол-вом значений, чем его размер, остальные заполняются нулями:

    int val[5] = {10, 20, 30}; // {10, 20, 30, 0, 0}
    
    int val2[5] = {} // {0, 0, 0, 0, 0}

Нумерация всех элементов в массиве начинается с 0.

Объявление массива символов и инициализация его отдельными символами:

    char name[8] = {'A', 'B', 'C', 'D'};
    
Так как последний элемент не содержит нуль-символ, то этот массив содержит символы, а не строку текста.

Если же объявить массив символов этими равнозначными вариантами:

    char name[8] = {'N', 'a', 'm', 'e', '\0'}; //ручной нуль-символ
	char name[60] = "Name"; //автоматический нуль-символ

То получится строка текста. А ее можно обрабатывать как строку, выводить на печать gets() printf() с помощью %s.

При присвоении изначального значения или набора значений в момент объявления массива можно скобки где указывается размер массива оставлять пустыми - компилятор С сам посчитает:

	int ages[] = {5, 4, 23, 0};

Функция sizeof() возвращает количество байтов, которое зарезервировано на этот массив, а не количество элементов.

При объявлении и инициализации массива можно обнулить все его элементы:
```c
int ages[8] = {0};
char chName[8] = {0};
```
В массивах в элементы, которые не заполнены при инициализации обычно компилятор записывает нули.

Пример заполнения массива:
```c
int ages[5];
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Введите элемент №%d ", i);
    scanf_s(" %d", &ages[i]);
}
```

Пример вывода элементов из массива:
```c
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Элемент %d = %d\n", i + 1, *(ages + i)); //можно обойтись без квадратных скобок.
}
```
Нельзя использовать массив до инициализации его определенными значениями.

Случайный массив на С++:
```cpp
srand(time(NULL));
for (int i = 0; i < _countof(arr); i++)
    arr[i] = 10 + rand() % 80; // от 10 до 90
```

Пример заполнения элементов массива с консоли на С++:
```cpp
int arr[5] = {};
for (int i = 0; i < _countof(arr); i++)
{
    cout << "arr[" << i << "]=";
    cin >> arr[i];
 	getchar();
}
```

Пример форматированного вывода на С++:
```cpp
for (int i = 0; i < _countof(arr); i++)
    cout << setw(4) << arr[i] << ' '; //форматированный вывод на С++
```

Пример вывода элементов на С++:
```cpp
for (int i = 0; i < _countof(arr); i++)
    cout << setw(4) << arr[i] << ' '; //форматированный вывод на С++
```

Изменение массива в С++ через оператор & и цикл foreach:
```cpp
int arr[10] = {};
for (auto& el : arr)
    el = 33;
```
Символ & дает не только читать, но и изменять элемент в перечислении.


## Работа с массивами

Заполнять массивы данными можно первоначально присваиванием или в момент их объявления. Можно заполнять массивы данными, вводимиыми пользователями. Можно заполнять массивы из файлов, которые хранятся на диске.

Пример поиска элемента в массиве:
```c
int namID[10] = {313, 23, 33, 11, 21, 67, 78, 57, 65, 1};
printf_s("Введите номер для поиска:> ");
int numSearch;
int found = 0;
scanf_s(" %d", &numSearch);
for (int i = 0; i < _countof(namID); i++)
{
    if (*(namID + i) == numSearch)
    {
        found = 1;
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```
Дополнительный пример поиска элементов в массиве:
```c
int arr[10] = {};
int i = 10;
for (auto &element : arr)
    element = i++;
int X = 11; //искомый элемент
int nX = -1; //индекс найденного элемента
for (i = 0; i<_countof(arr); i++)
    if (arr[i] == X)
    {
        nX = i;
        break;
    }
if (nX >= 0)
    cout << "Найден элемент: " << arr[nX] << " индекс: " << nX << endl;
else
    cout << "Элемент не найден!" << endl;
```

Пример поиска максимального элемента в массиве:
```c
int arr[10] = {};
int i = 10;
for (auto &element : arr)
    element = i++;
int nMax = 0;
for (i = 0; i<_countof(arr); i++)
    if (arr[i] > arr[nMax])
        nMax = i;
cout << "arr[" << nMax << "]=" << arr[nMax] << endl;
```

Пример сортировки массива методом пузырика:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы до:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Элементы после:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
```
Пример сортировки динамического массива на С++ методом выбора:
```cpp
srand(time(NULL));
/////////////////////////////
int * arr = new int [30];
int * arr_last = &arr[29];
for (int * pI = arr; pI <= arr_last; pI++)
    *pI = rand() % 99;
/////////////////////////////
for (int * pI = arr; pI <= arr_last - 1; pI++)
{
    int * pMin = pI;
    for (int * pJ = pI + 1; pJ <= arr_last; pJ++)
    {
        if (*pJ < *pMin)
            pMin = pJ;
    }
    if (pMin != pI)
    {
        int temp = *pI;
        *pI = *pMin;
        *pMin = temp;
    }
}
/////////////////////////////
cout << "Массив:" << endl;
for (int * pI = arr; pI <= arr_last; pI++)
    cout << *pI << ' ';
delete [] arr;
```

Процесс поиска элементов в отсортированном массиве будет быстрее, так как не нужно просматривать все элементы массива, а только до определенного значения и далее прекращать поиск.

Пример поиска в отсортированном массиве:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}	
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Введите номер для поиска:> ");
int numSearch;
scanf_s(" %d", &numSearch);
int found = 0; //флаг найденного элемента
for (int i = 0; i < _countof(arr); i++)
{
    if (*(arr + i) == numSearch)
    {
        found = 1;
        break;
    }
    if (*(arr + i) > numSearch) //если далее элементы больше, то смысла искать нет
    {
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```

Реверс элементов массива:
```cpp
const int n = 10;
int arr[n] = {};
int i = 10;
for (auto &element : arr)
    element = i++;
int temp;
for (int i = 0; i < n/2; i++)
{
    temp = arr[i];
    arr[i] = arr[n - 1 - i];
    arr[n - 1 - i] = temp;
}
```


Случайная перестановка массива:

```cpp
srand(time(NULL));
const int n = 10;
int abas[n] = {};
int i = 1;
for (int * pI = abas; pI < abas + n; pI++) // заполнение начального массива
    *pI = i++;
int countbas = n;
int arr[n] = {}; //массив перестановленных элементов
for (int * pI = arr; pI < arr + n; pI++) //перестановка
{
    int * rnd = abas + rand() % countbas;
    *pI = *rnd;
    *rnd = *(abas + countbas - 1);
    countbas--;
}
cout << "Массив сформированный:";
for (int * pI = arr; pI < arr + n; pI++)
    cout << *pI << ' ';
```

## Двумерные массивы

Объявление массива двумерного и его заполнение пустыми значениями:
```cpp
const int N = 3, M = 4;
int arr[N][M] = {};
```
	
Заполнение массива:
```cpp
for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
        arr[i][j] = rand() % 61;
```

Вывод массива на экран:
```cpp
for (int i = 0; i < N; i++)
{
    for (int j = 0; j < M; j++)
        cout << setw(4) << arr[i][j] << ' ';
    cout << endl;
}
```
Перебор значений диагонали в квардатном двумерном массиве:
```cpp
puts("\nГлавная диагональ:");
for (int i = 0; i < N; i++)
    cout << setw(4) << arr[i][i] << ' ';
puts("\nПобочная диагональ:");
for (int i = 0; i < N; i++)
    cout << setw(4) << arr[i][N-i-1] << ' ';
```
Перебор всех элементов главной диагонали и под ней:
```cpp
puts("\nЭлементы под главной диагональю:");
for (int i = 0; i < N; i++)
{
    for (int j = 0; j <= i; j++)
        cout << setw(4) << arr[i][j] << ' ';
    cout << endl;
}
```
Работа указателями с массивом на С++:
```cpp
const int N = 4, M = 4;
int mtx[N][M];
int * mtx_end = mtx[N];
srand(time(NULL));
//////////////////////////////
for (int *pI = &mtx[0][0]; pI < mtx_end; pI++)
    *pI = rand() % 99;
puts("Матрица:");
for (int *pI = &mtx[0][0]; pI < mtx_end; pI++)
{
    cout << *pI << ' ';
    if ( (pI - &mtx[0][0] + 1) % N == 0 )
        cout << endl;
}
puts("\nМаксимальный элемент всей матрицы:");
int * pMax = &mtx[0][0];
for (int *pI = &mtx[0][0]; pI < mtx_end; pI++)
    if (*pI > *pMax)
        pMax = pI;
int iMax = (pMax - &mtx[0][0]) / N;
int jMax = (pMax - &mtx[0][0]) % N;
cout << "mtx[" << iMax << "," << jMax << "]=" << *pMax;
```

