# Динамика (динамические массивы)

## Динамические массивы


С помощью указателей можно получить доступ к динамической памяти программы. Динамическая память - это неиспользуемая память, которая может быть использована в любой момент времени программой на языке С.

Динамическое распределение памяти позволяет программе использовать столько памяти, сколько необходимо. Когда пользователю нужно будет больше памяти, программа может получить дополнительно выделенную память. Когда пользователь прекратит использование этого количества памяти, можно высвободить память, что сделает ее доступной для других заданий, которые нуждаются в ней.

Функция malloc() выделяет динамическую память, тогда как функция free() - ее освобождает. Для доступа к выделенной памяти используется указатель.

Пример выделения динамической памяти:
```c
int * arrs;
arrs = (int *) malloc(4 * sizeof(int));
```
Эта функция требует в атрибутах значения - количества байт памяти, которое необходимо выделить. С помощью функции sizeof() можно узнать наверняка, сколько байт в памяти занимает определенный тип переменной. Это команда выделения, или откладывания 10 смежных участков памяти, чтобы следующие функции не вторгались в эту выделенную память.

Функция malloc() всегда делает следующие два шага:

1. выделяет запрошенное количество байтов памяти и гарантирует, что никакая другая программ не может перезаписать содержимое выделенной памяти до тех пор, пока программ не высвободит выделенную память.

2. присваивает указатель первому занчению, хранящемуся в выделенной памяти.

Выделенные ячейки памяти можно использовать как массив - arrs[0], arrs[1] и так далее. Нужно помнить, что ячейки каждого выделенного набора будут соседствующими, они будут следовать одно за другим, как будто это целочисленный массив.

Функция malloc() всегда возвращает по умолчанию символьный указатель, его если нужно - привести к требуемому типу этим - (int *). 

Если вызов функции malloc() неудачно выполнится, то указатель будет указывать на 0. Поэтому можно так делать выделение памяти:
```c
int * arrs = (int *) malloc(4 * sizeof(int));
if (arrs == nullptr)
{
    puts("Недостаточно памяти!");
    exit(1);
}
puts("Память успешно выделена!");
```

Освобождение динамической памяти производится с помощью функции free(). Если попытаться воспользоватся указателем после примененеия функции free(), возникает риск перезаписать какие-либо данные, хранящиеся в памяти и вызвать ошибку. Память нужно обязательно освобождать через free(), иначе возникает утечка памяти.
```c
free(arrs);
```

Массив указателей может помочь выделить большое количество наборов динамической памяти. Пример объявления массива указателей:
```c
int * arrs[4];
```

Но это массив указателей, а не целых чисел. Каждый из элементов массива может указывать на отдельный набор ячеек выделенной динамической памяти. Можно выделять и освобождать данные, на которые ссылаюстя эти указатели.
```c
int * arrs[4];
int sizes[4];
for (int i = 0; i < _countof(arrs); i++)
{
    printf_s("Сколько чисел для %d-го списка?:> ", i);
    scanf_s(" %d", &sizes[i]);
    arrs[i] = (int *)malloc(sizes[i] * sizeof(int));
    for (int j = 0; j < sizes[i]; j++)
    {
        printf_s("Введите число №%d:> ", j);
        scanf_s(" %d", arrs[i] + j);
    }
}
puts("Введенный массив:");
for (int i = 0; i < _countof(arrs); i++)
{
    for (int j = 0; j < sizes[i]; j++)
    {
        printf_s("Список №%d число №%d = %d\n", i, j, *(arrs[i] + j));
    }
}
for (int i = 0; i < _countof(arrs); i++)
{
    free(arrs[i]);
}
```

Вначале функций объявлять только переменные-указатели и другие переменные. Записывайте данные в динамическую память только когда нужны данные, отличные от простых счетчиков цикла и сумм.

Не всегда следует полагаться на обычные массивы для хранения данных программы, иногда нужны данные только на непродолжительный период времени. Использование динамической памяти повышает эффективность использования ресурсов памяти.

Выделение памяти для динамического массива на языке С++:
```c
int * arr = new int [arr_size];
```
Освобождений этой памяти на языке С++:
```c
delete [] arr;
```
Пример на С++:
```c
const int arr_size = 20;
int * arr = new int [arr_size];
if (arr == nullptr)
    exit(1);
srand(time(nullptr));
for (int i = 0; i < arr_size; i++)
    *(arr + i) = rand() % 100 + 50;
int * pMax = arr;
cout << "Массив:" << endl;
for (int i = 0; i < arr_size; i++)
{
    if (*(arr + i) > *(pMax))
        pMax = arr + i;
    cout << *(arr + i) << ' ';
}
puts("\n");
cout << "Максимальный: " << *pMax << " номер: " << pMax - arr + 1 << endl;
delete [] arr;
```


## Расширение массивов в мамяти

Простое использование, которое лучше не использовать:
```c
int N = 0;
int * arr = (int * )malloc(0, sizeof(int));
int x = 10;
while (x != 0)
{
    N++;
    arr = (int*)realloc(arr, N * sizeof(int));
    arr[N-1] = x;
    x--;
}
```

Массив нужно увеличивать нужно не каждый раз, а через определенное количество введенных элементов.

Пример реализации:
```c
	int N = 0;
	int length = 10;
	int * arr = (int * )calloc(length, sizeof(int));
	int x = 10;
	while (x != 0)
	{
		N++;
		if (N>length)
		{
			length+=10;
			arr = (int*)realloc(arr, length * sizeof(int));
		}
		arr[N-1] = x;
		x--;
	}
```

В языке С++ лучше использовать тип vector, он сам будет расширять массив при добавлении в него нового элемента.


## Динамические двумерные массивы

Используются указатели - массив масиввов. Для выделения в памяти места под матрицу нужен массив указателей.

Динамическая матрица как массив указателей:
```c
#define N 10
#define M 10
typedef int * pInt; //указатель на переменную
pInt *arr; //массив указателей
```
Выделение и освобождение памяти под двумерный массив:
```c
duarr = (pInt *)calloc(N, sizeof(pInt));
duarr[0] = (int *)calloc(N*M, sizeof(int)); //выделение памяти сразу на весь массив
for (int i = 1; i < N; i++)
    duarr[i] = duarr[i-1] + M; //расстановка указателей
/*   */
free(duarr[0]);
free(duarr);
////////////////////////////////////////////////
duarr = (pInt *)calloc(N, sizeof(pInt));
for (int i = 0; i < N; i++)
    duarr[i] = (int *)calloc(M, sizeof(int)); //выделение памяти отдельно на каждую строку
/*    */
for (int i = 0; i < N; i++)
    free(duarr[i]);
free(duarr);
```
Заполнение и чтение массива:
```c
for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
    {
        duarr[i][j] = (i+1)*(j+1);
    }
for (int i = 0; i < N; i++)
{
    for (int j = 0; j < M; j++)
    {
        printf("%3d ", duarr[i][j]);
    }
    printf("\n");
}
```
Тоже самое на языке С++:
Выделение и освобождение памяти под двумерный массив:
```cpp
duarr = new pInt[N];
duarr[0] = new int[N*M];
for (int i = 1; i < N; i++)
duarr[i] = duarr[i-1] + M; //расстановка указателей
/**/
delete [] duarr[0];
delete [] duarr;
////////////////////////////////
duarr = new pInt[N];
for (int i = 0; i < N; i++)
    duarr[i] = new int [M];
/**/
for (int i = 0; i < N; i++)
    delete [] duarr[i];
delete [] duarr;
```
В языке С++ можно работать с двумерным массивом использую тип vector. Вектор, состоящий из элементов - векторов:
```cpp
#define N 10
#define M 10
typedef vector<int> vint;
vector<vint> varr;
```
Работа с массивом:
```cpp
varr.resize( N ); //количество
for (int i = 0; i < N; i++)
    varr[i].resize( M );
for (int i = 0; i < M; i++)
    for (int j = 0; j < N; j++)
        varr[i][j] = (i+1)*(j+1);
for (int i = 0; i < N; i++)
{
    for (int j = 0; j < M; j++)
    {
        printf("%3d ", varr[i][j]);
    }
    printf("\n");
}
```
