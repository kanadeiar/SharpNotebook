# Указатели (массивы, массивы + указатели)

## Массивы

Массив символов - это лишь список символов, имеющий имя. Массив чисел - это список целых чисел, имеющих имя. Вместо ссылки на каждый элемент - ссылка по общему имени массива и выделение нужного элемента в квадратных скобках. Массив может содержать элементы только одного типа.

Чтобы использовать массив, надо его объявить - присвоить ему имя, определить тип входящих в масив переменных и их количество. По этим сведениям компьютер вычислит, сколько места требуется для хранения массива, и выделит в памяти нужное число ячеек.

Объявление массива целых чисел:

    int i[25];

Объявление массива из символов сразу с его инициализацией:

    char name[5] = "Name"; //еще один элемент для нуль-символа

Можно объявлять массивы с резервом для добавления еще других элементов:

    char name[80] = "Name"; 

Объявление целочисленного массива и его инициализация меньшим кол-вом значений, чем его размер, остальные заполняются нулями:

    int val[5] = {10, 20, 30}; // {10, 20, 30, 0, 0}
    
    int val2[5] = {} // {0, 0, 0, 0, 0}

Нумерация всех элементов в массиве начинается с 0.

Объявление массива символов и инициализация его отдельными символами:

    char name[8] = {'A', 'B', 'C', 'D'};
    
Так как последний элемент не содержит нуль-символ, то этот массив содержит символы, а не строку текста.

Если же объявить массив символов этими равнозначными вариантами:

    char name[8] = {'N', 'a', 'm', 'e', '\0'}; //ручной нуль-символ
	char name[60] = "Name"; //автоматический нуль-символ

То получится строка текста. А ее можно обрабатывать как строку, выводить на печать gets() printf() с помощью %s.

При присвоении изначального значения или набора значений в момент объявления массива можно скобки где указывается размер массива оставлять пустыми - компилятор С сам посчитает:

	int ages[] = {5, 4, 23, 0};

Функция sizeof() возвращает количество байтов, которое зарезервировано на этот массив, а не количество элементов.

При объявлении и инициализации массива можно обнулить все его элементы:
```c
int ages[8] = {0};
char chName[8] = {0};
```
В массивах в элементы, которые не заполнены при инициализации обычно компилятор записывает нули.

Пример заполнения массива:
```c
int ages[5];
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Введите элемент №%d ", i);
    scanf_s(" %d", &ages[i]);
}
```


Пример вывода элементов из массива:
```c
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Элемент %d = %d\n", i + 1, *(ages + i)); //можно обойтись без квадратных скобок.
}
```
Нельзя использовать массив до инициализации его определенными значениями.

Случайный массив на С++:
```cpp
srand(time(NULL));
int arr[5] = {};
for (int i = 0; i < _countof(arr); i++)
    arr[i] = 10 + rand() % 80; // от 10 до 90
for (int i = 0; i < _countof(arr); i++)
    cout << setw(4) << arr[i] << ' '; //форматированный вывод на С++
```

Пример заполнения элементов массива с консоли на С++:
```cpp
int arr[5] = {};
for (int i = 0; i < _countof(arr); i++)
{
    cout << "arr[" << i << "]=";
    cin >> arr[i];
 	getchar();
}
for (int i = 0; i < _countof(arr); i++)
    cout << setw(4) << arr[i] << ' '; //форматированный вывод на С++
```

Пример вывода элементов на С++:
```cpp
for (int i = 0; i < _countof(arr); i++)
    cout << setw(4) << arr[i] << ' '; //форматированный вывод на С++
```
Изменение массива в С++ через оператор & и цикл foreach:
```cpp
int arr[10] = {};
for (auto& el : arr)
    el = 33;
```
Символ & дает не только читать, но и изменять элемент в перечислении.


## Работа с массивами

Заполнять массивы данными можно первоначально присваиванием или в момент их объявления. Можно заполнять массивы данными, вводимиыми пользователями. Можно заполнять массивы из файлов, которые хранятся на диске.

Пример поиска элемента в массиве:
```c
int namID[10] = {313, 23, 33, 11, 21, 67, 78, 57, 65, 1};
printf_s("Введите номер для поиска:> ");
int numSearch;
int found = 0;
scanf_s(" %d", &numSearch);
for (int i = 0; i < _countof(namID); i++)
{
    if (*(namID + i) == numSearch)
    {
        found = 1;
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```

Пример сортировки массива методом пузырика:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы до:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Элементы после:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
```
Пример сортировки динамического массива на С++ методом выбора:
```cpp
srand(time(NULL));
/////////////////////////////
int * arr = new int [30];
int * arr_last = &arr[29];
for (int * pI = arr; pI <= arr_last; pI++)
    *pI = rand() % 99;
/////////////////////////////
for (int * pI = arr; pI <= arr_last - 1; pI++)
{
    int * pMin = pI;
    for (int * pJ = pI + 1; pJ <= arr_last; pJ++)
    {
        if (*pJ < *pMin)
            pMin = pJ;
    }
    if (pMin != pI)
    {
        int temp = *pI;
        *pI = *pMin;
        *pMin = temp;
    }
}
/////////////////////////////
cout << "Массив:" << endl;
for (int * pI = arr; pI <= arr_last; pI++)
    cout << *pI << ' ';
delete [] arr;
```

Процесс поиска элементов в отсортированном массиве будет быстрее, так как не нужно просматривать все элементы массива, а только до определенного значения и далее прекращать поиск.

Пример поиска в отсортированном массиве:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}	
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Введите номер для поиска:> ");
int numSearch;
scanf_s(" %d", &numSearch);
int found = 0; //флаг найденного элемента
for (int i = 0; i < _countof(arr); i++)
{
    if (*(arr + i) == numSearch)
    {
        found = 1;
        break;
    }
    if (*(arr + i) > numSearch) //если далее элементы больше, то смысла искать нет
    {
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```

## Двумерные массивы

Объявление массива двумерного и его заполнение пустыми значениями:
```cpp
const int N = 3, M = 4;
int arr[N][M] = {};
```
	
Заполнение массива:
```cpp
for (int i = 0; i < N; i++)
    for (int j = 0; j < M; j++)
        arr[i][j] = rand() % 61;
```

Вывод массива на экран:
```cpp
for (int i = 0; i < N; i++)
{
    for (int j = 0; j < M; j++)
        cout << setw(4) << arr[i][j] << ' ';
    cout << endl;
}
```
Перебор значений диагонали в квардатном двумерном массиве:
```cpp
puts("\nГлавная диагональ:");
for (int i = 0; i < N; i++)
    cout << setw(4) << arr[i][i] << ' ';
puts("\nПобочная диагональ:");
for (int i = 0; i < N; i++)
    cout << setw(4) << arr[i][N-i-1] << ' ';
```
Перебор всех элементов главной диагонали и под ней:
```cpp
puts("\nЭлементы под главной диагональю:");
for (int i = 0; i < N; i++)
{
    for (int j = 0; j <= i; j++)
        cout << setw(4) << arr[i][j] << ' ';
    cout << endl;
}
```
Работа указателями с массивом на С++:
```cpp
const int N = 4, M = 4;
int mtx[N][M];
int * mtx_end = mtx[N];
srand(time(NULL));
//////////////////////////////
for (int *pI = &mtx[0][0]; pI < mtx_end; pI++)
    *pI = rand() % 99;
puts("Матрица:");
for (int *pI = &mtx[0][0]; pI < mtx_end; pI++)
{
    cout << *pI << ' ';
    if ( (pI - &mtx[0][0] + 1) % N == 0 )
        cout << endl;
}
puts("\nМаксимальный элемент всей матрицы:");
int * pMax = &mtx[0][0];
for (int *pI = &mtx[0][0]; pI < mtx_end; pI++)
    if (*pI > *pMax)
        pMax = pI;
int iMax = (pMax - &mtx[0][0]) / N;
int jMax = (pMax - &mtx[0][0]) % N;
cout << "mtx[" << iMax << "," << jMax << "]=" << *pMax;
```


## Указатели

Переменные-указатели предназначены для хранения адресов расположения других переменных. Объявление переменных-указателей. 

Операторы для работы с указателями:

& - операция взятия адреса

* - операция разыменования

Пример объявления переменных:
```c
int num;
float value;
int * pNum;
float * pValue;
```

Указатели - они типизированы, предусмотрены в языке С символьные указатели, указатели целых, длинных целых чисел и т.д. Переменная-указатель хранит адрес другой переменной. Для получения адреса переменной нужно использовать оператор взятия адреса &. 

Пример работы с указателем:
```c
int num = 22;
int * pNum;
pNum = &num; //примвоение значения адреса переменной num указателю pNum
//теперь в pNum содержится адрес переменной num
```

Оператор разыменования * позволяет работать со значением самой переменной, делая разыменвание указателя. 

Два способа задания переменной:

num = 25;

*pNum = 25;

Пример работы с этим указателем:
```c
int num;
int * pNum = &num;
*pNum = 22;
printf_s("Чиcло: %d\n", num);
printf_s("Адрес переменной: %p\n", &num);
printf_s("Число: %d\n", *pNum);
printf_s("Значение в указателе: %p\n", pNum);
```

## Массивы = указатели

На самом деле массив - особый вид указателя. Используя нотацию указателей и нотацию массивов можно сохранять списки символьных строк и ссылаться на них как на элементы любого другого типа.

Имя массива - указатель на первый элемент этого массива. Имена массивов это константы-указатели. 

Пример:
```c
int arr[5] = {1, 2, 3, 4, 5};
```
К элементам такого массива можно обращаться как через квадратные скобки по индексной нотации, так и через указатель.

Значение указателя-массива изменить нельзя, он похож на фиксированную переменную-указатель, значение которой заблокировано компилятором.

Получить элемент массива можно двумя способами, втрой - круче:
```c
int arr[5] = {1, 2, 3, 4, 5};
printf_s("Значение первого элемента: %d\n", arr[0]);
printf_s("Значение через указатель: %d", *arr + 0);
```
Разные типы данных разных массивов занимают разное количество памяти в памяти, как правило больше, чем 1 байт. Если к указателю прибавить какое-либо число, то компилятор автоматически прибавит к нему 1 размер типа массива - то есть несколько байт, которые и занимает этот тип данных.

Две строки следующие одинаково выглядят в памяти компьютера, однако одна - константа-указатель, а другая - переменная-указатель. Новое значение в первую переменную можно записать только через функцию strcopy() - посимвольную копию строки, а в переменную-указатель - просто изменяя значение этой переменой (которое является адресом).
```c
char name[] = "Name";
const char* pName = "Name";
strcpy_s(name, "Wiwi");
pName = "Wiwi";
```
Язык С распределяет строковые литералы программы по участкам памяти, а затем заменяет их в программе на адреса участков памяти.

Нужно быть пределльно внимательным и не сохранять в первоначальную строку, на которую ссылался указатель, новую строку, длиннее старой.

Пример:
```c
char min2[2];
char * pMin2 = min2;
gets_s(pMin2, _countof(min2));
const char * name1 = "And";
```

Пользователь может ввести строку, длинна которой превышает длинну старой строки, как и другие функции, такие как scanf() strcpy() strcat(), не знают что в качестве аргумента им передается символьный указатель. Эти функции записывают новую строку поверх старой, уже хранящейся в памяти компьютера. Если длинна новой строки больше старой, то произойдет перезапись других данных.

Перед записью новой строки поверх старой нужно зарезервировать достаточно символов для символьного массива.

Пример:
```c
char input[128];
char * pInput = input; //или char * pInput = input[0]; - это одно и то-же
gets_s(pInput, _countof(input));
fgets(pInput, _countof(input), stdin); //безопасная версия
```
Всегда нужно оставлять свободное место для нуль-символа, завершающего строку. При имсользовании безопасных функций, если ползователь введет строку символов, превышающую указанную в аргументах функции, то только указанное число запишеться, а остальное - отбросится.

>stdin нужно указывать в качестве третьего аргумента, чтобы функция обращалась за вводом данных к клавиатуре.

Если нужно большое количество указателей, то нужно создавать массив из указателей.

Пример резервирования массива из нескольких указателей:
```c
int * arr1[32]; //массив целочисленных указателей
char * arr2[32]; //массив символьных указателей
```

Пример использования такого массива:
```c
const char * names[6] = {"Zinx", "Nik", "Kavorado", "Momowo", "Xix", "Anno"};
for (int outer = 0; outer < _countof(names) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(names); inner++)
    {
        if (names[inner] < names[outer])
        {
            const char * temp = names[inner]; //обмен адресами указателей, а не значениями
            names[inner] = names[outer];
            names[outer] = temp;
        }
    }
}
for (int i=0; i < _countof(names); i++)
{
    printf_s("Имя: %s\n", *(names + i));
}
```
