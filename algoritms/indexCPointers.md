# Указатели (массивы + указатели)


## Указатели

Переменные-указатели предназначены для хранения адресов расположения других переменных. Объявление переменных-указателей. 

Операторы для работы с указателями:

& - операция взятия адреса

* - операция разыменования

Пример объявления переменных:
```c
int num;
float value;
int * pNum;
float * pValue;
```

Указатели - они типизированы, предусмотрены в языке С символьные указатели, указатели целых, длинных целых чисел и т.д. Переменная-указатель хранит адрес другой переменной. Для получения адреса переменной нужно использовать оператор взятия адреса &. 

Пример работы с указателем:
```c
int num = 22;
int * pNum;
pNum = &num; //примвоение значения адреса переменной num указателю pNum
//теперь в pNum содержится адрес переменной num
```

Оператор разыменования * позволяет работать со значением самой переменной, делая разыменвание указателя. 

Два способа задания переменной:

num = 25;

*pNum = 25;

Пример работы с этим указателем:
```c
int num;
int * pNum = &num;
*pNum = 22;
printf_s("Чиcло: %d\n", num);
printf_s("Адрес переменной: %p\n", &num);
printf_s("Число: %d\n", *pNum);
printf_s("Значение в указателе: %p\n", pNum);
```

## Массивы = указатели

На самом деле массив - особый вид указателя. Используя нотацию указателей и нотацию массивов можно сохранять списки символьных строк и ссылаться на них как на элементы любого другого типа.

Имя массива - указатель на первый элемент этого массива. Имена массивов это константы-указатели. 

Пример:
```c
int arr[5] = {1, 2, 3, 4, 5};
```
К элементам такого массива можно обращаться как через квадратные скобки по индексной нотации, так и через указатель.

Значение указателя-массива изменить нельзя, он похож на фиксированную переменную-указатель, значение которой заблокировано компилятором.

Получить элемент массива можно двумя способами, втрой - круче:
```c
int arr[5] = {1, 2, 3, 4, 5};
printf_s("Значение первого элемента: %d\n", arr[0]);
printf_s("Значение через указатель: %d", *arr + 0);
```
Разные типы данных разных массивов занимают разное количество памяти в памяти, как правило больше, чем 1 байт. Если к указателю прибавить какое-либо число, то компилятор автоматически прибавит к нему 1 размер типа массива - то есть несколько байт, которые и занимает этот тип данных.

Две строки следующие одинаково выглядят в памяти компьютера, однако одна - константа-указатель, а другая - переменная-указатель. Новое значение в первую переменную можно записать только через функцию strcopy() - посимвольную копию строки, а в переменную-указатель - просто изменяя значение этой переменой (которое является адресом).
```c
char name[] = "Name";
const char* pName = "Name";
strcpy_s(name, "Wiwi");
pName = "Wiwi";
```
Язык С распределяет строковые литералы программы по участкам памяти, а затем заменяет их в программе на адреса участков памяти.

Нужно быть пределльно внимательным и не сохранять в первоначальную строку, на которую ссылался указатель, новую строку, длиннее старой.

Пример:
```c
char min2[2];
char * pMin2 = min2;
gets_s(pMin2, _countof(min2));
const char * name1 = "And";
```

Пользователь может ввести строку, длинна которой превышает длинну старой строки, как и другие функции, такие как scanf() strcpy() strcat(), не знают что в качестве аргумента им передается символьный указатель. Эти функции записывают новую строку поверх старой, уже хранящейся в памяти компьютера. Если длинна новой строки больше старой, то произойдет перезапись других данных.

Перед записью новой строки поверх старой нужно зарезервировать достаточно символов для символьного массива.

Пример:
```c
char input[128];
char * pInput = input; //или char * pInput = input[0]; - это одно и то-же
gets_s(pInput, _countof(input));
fgets(pInput, _countof(input), stdin); //безопасная версия
```
Всегда нужно оставлять свободное место для нуль-символа, завершающего строку. При имсользовании безопасных функций, если ползователь введет строку символов, превышающую указанную в аргументах функции, то только указанное число запишеться, а остальное - отбросится.

>stdin нужно указывать в качестве третьего аргумента, чтобы функция обращалась за вводом данных к клавиатуре.

Если нужно большое количество указателей, то нужно создавать массив из указателей.

Пример резервирования массива из нескольких указателей:
```c
int * arr1[32]; //массив целочисленных указателей
char * arr2[32]; //массив символьных указателей
```

Пример использования такого массива:
```c
const char * names[6] = {"Zinx", "Nik", "Kavorado", "Momowo", "Xix", "Anno"};
for (int outer = 0; outer < _countof(names) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(names); inner++)
    {
        if (names[inner] < names[outer])
        {
            const char * temp = names[inner]; //обмен адресами указателей, а не значениями
            names[inner] = names[outer];
            names[outer] = temp;
        }
    }
}
for (int i=0; i < _countof(names); i++)
{
    printf_s("Имя: %s\n", *(names + i));
}
```
