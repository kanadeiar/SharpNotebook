# Структурирование (динамическая память и структуры)

## Динамическая память

С помощью указателей можно получить доступ к динамической памяти программы. Динамическая память - это неиспользуемая память, которая может быть использована в любой момент времени программой на языке С.

Динамическое распределение памяти позволяет программе использовать столько памяти, сколько необходимо. Когда пользователю нужно будет больше памяти, программа может получить дополнительно выделенную память. Когда пользователь прекратит использование этого количества памяти, можно высвободить память, что сделает ее доступной для других заданий, которые нуждаются в ней.

Функция malloc() выделяет динамическую память, тогда как функция free() - ее освобождает. Для доступа к выделенной памяти используется указатель.

Пример выделения динамической памяти:
```c
int * arrs;
arrs = (int *) malloc(4 * sizeof(int));
```
Эта функция требует в атрибутах значения - количества байт памяти, которое необходимо выделить. С помощью функции sizeof() можно узнать наверняка, сколько байт в памяти занимает определенный тип переменной. Это команда выделения, или откладывания 10 смежных участков памяти, чтобы следующие функции не вторгались в эту выделенную память.

Функция malloc() всегда делает следующие два шага:

1. выделяет запрошенное количество байтов памяти и гарантирует, что никакая другая программ не может перезаписать содержимое выделенной памяти до тех пор, пока программ не высвободит выделенную память.

2. присваивает указатель первому занчению, хранящемуся в выделенной памяти.

Выделенные ячейки памяти можно использовать как массив - arrs[0], arrs[1] и так далее. Нужно помнить, что ячейки каждого выделенного набора будут соседствующими, они будут следовать одно за другим, как будто это целочисленный массив.

Функция malloc() всегда возвращает по умолчанию символьный указатель, его если нужно - привести к требуемому типу этим - (int *). 

Если вызов функции malloc() неудачно выполнится, то указатель будет указывать на 0. Поэтому можно так делать выделение памяти:
```c
int * arrs = (int *) malloc(4 * sizeof(int));
if (arrs == nullptr)
{
    puts("Недостаточно памяти!");
    exit(1);
}
puts("Память успешно выделена!");
```

Освобождение динамической памяти производится с помощью функции free(). Если попытаться воспользоватся указателем после примененеия функции free(), возникает риск перезаписать какие-либо данные, хранящиеся в памяти и вызвать ошибку. Память нужно обязательно освобождать через free(), иначе возникает утечка памяти.
```c
free(arrs);
```

Массив указателей может помочь выделить большое количество наборов динамической памяти. Пример объявления массива указателей:
```c
int * arrs[4];
```

Но это массив указателей, а не целых чисел. Каждый из элементов массива может указывать на отдельный набор ячеек выделенной динамической памяти. Можно выделять и освобождать данные, на которые ссылаюстя эти указатели.
```c
int * arrs[4];
int sizes[4];
for (int i = 0; i < _countof(arrs); i++)
{
    printf_s("Сколько чисел для %d-го списка?:> ", i);
    scanf_s(" %d", &sizes[i]);
    arrs[i] = (int *)malloc(sizes[i] * sizeof(int));
    for (int j = 0; j < sizes[i]; j++)
    {
        printf_s("Введите число №%d:> ", j);
        scanf_s(" %d", arrs[i] + j);
    }
}
puts("Введенный массив:");
for (int i = 0; i < _countof(arrs); i++)
{
    for (int j = 0; j < sizes[i]; j++)
    {
        printf_s("Список №%d число №%d = %d\n", i, j, *(arrs[i] + j));
    }
}
for (int i = 0; i < _countof(arrs); i++)
{
    free(arrs[i]);
}
```

Вначале функций объявлять только переменные-указатели и другие переменные. Записывайте данные в динамическую память только когда нужны данные, отличные от простых счетчиков цикла и сумм.

Не всегда следует полагаться на обычные массивы для хранения данных программы, иногда нужны данные только на непродолжительный период времени. Использование динамической памяти повышает эффективность использования ресурсов памяти.

## Структуры

Структура в языке С - это средство, с помощью которого можно группировать данные разных типов и получать доступ к каждой отдельной части этих данных, называемых членами. Если есть много тиких элементов данных, то нужно создавать массивы структур.

Объявление структуры:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
```
Объявление структуры определяет макет, или внешний вид структурв. После объявления формата структуры можно начать объявлять переменные. Объявление члена - это объявление переменных встроенных типов данных.

Объявление структуры рассказывают компилятору, как выглядит структура прежде, чем переменные этого типа данных можно объявить. 

Пример объявления структуры и массива из структурных переменных:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
Sample items[10]; //массив из 10 элементов
```
Пример объявления указателя на структуру и резервирование участка динамической памяти для хранения структуры и привязывание указателя к этому участку памяти:
```c
Sample * item1; //Указатель на структуру
item1 = (Sample *)malloc(sizeof(Sample));
```

Запись и чтение данных в структурную переменную производится через оператор точку:

имяСтруктурнойПеременной.имяЧлена

Запись и чтение данных в структуру в динамической памяти через ссылку, то нужно через оператор структурного указателя ->.

имяУказателя->имяЧлена

Пример работы со структурами в массиве переменных:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
Sample samples[3];
for (int i=0; i < _countof(samples); i++)
{
    samples[i].id = i + 1;
    strcpy_s(samples[i].name, "Test");
    samples[i].cost = (i + 1) * 100;
}
puts("Коллекция:");
for (Sample el : samples)
{
    printf_s("%s номер %d стоимость %d\n", el.name, el.id, el.cost);
}
for (int i=0; i < _countof(samples); i++)
{
    free(samples[i]); //не забывать освобождать память!!!
}
```
Пример работы со структурой, размещаемой в динамической памяти:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
Sample * p_samples[3];
for (int i = 0; i < _countof(p_samples); i++)
{
    p_samples[i] = (Sample *)malloc(sizeof(Sample));
    p_samples[i]->id = i + 1;
    strcpy_s(p_samples[i]->name, "Test");
    p_samples[i]->cost = (i + 1) * 100;
}
puts("Коллекция из указателей:");
for (Sample * el : p_samples)
{
    printf_s("имя: %s номер: %d цена: %d\n", el->name, el->id, el->cost);
}
for (int i = 0; i < _countof(p_samples); i++)
{
    free(p_samples[i]);
}
```
