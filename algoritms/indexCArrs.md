# Массивы

## Массивы

Массив символов - это лишь список символов, имеющий имя. Массив чисел - это список целых чисел, имеющих имя. Вместо ссылки на каждый элемент - ссылка по общему имени массива и выделение нужного элемента в квадратных скобках. Массив может содержать элементы только одного типа.

Объявление массива целых чисел:

    int i[25];

Объявление массива из символов сразу с его инициализацией:

    char name[5] = "Name"; //еще один элемент для нуль-символа

Можно объявлять массивы с резервом для добавления еще других элементов:

    char name[80] = "Name"; 

Объявление целочисленного массива и его инициализация меньшим кол-вом значений, чем его размер:

    int val[8] = {10, 20, 30, 40};

Нумерация всех элементов в массиве начинается с 0.

Объявление массива символов и инициализация его отдельными символами:

    char name[8] = {'A', 'B', 'C', 'D'};
    
Так как последний элемент не содержит нуль-символ, то этот массив содержит символы, а не строку текста.

Если же объявить массив символов этими равнозначными вариантами:

    char name[8] = {'N', 'a', 'm', 'e', '\0'}; //ручной нуль-символ
	char name[60] = "Name"; //автоматический нуль-символ

То получится строка текста. А ее можно обрабатывать как строку, выводить на печать gets() printf() с помощью %s.

При присвоении изначального значения или набора значений в момент объявления массива можно скобки где указывается размер массива оставлять пустыми - компилятор С сам посчитает:

	int ages[] = {5, 4, 23, 0};

Функция sizeof() возвращает количество байтов, которое зарезервировано на этот массив, а не количество элементов.

При объявлении и инициализации массива можно обнулить все его элементы:
```c
int ages[8] = {0};
char chName[8] = {0};
```
В массивах в элементы, которые не заполнены при инициализации обычно компилятор записывает нули.

Пример заполнения массива:
```c
int ages[5];
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Введите элемент №%d ", i);
    scanf_s(" %d", &ages[i]);
}
```

Пример вывода элементов из массива:
```c
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Элемент %d = %d\n", i + 1, *(ages + i)); //можно обойтись без квадратных скобок.
}
```
Нельзя использовать массив до инициализации его определенными значениями.

## Работа с массивами

Заполнять массивы данными можно первоначально присваиванием или в момент их объявления. Можно заполнять массивы данными, вводимиыми пользователями. Можно заполнять массивы из файлов, которые хранятся на диске.

Пример поиска элемента в массиве:
```c
int namID[10] = {313, 23, 33, 11, 21, 67, 78, 57, 65, 1};
printf_s("Введите номер для поиска:> ");
int numSearch;
int found = 0;
scanf_s(" %d", &numSearch);
for (int i = 0; i < _countof(namID); i++)
{
    if (*(namID + i) == numSearch)
    {
        found = 1;
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```

Пример сортировки массива методом пузырика:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы до:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Элементы после:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
```

Процесс поиска элементов в отсортированном массиве будет быстрее, так как не нужно просматривать все элементы массива, а только до определенного значения и далее прекращать поиск.

Пример поиска в отсортированном массиве:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}	
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Введите номер для поиска:> ");
int numSearch;
scanf_s(" %d", &numSearch);
int found = 0; //флаг найденного элемента
for (int i = 0; i < _countof(arr); i++)
{
    if (*(arr + i) == numSearch)
    {
        found = 1;
        break;
    }
    if (*(arr + i) > numSearch) //если далее элементы больше, то смысла искать нет
    {
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```
