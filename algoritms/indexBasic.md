# Основы C

## Русификация ввода-вывода в консоли
```c
#include <windows.h>
SetConsoleCP(1251);
SetConsoleOutputCP(1251);
//возможный вариант
setlocale(LC_ALL, "russian");
getchar();
return 0;
```
## Базовая функция

В каждой программе на C обязательно должно присутствовать функция main(). От команды функцию отличают круглые скобки сразу после имени. Имена практически всех втроенных функций С должны содержать буквы нижнего регистра. Язык С придирчив к регистрам. Следует всегда функцию main() ставить первой.
```c
#include <windows.h>
#include <stdio.h>
int main(int argc, const char* argv[])
{
	SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
	printf_s("Привет, ");
	printf_s("Всем!\n");	
	getchar();
	return 0;
}
```

## Подключение файлов к программе

Два идентичных формата:

#include <имя файла>

#include "имя файла"

Это директива команды слияния файлов. Выражение include заменится содержимым файла, указанным после него. Она вставляет содержимого одного файла в другой. Рядом с компилятором существует хранилище файлов, входящих в комплект поставки компилятора, для их включения нужно использовать угловые скобки. Подключаемый файл xxx.h - заголовоыный.

При написании собственных загловочных файлов нужно использовать вторую форму директивы препроцессора, с именем, заключенным в кавычки. При этом компилятор сначало ищет нужный файл в той папке, в которой сохраненна программ, и если не находит, то продолжает поиск в директории, выбранной по умолчанию.

Заголовочный файл это файл с расширением .h. Это дает компилятору понять, что создан именно заголовочный файл. Чтобы задействовать заголовочный файл в основном коде, нужно его подключить:

#include "CppConsoleApplication1Learn.h"








# Консоль

## Базовая программа с выводом
```c
#include <windows.h>
#include <stdio.h>
int main(int argc, const char* argv[])
{
	SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
	printf_s("Язык программирования %c \n", 'C');
	printf_s("Число %d\n", 23);
	printf_s("Это %.1f успеха\n", 99.3333);
	getchar();
	return 0;
}
``` 

Каждый раз, когда нужно преждевременно завершить выполнение программы, нужно воспользоватся функцией exit(). Значение, указанное в скобках передается ОС. Пример:
```c
exit(0);
``` 

## Комментарии
Правило программирования - комментировать код.

//Комментарий
/* Комментарий 
многострочный */
Для повышения удобочитаемости программ исползовать отступы и разрывы.


## Вывод текста на экран

Назначение функции printf() - вывод данных на экран консоли. Ее формат:

printf(строка_формата [, данные])

Строка формата заключается в двойные кавычки как группа символов.
```c
printf_s("Язык программирования %d \n", 9);
``` 
Управляющие последовательности:
```c
\n - новая строка
\a - звуковое оповещение
\b - возврат каретки на один символ
\t - табуляция
\\ - вывод символа обратный слеш
\' - вывод симовла апострофа
\" - вывод символа двойных кавычек
``` 
Пример использования символов этих:
```c
printf_s("Колонка1\tКолонка2\tКолонка3\n");
printf_s("Писк компьютера\a\n");
printf_s("Эти\bо симолы \\\" \'<- и этот\n");
``` 
Символы преобразования используются для вывода переменных на экран с помощью printf().

Символы преобразования:
```c
%d - целое число
%f - число с плавающей точкой
%c - символ
%s - строка
``` 
Пример использования:
```c
printf_s("%s %d %.1f %c\n", "Сумма чисел", 55, -4.233, 'X'); //Сумма чисел 55 -4.2 X
``` 

## Получение данных от пользователя

Функция scanf() позволяет принимать данные, вводимые с клавиатуры. 

scanf(строка_формата [, данные])

Когда код программы достигает функции этой, выполнение программы приостанавливатся и компьютер ожидает, пока пользователь введет необходимые данные. Переменные перечисленные в функции scanf() получают введенные пользователем значения. Выполнение функции завершается, когда пользователь нажимает клавишу Enter.

Пример выражений на языке С:
```c
char first;
int age;
int favorite_num;
printf_s("С какой буквы начинается Ваша фамилия? ");
scanf_s(" %c", &first);
printf_s("Сколько вам лет? ");
scanf_s(" %d", &age);
printf_s("Какое любимое число? ");
scanf_s(" %d", &favorite_num);
printf_s("\nВаша фамилия начинается на %c и вам %d лет\n", first, age);
printf_s("Ваше любимое число это %d\n", favorite_num);	
``` 
Перед каждым символом %c %d нужно ставить пробел, это для лучшей работы их (!?!?).

Пример еще различных запросов у пользователя в т.ч. числа с плавающей точкой:
```c
float price = 0.0;
char nach[24];
int mounth, day, year;
printf_s("Введите стоимость кефира в магазине (формат $XX.XX):> ");
scanf_s(" $%f", &price);
printf_s("Любимая начинка?> ");
scanf_s(" %s", nach, _countof(nach));
printf_s("Введите седняшнее число (формат XX/XX/XX):> ");
scanf_s(" %d/%d/%d", &day, &mounth, &year);
printf_s("Сегодня %d.%d.%d нужно съесть пирог с начинкой \"%s\" и запить кефиром за $%f", day, mounth, year, nach, price);
``` 
Еще пример:
```c
char name[64];
if (scanf_s(" %s", name, sizeof(name)) == 1)
    printf("Your name is %s\n", name);
``` 

## Специальные функции ввода-вывода

Существуют спец функции ввода одного символа с клавиатуры getchar(), а функция putchar() - выводит 1 символ на экран. Управление ходом выполнения программы не возвращается, пока пользователь не нажмет кнопку Enter. На самом деле функция getchar() принимает ввод в буфер, пока пользователь не нажмет кнопку Enter, после этого происходит освобождение буфера посимвольно. Можно воспользоватся клавишей Backspace чтобы в этой функции удалить ввод. Факт нажатия клавиши Enter сохраняется в буфере, нужно его удалять вручную.

Пример вывода строки текста:
```c
char msg[] = "Проба текста";
for (int i=0; i<strlen(msg); i++)
{
    putchar(msg[i]);
}
putchar('\n');
``` 
Пример ввода текста и его вывода:
```c
char msg[10];
printf_s("Введите 10 символов и нажмите Enter\n");
int len = 0;
for (int i=0; i < strlen(msg); i++)
{
    msg[i] = getchar();
    if (msg[i] == '\n')
    {
        len = i - 1;
        break;
    }
}
putchar('\n');
for (int i=0; i <= len; i++)
{
    putchar(msg[i]);
}
putchar('\n');
``` 
Пример обработки факта нажатия клавижи Enter после ввода символа:
```c
printf_s("Введите 1 одну букву:");
char letter1 = getchar();
getchar();
printf_s("Введите 2 одну букву:");
char letter2 = getchar();
getchar();
printf_s("Буква = %c & %c", letter1, letter2);
``` 

Специальная функция ввода символов getch() поможет избавится от лишней записи Enter. Эта функция безбуферная, она не ждет от пользователя нажатия клавиши Enter. Невозможность удаления ввода Backspace. Вывод - с помощью putch() так как первая функция по умолчанию не выводит введенные символы.

Пример:
```c
printf_s("Введите 1 одну букву:");
char ch1 = _getwch();
_putwch(ch1);
putchar('\n');
printf_s("Буква = %c", ch1);
``` 





# Переменные

## Переменные

Литеральные данные - это данные которые не меняются при выполнении программы. Переменные - меняются.
    
Наиболее часто используемые типы данных:
```c
char - символьные данные ('X' '#')
int - целочисленные данные (-32, 5, от от -2147483648 до 2147183647)
float - числа с плавающей точкой (35.3 -34.43)
double - сверхмалое или сверхбольше значение с плавающей точкой
``` 
Имя переменной может состоять из символов в количестве от 1 до 31. Имя должно начинаться с буквы латинсокго алфавита, после него другие буквы лат.алфавита, цифры и знакип подчеркивания.

Пример использования данных в переменных:

переменная = данные;
```c
char answer = 'B';
int quant = 14, one = 4;
int rez = quant * one;
``` 


## Символы

Любой символ, заключенный в апостровы:
```c
'A' 'a' '4' '%' '!' '+' '=' ']'
```
Все символы заключаются в апострофы (') - одинарные кавычки. 

Группа из нескольких символов - это строка, она в двойных кавчыках:
```c
"Изучать язык весело"
```

## Числа
Числа без дробной части - целые числа:
```c
10 2344 -222 -434
```
>Запись числа в других системах счисления: 053-восьмеричная, 0x45-шестнадцатеричная 
    
Числа с дробным разделителем - вещественные числа с плавающей точкой
```c
10.4 2344.4343 -222.33 -0.33
```

## Константы

Для определения констант используется директива #define, она аналогична литералам. Константы, определенные с помощью define, не являются переменными. Пример:
```c
#define AGELIMIT 21
#define MYNAME "Name"
``` 
Для констант в языке С нужно использовать заглавные буквы. Это позволяет быстро определять, где константы, а где - переменные.

## Присваивание значений переменным

Если нужно прибавить 1 к значению переменной, то можно воспользоватся оператором составного сложения +=.

lossCount += 1;

sales *= 1.25;

amt /= 2;

days %= 3;

quality -= 5;

В языке С можно использовать операторы инкремента и декремента, которые работают только с одним аргументом.

Прибавление значению еденицы:

count++;

Вычитанию 1 из значения:

count--;

Можно написать и так:

++count++;

Если оператор находится слева, то это преинкремент или преддекремента, а после - постинктемента или постдекремента.


## Приведение типа переменной

Пример приведения типа перемнной в языке С:

(float)age;

Пример использования:

salaryBon = salary * (float)age / 150.0; //переменная age временно приводится к типу для вычисления

Пример для выражения:

value = (float)(num - 10 * yrsService);

## Размер типов данных

Для определения количества участков памяти, которые потребуются для хранения данных всех типов, используются функции sizeof(). В языке С большинство типов данных используют 4 байта для хранения целочисленных значений. Для точного определения сколько в памяти занимают целые числа и числа с правающей точкой, можно использовать функцию sizeof().

int i = sizeof(int);

int f = sizeof(float);

Пример использования:
```c
char names[] = "Name Nikolay";
int i = 7;
printf_s("Размер i %d\n", sizeof(i));
printf_s("Размер names %d\n", sizeof(names));
``` 

## Строки

В языке С нет строковых переменных, но есть способ сохранить строковые данные. 

В конце каждой строки в языке С добавляется специальный нуль-символ. Нексолько значений его: нуль-символ, бинарный нуль, ASII 0, \0.

Пример сохранения строки в памяти:

[С][л][о][в][о][\0] - реально строка занимает 6 байт

Длинна строки - это всегда количество символов в строке, не включая нуль-символ.

Каждый раз, когда встречается константа в двойных кавычках нужно представлять завершающий нуль-симвл на конце строки, записываемый в память компьютера.

Символьные массивы позволяют хранить в памяти компьютера строки текста. Пример:
```c
char sampl[10]; //это символьный массив
``` 
Если в него требуется сохранить слово на обычном языке, то в последний символ записывается нуль-символ. Нужно резервировать достаточное количество места для хранения самой длинной строки из тех, что потенциально потребуется плюс символ завершения строки.

Пример:
```c
char sampl[8] = "Test"; //это символьный массив
``` 
В памяти: [T][e][s][t][\0][?][?][?] начальный индекс - 0, конечный - 7

Вывод в консоль массива - через %s.

При одновременном объявлении и инициализации массива указывать длинну массива не обязательно.
```c
char sampl[8] = "Testing";
char sampl1[] = "Testing";
char sampllong[30] = "Testing"; //резервирование места для более длинного чего то
``` 
Инициилизировать так символьные массивы можно, но нельзя присваивать им новое знчение. Записать строку в массив символьный можно только в момент объявления массива. Если далее нужно присвоить какое либо значение новое - нужно посимвольно изменять строку, либо воспользоваться функцией strcopy().

Пример использования:
```c
strcpy_s(sampllong, "New string"); //автоматическое добавление нуль-символа в конец строки
``` 

Функция strlen() возвращает длинну строки, которая находится в аргументах функции.

## Функции работы со строками

Функия isapha() возвращает значение ИСТИНА (1), если символ в скобках - символ алфавита от a до z (или от A до Z) и ЛОЖЬ (0) если значение в скобках другой символ.

Пример применения:
```c
char ch = 'a';
if (isalpha(ch))
{
    printf_s("Введена буква\n");
}
``` 
Функция isdigit() возвращает ИСТИНА (1) если символ в скобках - число от 0 до 9.

Пример применения:
```c
char ch = '1';
if (isalpha(ch))
{
    printf_s("Введена цифра\n");
}
``` 
Функции isupper() и islower() информируют о том, содержит ли переменная символ верхнего или нижнего регистра.

Пример примененеия:
```c
char ch = 'A';
if (isupper(ch))
{
    printf_s("Буква верхнего регистра\n");
}
``` 

Функции toupper() и tolower() возвращают переданный им аргумент с исзмененным регистром. Первая функция возвращает аргумент, наход в скобках в виде символа верхнего регистра, а вторая - нижнего.

Пример:
```c
char answer = 'y';
if (toupper(answer) == 'Y')
{
    printf_s("да\n");
}
else
{
    printf_s("нет\n");
}
``` 

Функция strcat() делает конкатенацию строк. Она берет одну строку и прибавляет, то есть подставляет эту строку в конец другой строки. При этом заботится о символе конца строки \0. Нужно точно быть уверенным в том, что в первую строку поместится вторая строка.

Пример:
```c
char first[32] = "Толя";
char last[32] = " Пашин";
strcat_s(first, last);
printf_s("Имя - %s", first); //Толя Пашин
``` 

Функции puts() и gets() поедоставляют простой способо ввода и печати строк текста. Первая выводит строку текста на экран, а вторая - принимает строку текста с клаиватуры.
Функция puts() автоматически вставляет разрыв строки в конец всех распечатываемых строк. А функция gets() автоматически конвертирует нажатие клавиши Enter в нуль символ \0. Эту функцию можно использовать если нужно запросить у пользователя строки, которые содержат пробелы.

Пример использования:
```c
char fullStr[128];
char surnameName[64];
puts("Введите ваше имя фамилию:");
gets_s(surnameName);
char city[32];
puts("Город:");
gets_s(city);
puts("Ваши фамилия и имя:");
strcpy_s(fullStr, surnameName);
strcat_s(fullStr, " - годод ");
strcat_s(fullStr, city);
puts(fullStr);
``` 





# Арифметика

## Математические операции

Обычное математическое выражение:

newVal = oldVal - factor;

newVal = maxim / 1.3 * 100.0;

Значение присваивается левой переменной.

Выражение можно поместить в функцию printf().
```c
printf_s("Пример вычисления %d этот", age + 3);
``` 
Отсечение дробной части:

int vari = 10 / 3;

Остаток от деления (операция деление по модулю):

int var2 = 10 % 3;

Порядок выполнения операций в языке C:
```c
Уровень - Оператор - Ассоциативность
1 - ()скобки, []элемент из массива и .ссылка на член структуры - слева направо
2 - -знак отриц.числа, ++инкремент, --декремент, &взятие адреса, *разыменование указателя, sizeof(), !логическое НЕ - справа навлево 
3 - *умножение, /деление, %деление по модулю - слева направо
4 - +сложение, -вычитание - слева направо
5 - <меньше, <=меньше или равно, >больше, >=больше или равно - слева направо
6 - ==равно, !=меньше - слева направо
7 - && логическое И - слева направо
8 - || логическое ИЛИ - слева направо
9 - ?: оператор условия - справа налево
10 - =, *=, /=, %=, |=, -= операторы присваивания - справа налево
11 - , оператор-запятая - слева направо
```
С помощью скобок можно установить нужный порядок выполения оперторов.

Результатом всех выражений С являются значения, а это значит что результатом присваивания одной переменной другой будет значение другой переменной. Можно делать так:

a = b = c = 99;

и так:

a = 2 * (b * 2);

## Математические функции

Функции floor() и ceil() можно назвать функцие пола и потолка, они снижают или возносят нецелые числа к ближайшему целому значению.

Пример:
```c
float val1 = floor(18.5); //18.0
float val2 = floor(-18.5); //-19.0
float val3 = ceil(18.5); //19.0
float val4 = ceil(-18.5); //-18.0
```

Функция fabs() возвращает абсолютное значение числа с плавающей точкой. 

Пример:
```c
printf_s("Абсолютное знач. числа 23.4 - %.1f.\n", fabs(23.4));
printf_s("Абсолютное знач. числа -23.4 - %.1f.\n", fabs(-23.4));
```

Функция возведения в степень pow() и функция квадратного корня из числа sqrt().

Пример:
```c
printf_s("10 в 3 степени: %.1f\n", pow(10.0, 3.0));
printf_s("Квадратный корень из 64: %.1f\n", sqrt(64));
```

Тригонометрические функции языка С:
```c
Функция             Описание
cos(x)              Косинус угла х
sin(x)              Синус угла х
tan(x)              Тангенс угла х
acos(x)             Арккосинус угла х
asin(x)             Арксинус угла х
atan(x)             Арктангенс угла х
```
Конвертация из градусов в радианы:

radians = degrees * (3.14159 / 180.0);

Логарифмические функции языка С:
```c
Функция             Описание
exp(x)              Значение экспоненты, основания натуркльного логарифма, возведенного в степень, заданную выражением x (e ^ x).
log(x)              Натуральный логарифм аргумента х. Записывается как ln(x).
log10(x)            Логарифм по основанию 10 аргумента х. Записыватеся как lg(x).
```

Примеры использования функций:
```c
printf_s("Квадратный корень из 36: %.1f\n", sqrt(36.0));
printf_s("4 в 3-ей степени: %.1f\n", pow(4.0, 3.0));
printf_s("Косинус угла 60 градусов: %.3f\n", cos((60*(3.14159/180))));
printf_s("е в степени 2: %.3f\n", exp(2));
printf_s("Натуральный логарифм 5: %.3f\n", log(5));
```

Функция rand() позволяет генерировать в языке С случайные числа. Она возвращает случайное число в диапазоне от 0 до 32767. Для уменьшения дипазона случайных чисел можно воспользоватся оператором деления по модулю %. Например от 1 до 3: (rand() % 2) + 1.

Сначало нужно генератору случайных чисел установить базу, исходя из которой функция rand() будет отсчитывать случайные числа. В аргумент нужно передать точное значение времени дня, тогда это будет случайное значение.

Пример использования случайных чисел:
```c
srand(time(NULL));
int dice1 = (rand() % 5) + 1;
printf_s("Значение игральной кости: %d", dice1);
```










# Ветвления

## Ветвления

Рациональные операторы языка С:
```c
Оператор сравнения  Описание
==                  Равно
!=                  Не равно
>                   Больше
<                   Меньше
>=                  Больше или равно
<=                  Меньше или равно
```
Результат сравнения ИСТИНА соответствует 1, результат сравнения ЛОЖЬ - 0.

Оператор ветвления if

if (условие) { блок из одного или нескольких выражений на языке C; }

if (условие) { блок из одного или нескольких выражений на языке С; }

else { блок из одного или нескольких выражений на языке С; }

Логические операторы:
```c
&&          И
||          ИЛИ
!           НЕ
```
Пример:
```c
if ((age >= 21) && (age <= 65))
{
    doIt();
}
```
В логических операторах оператор && предшествует оператору ||.

Условный оператор языка С требует три аргумента. Синтаксис:

отношение ? истинноеВыражение : ложноеВыражение;

Пример использования:
```c
int age = 30;
(age >= 21) ? (age = 21) : (age += 30);
```
Этот можно заменить более коротким:
```c
age = (age >= 21) ? 21 : age + 30;
```
Оператор можно использовать в функции printf():
```c
printf_s("Возраст %sслишком большой", (age < 90) ? "не " : "");
```

В языке С существует выражение switch, которое заменяет множественные конструкции if-else-if. Синтаксис:
```c
switch (выражение)
{
    case (выражение1): {одно или несколько выражений С;}
    case (выражение2): {одно или несколько выражений С;}
    case (выражение3): {одно или несколько выражений С;}
    default: {одно или несколько выражений С;}
}
```
Выражения case определяют ход выполнения программы в зависимости от значения переменной в выражении.

Нужно обязательно вставлять выражения break для того, чтобы не выполнились несколько блоков кода сразу, а только один блок case.

Пример:
```c
int choice = 1;
switch (choice)
{
case (1): printf_s("Первый блок кода");
    break;
case (2): printf_s("Второй блок кода");
    break;
default: printf_s("Неправильный выбор");
    break;
}
```
>Для повышения эффективности можно изменять порядок следования блоков case, наиболее возможные варианты переместить к началу.

Оператору switch можно передать либо целочисленную, либо символьную переменную, нельзя передавать переменную типа float и double.


## Цикличность

Цикл - это блок кода, выполнение которого повторяется определенное количество раз. 

Первый вариант цикла while, пример:
```c
while (условие)
{
    блок из одного или нескольких выражений;
}
```
Первым проверяется условие, затем выполняется блок кода в теле цикла, а после этого снова проверяется условие, цикл работает пока условие - ИСТИНА. Блок из одного или нескольких выражений принято называть телом цикла.

Пример:
```c
int i = 0;
while (i < 10)
{
    printf_s("Значение слишком мало.\n");
    i++;
}
```

Второй вариант цикла do...while, пример: 
```c
do
{
    блок из одного или нескольких выражений;
}
while (условие)
```
Тело такого цикла должно быть выполнено хотя бы один раз, после этого проверяется условие. Цикл повторяется пока условие - ИСТИНА.

Пример:
```c
char choise;
do
{
    printf_s("Продолжаеть цикл? (y/n)");		
    scanf_s(" %c", &choise);
}
while (choise != 'n' && choise != 'N');
```

Третий вариант цикла - это цикл for, пример:
```c
for (начальноеВыражение; контрольеВыражение; счетчик)
{
    блок из одного или нескольких выражений;
}
```
В этом цикле при входе в цикл for выполняется начальноеВыражение, это выполняется только один раз. после этого проверяется истинность контрольногоВыражения, если истина - то тело цикла выполняется. После его выполнения выполняется тело цикла счетчик, после этого снова проверяется тело цикла.

Пример:
```c
for (int i = 10; i > 0; i--)
{
    printf_s("%d\n", i);
}
```

В языке С существуют выражение break и continue позволяют контролировать ход выполнения  циклов. 

Пример break - преждевременное прекращение цикла:
```c
for (int i = 0; i < 10; i++)
{
    printf_s("%d\n", i);
    if (i == 4)
        break;
}
```

Пример continue - команда заново начать выполнение цикла:
```c
for (int i = 0; i < 10; i++)
{
    if (i < 5)
        continue;
    printf_s("%d\n", i);
}
```




# Указатели

## Массивы

Массив символов - это лишь список символов, имеющий имя. Массив чисел - это список целых чисел, имеющих имя. Вместо ссылки на каждый элемент - ссылка по общему имени массива и выделение нужного элемента в квадратных скобках. Массив может содержать элементы только одного типа.

Объявление массива целых чисел:

    int i[25];

Объявление массива из символов сразу с его инициализацией:

    char name[5] = "Name"; //еще один элемент для нуль-символа

Можно объявлять массивы с резервом для добавления еще других элементов:

    char name[80] = "Name"; 

Объявление целочисленного массива и его инициализация меньшим кол-вом значений, чем его размер:

    int val[8] = {10, 20, 30, 40};

Нумерация всех элементов в массиве начинается с 0.

Объявление массива символов и инициализация его отдельными символами:

    char name[8] = {'A', 'B', 'C', 'D'};
    
Так как последний элемент не содержит нуль-символ, то этот массив содержит символы, а не строку текста.

Если же объявить массив символов этими равнозначными вариантами:

    char name[8] = {'N', 'a', 'm', 'e', '\0'}; //ручной нуль-символ
	char name[60] = "Name"; //автоматический нуль-символ

То получится строка текста. А ее можно обрабатывать как строку, выводить на печать gets() printf() с помощью %s.

При присвоении изначального значения или набора значений в момент объявления массива можно скобки где указывается размер массива оставлять пустыми - компилятор С сам посчитает:

	int ages[] = {5, 4, 23, 0};

Функция sizeof() возвращает количество байтов, которое зарезервировано на этот массив, а не количество элементов.

При объявлении и инициализации массива можно обнулить все его элементы:
```c
int ages[8] = {0};
char chName[8] = {0};
```
В массивах в элементы, которые не заполнены при инициализации обычно компилятор записывает нули.

Пример заполнения массива:
```c
int ages[5];
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Введите элемент №%d ", i);
    scanf_s(" %d", &ages[i]);
}
```

Пример вывода элементов из массива:
```c
for (int i = 0; i < _countof(ages); i++)
{
    printf_s("Элемент %d = %d\n", i + 1, *(ages + i)); //можно обойтись без квадратных скобок.
}
```
Нельзя использовать массив до инициализации его определенными значениями.

## Работа с массивами

Заполнять массивы данными можно первоначально присваиванием или в момент их объявления. Можно заполнять массивы данными, вводимиыми пользователями. Можно заполнять массивы из файлов, которые хранятся на диске.

Пример поиска элемента в массиве:
```c
int namID[10] = {313, 23, 33, 11, 21, 67, 78, 57, 65, 1};
printf_s("Введите номер для поиска:> ");
int numSearch;
int found = 0;
scanf_s(" %d", &numSearch);
for (int i = 0; i < _countof(namID); i++)
{
    if (*(namID + i) == numSearch)
    {
        found = 1;
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```

Пример сортировки массива методом пузырика:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы до:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Элементы после:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}
```

Процесс поиска элементов в отсортированном массиве будет быстрее, так как не нужно просматривать все элементы массива, а только до определенного значения и далее прекращать поиск.

Пример поиска в отсортированном массиве:
```c
srand(time(NULL));
int arr[10];
for (int i = 0; i < _countof(arr); i++)
    arr[i] = rand() % 100;
printf_s("Элементы:\n");
for (int element : arr)
{
    printf_s("%d \n", element);
}	
for (int outer = 0; outer < _countof(arr) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(arr); inner++)
    {
        if (arr[inner] < arr[outer])
        {
            int temp = arr[inner];
            arr[inner] = arr[outer];
            arr[outer] = temp;
        }
    }
}
printf_s("Введите номер для поиска:> ");
int numSearch;
scanf_s(" %d", &numSearch);
int found = 0; //флаг найденного элемента
for (int i = 0; i < _countof(arr); i++)
{
    if (*(arr + i) == numSearch)
    {
        found = 1;
        break;
    }
    if (*(arr + i) > numSearch) //если далее элементы больше, то смысла искать нет
    {
        break;
    }
}
if (found)
{
    printf_s("Такой элемент есть в массиве!");
}
else
{
    printf_s("Такого элемента нет в массиве!");
}
```

## Указатели

Переменные-указатели предназначены для хранения адресов расположения других переменных. Объявление переменных-указателей. 

Операторы для работы с указателями:

& - операция взятия адреса

* - операция разыменования

Пример объявления переменных:
```c
int num;
float value;
int * pNum;
float * pValue;
```

Указатели - они типизированы, предусмотрены в языке С символьные указатели, указатели целых, длинных целых чисел и т.д. Переменная-указатель хранит адрес другой переменной. Для получения адреса переменной нужно использовать оператор взятия адреса &. 

Пример работы с указателем:
```c
int num = 22;
int * pNum;
pNum = &num; //примвоение значения адреса переменной num указателю pNum
//теперь в pNum содержится адрес переменной num
```

Оператор разыменования * позволяет работать со значением самой переменной, делая разыменвание указателя. 

Два способа задания переменной:

num = 25;

*pNum = 25;

Пример работы с этим указателем:
```c
int num;
int * pNum = &num;
*pNum = 22;
printf_s("Чиcло: %d\n", num);
printf_s("Адрес переменной: %p\n", &num);
printf_s("Число: %d\n", *pNum);
printf_s("Значение в указателе: %p\n", pNum);
```

## Массивы = указатели

На самом деле массив - особый вид указателя. Используя нотацию указателей и нотацию массивов можно сохранять списки символьных строк и ссылаться на них как на элементы любого другого типа.

Имя массива - указатель на первый элемент этого массива. Имена массивов это константы-указатели. 

Пример:
```c
int arr[5] = {1, 2, 3, 4, 5};
```
К элементам такого массива можно обращаться как через квадратные скобки по индексной нотации, так и через указатель.

Значение указателя-массива изменить нельзя, он похож на фиксированную переменную-указатель, значение которой заблокировано компилятором.

Получить элемент массива можно двумя способами, втрой - круче:
```c
int arr[5] = {1, 2, 3, 4, 5};
printf_s("Значение первого элемента: %d\n", arr[0]);
printf_s("Значение через указатель: %d", *arr + 0);
```
Разные типы данных разных массивов занимают разное количество памяти в памяти, как правило больше, чем 1 байт. Если к указателю прибавить какое-либо число, то компилятор автоматически прибавит к нему 1 размер типа массива - то есть несколько байт, которые и занимает этот тип данных.

Две строки следующие одинаково выглядят в памяти компьютера, однако одна - константа-указатель, а другая - переменная-указатель. Новое значение в первую переменную можно записать только через функцию strcopy() - посимвольную копию строки, а в переменную-указатель - просто изменяя значение этой переменой (которое является адресом).
```c
char name[] = "Name";
const char* pName = "Name";
strcpy_s(name, "Wiwi");
pName = "Wiwi";
```
Язык С распределяет строковые литералы программы по участкам памяти, а затем заменяет их в программе на адреса участков памяти.

Нужно быть пределльно внимательным и не сохранять в первоначальную строку, на которую ссылался указатель, новую строку, длиннее старой.

Пример:
```c
char min2[2];
char * pMin2 = min2;
gets_s(pMin2, _countof(min2));
const char * name1 = "And";
```

Пользователь может ввести строку, длинна которой превышает длинну старой строки, как и другие функции, такие как scanf() strcpy() strcat(), не знают что в качестве аргумента им передается символьный указатель. Эти функции записывают новую строку поверх старой, уже хранящейся в памяти компьютера. Если длинна новой строки больше старой, то произойдет перезапись других данных.

Перед записью новой строки поверх старой нужно зарезервировать достаточно символов для символьного массива.

Пример:
```c
char input[128];
char * pInput = input; //или char * pInput = input[0]; - это одно и то-же
gets_s(pInput, _countof(input));
fgets(pInput, _countof(input), stdin); //безопасная версия
```
Всегда нужно оставлять свободное место для нуль-символа, завершающего строку. При имсользовании безопасных функций, если ползователь введет строку символов, превышающую указанную в аргументах функции, то только указанное число запишеться, а остальное - отбросится.

>stdin нужно указывать в качестве третьего аргумента, чтобы функция обращалась за вводом данных к клавиатуре.

Если нужно большое количество указателей, то нужно создавать массив из указателей.

Пример резервирования массива из нескольких указателей:
```c
int * arr1[32]; //массив целочисленных указателей
char * arr2[32]; //массив символьных указателей
```

Пример использования такого массива:
```c
const char * names[6] = {"Zinx", "Nik", "Kavorado", "Momowo", "Xix", "Anno"};
for (int outer = 0; outer < _countof(names) - 1; outer++)
{
    for (int inner = outer + 1; inner < _countof(names); inner++)
    {
        if (names[inner] < names[outer])
        {
            const char * temp = names[inner]; //обмен адресами указателей, а не значениями
            names[inner] = names[outer];
            names[outer] = temp;
        }
    }
}
for (int i=0; i < _countof(names); i++)
{
    printf_s("Имя: %s\n", *(names + i));
}
```

## Динамическая память

С помощью указателей можно получить доступ к динамической памяти программы. Динамическая память - это неиспользуемая память, которая может быть использована в любой момент времени программой на языке С.

Динамическое распределение памяти позволяет программе использовать столько памяти, сколько необходимо. Когда пользователю нужно будет больше памяти, программа может получить дополнительно выделенную память. Когда пользователь прекратит использование этого количества памяти, можно высвободить память, что сделает ее доступной для других заданий, которые нуждаются в ней.

Функция malloc() выделяет динамическую память, тогда как функция free() - ее освобождает. Для доступа к выделенной памяти используется указатель.

Пример выделения динамической памяти:
```c
int * arrs;
arrs = (int *) malloc(4 * sizeof(int));
```
Эта функция требует в атрибутах значения - количества байт памяти, которое необходимо выделить. С помощью функции sizeof() можно узнать наверняка, сколько байт в памяти занимает определенный тип переменной. Это команда выделения, или откладывания 10 смежных участков памяти, чтобы следующие функции не вторгались в эту выделенную память.

Функция malloc() всегда делает следующие два шага:

1. выделяет запрошенное количество байтов памяти и гарантирует, что никакая другая программ не может перезаписать содержимое выделенной памяти до тех пор, пока программ не высвободит выделенную память.

2. присваивает указатель первому занчению, хранящемуся в выделенной памяти.

Выделенные ячейки памяти можно использовать как массив - arrs[0], arrs[1] и так далее. Нужно помнить, что ячейки каждого выделенного набора будут соседствующими, они будут следовать одно за другим, как будто это целочисленный массив.

Функция malloc() всегда возвращает по умолчанию символьный указатель, его если нужно - привести к требуемому типу этим - (int *). 

Если вызов функции malloc() неудачно выполнится, то указатель будет указывать на 0. Поэтому можно так делать выделение памяти:
```c
int * arrs = (int *) malloc(4 * sizeof(int));
if (arrs == nullptr)
{
    puts("Недостаточно памяти!");
    exit(1);
}
puts("Память успешно выделена!");
```

Освобождение динамической памяти производится с помощью функции free(). Если попытаться воспользоватся указателем после примененеия функции free(), возникает риск перезаписать какие-либо данные, хранящиеся в памяти и вызвать ошибку. Память нужно обязательно освобождать через free(), иначе возникает утечка памяти.
```c
free(arrs);
```

Массив указателей может помочь выделить большое количество наборов динамической памяти. Пример объявления массива указателей:
```c
int * arrs[4];
```

Но это массив указателей, а не целых чисел. Каждый из элементов массива может указывать на отдельный набор ячеек выделенной динамической памяти. Можно выделять и освобождать данные, на которые ссылаюстя эти указатели.
```c
int * arrs[4];
int sizes[4];
for (int i = 0; i < _countof(arrs); i++)
{
    printf_s("Сколько чисел для %d-го списка?:> ", i);
    scanf_s(" %d", &sizes[i]);
    arrs[i] = (int *)malloc(sizes[i] * sizeof(int));
    for (int j = 0; j < sizes[i]; j++)
    {
        printf_s("Введите число №%d:> ", j);
        scanf_s(" %d", arrs[i] + j);
    }
}
puts("Введенный массив:");
for (int i = 0; i < _countof(arrs); i++)
{
    for (int j = 0; j < sizes[i]; j++)
    {
        printf_s("Список №%d число №%d = %d\n", i, j, *(arrs[i] + j));
    }
}
for (int i = 0; i < _countof(arrs); i++)
{
    free(arrs[i]);
}
```

Вначале функций объявлять только переменные-указатели и другие переменные. Записывайте данные в динамическую память только когда нужны данные, отличные от простых счетчиков цикла и сумм.

Не всегда следует полагаться на обычные массивы для хранения данных программы, иногда нужны данные только на непродолжительный период времени. Использование динамической памяти повышает эффективность использования ресурсов памяти.

## Структуры

Структура в языке С - это средство, с помощью которого можно группировать данные разных типов и получать доступ к каждой отдельной части этих данных, называемых членами. Если есть много тиких элементов данных, то нужно создавать массивы структур.

Объявление структуры:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
```
Объявление структуры определяет макет, или внешний вид структурв. После объявления формата структуры можно начать объявлять переменные. Объявление члена - это объявление переменных встроенных типов данных.

Объявление структуры рассказывают компилятору, как выглядит структура прежде, чем переменные этого типа данных можно объявить. 

Пример объявления структуры и массива из структурных переменных:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
Sample items[10]; //массив из 10 элементов
```
Пример объявления указателя на структуру и резервирование участка динамической памяти для хранения структуры и привязывание указателя к этому участку памяти:
```c
Sample * item1; //Указатель на структуру
item1 = (Sample *)malloc(sizeof(Sample));
```

Запись и чтение данных в структурную переменную производится через оператор точку:

имяСтруктурнойПеременной.имяЧлена

Запись и чтение данных в структуру в динамической памяти через ссылку, то нужно через оператор структурного указателя ->.

имяУказателя->имяЧлена

Пример работы со структурами в массиве переменных:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
Sample samples[3];
for (int i=0; i < _countof(samples); i++)
{
    samples[i].id = i + 1;
    strcpy_s(samples[i].name, "Test");
    samples[i].cost = (i + 1) * 100;
}
puts("Коллекция:");
for (Sample el : samples)
{
    printf_s("%s номер %d стоимость %d\n", el.name, el.id, el.cost);
}
for (int i=0; i < _countof(samples); i++)
{
    free(samples[i]); //не забывать освобождать память!!!
}
```
Пример работы со структурой, размещаемой в динамической памяти:
```c
struct Sample
{
    char name[33];
    int id;
    int cost;
};
Sample * p_samples[3];
for (int i = 0; i < _countof(p_samples); i++)
{
    p_samples[i] = (Sample *)malloc(sizeof(Sample));
    p_samples[i]->id = i + 1;
    strcpy_s(p_samples[i]->name, "Test");
    p_samples[i]->cost = (i + 1) * 100;
}
puts("Коллекция из указателей:");
for (Sample * el : p_samples)
{
    printf_s("имя: %s номер: %d цена: %d\n", el->name, el->id, el->cost);
}
for (int i = 0; i < _countof(p_samples); i++)
{
    free(p_samples[i]);
}
```

