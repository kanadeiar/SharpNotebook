# Анонимные типы

Механизм анонимных типов в C# позволяет автоматически объявить новый тип без названия, содержащих набор свойств, каким-либо образом связанных друг с другом. Значения в анонимных типах неизменны. Экземпляры анонимного типа не должны выходить за пределы метода. В прототипе метода не может содержаться параметр анонимного типа, так как задать анонимный тип невозможно. Метод не может возвращать ссылку на анонимный тип.

Пример определения нового объекта и класса и вывод свойств в консоль:

```csharp
var test = new { One = 1, Two = 2 };
Console.WriteLine($"One = {test.One} Two = {test.Two}");
```

Компилятор C# определяет тип каждого выражения, создает закрытые поля этих типов, для каждого поля создает открытые поля доступа, переопределяет методы Equals, GetHashCode, ToString объекта и создает код этих методов.

Компилятор C# может выводить имена на основании имен переменных.

```csharp
var dt = DateTime.Now;
var test = new { dt.Year };
Console.WriteLine($"Year = {test.Year}");
```

Если компилятор видит определение множества анонимных типов с одинаковой структурой, то он создает одно определение для анонимного типа и множество экземпляров этого типа.

Анонимные типы поддерживают создание из них массивов.

```csharp
var arr = new[] 
{
    new { Value = 1 },
    new { Value = 2 },
    new { Value = 3 },
};
foreach (var item in arr)
{
    Console.WriteLine($"{item.Value}");
};
```

## Кортежи

Кортежи предназначены для того, чтоб быть легковесным механизмом передачи данных.

Относительно кортежей важно отметить два момента:

- поля не подвергаются проверке достоверности;

- определять собственные методы нельзя.

Определено несколько обобщенных кортежных типов унаследованных от System.Object, которые отличаются количеством обобщенных параметров. 

```csharp
[Serializable]
public class Tuple<T1> 
{
    private T1 m_Item1;
    public Tuple(T1 item1) { m_Item1 = item1; }
    public T1 Item { get { return m_Item1; } }
}
```

Значения в кортежах неизменны. Позволяют использовать CompareTo, Equals, GetHashCode, ToString, Size. 

Пример использования:

```csharp
private static Tuple<int, int> Swap(int a, int b)
{
    return new Tuple<int, int>(b, a);
}
// использование
var vals = Swap(1, 2);
System.Console.WriteLine($"{vals.Item1} {vals.Item2}");
```

В кортежах можно именовать свойства.

```csharp
(string FirstLetter, int TheNumber, string SecondLetter) valuesWithNames = ("a", 5, "c");
var valuesWithNames2 = (FirstLetter: "a", TheNumber: 5, SecondLetter: "c");
```

Cпециальные имена полей существуют только на этапе компиляции и не доступны при инспектировании кортежа во время выполнения с использованием рефлексии.

В C# имеется возможность выводить имена переменных в кортежан на основе передаваемых данных в кортеж изначально.

В кортежах имеется свойство эквивалентности (==) и неэквивалентности (!=) между собой. При проверке на неэквивалентность операции сравнения будут выполнять неявные преобразования типов данных внутри кортежей, включая сравнение допускающих и не допускающих null кортежей и/или свойств.

### Деконструирование кортежей

Деконструирование является термином, описывающим отделение свойств кортежа друг от друга с целью применения по одному. Деконструировать можно классы и структуры.

Пример определения деконструктора:

```csharp
struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    public (int XPos, int YPos) Deconstruct() => (X, Y);
}
```

Пример использования в обычном методе:

```csharp
var p1 = new Point { X = 1, Y = 2 };
var values = p1.Deconstruct();
Console.WriteLine($"X is: {values.XPos}");
Console.WriteLine($"Y is: {values.YPos}");
```

Пример использования деконструктора в выражении switch:

```csharp
var rez = p1.Deconstruct() switch
{
    (0, 0) => "начало",
    var (х, у) when х > 0 && у > 0 => "один",
    var (х, у) when х < 0 && у > 0 => "два",
    (_, _) => "отсутствие",
};
```

Можно упростить деконструктор, если установить в параметрах его модификаторы out:

```csharp
public void Deconstruct(out int XPos, out int YPos) => (XPos, YPos) = (X, Y);
// измененный пример:
var rez = p1 switch
{
...
};
```
