# Делегаты

## Объявление и использование делегатов

В CLR механизм функций обратного вызова поддерживается при помощи делегатов. Обеспечивают последовательный вызов нескольких методов, а также вызов как статических, так и экземплярных методов.

Делегат - это обертка для метода и обрабатываемого этим методом объекта.

Делегат — это безопасный в отношении типов объект, указывающий на другой метод или возможно на список методов приложения, которые могут быть вызваны в более позднее время.

Делегаты обеспечивают безопасный по отношению к типам обратный вызов методов. Проверка на этапе компиляции.

Делегат поддерживает три важных порции информации:

- адрес метода, вызовы которого он делает;

- аргументы (если есть) вызываемого метода;

- возвращаемое значение (если есть) вызываемого метода.

Пример объявления делегата и его использования:

```csharp
internal delegate void Feedback(int value);
// используемые методы
    private static void Processor(Feedback fb, int value)
    {
        fb?.Invoke(value);
    }
    private static void StaticFeedbackToConsole(int value)
    {
        Console.WriteLine("Static Console = " + value);
    }
    public void FeedbackToConsole(int value)
    {
        Console.WriteLine("Console = " + value);
    }
// использование в главном методе
        Processor(null, 1);
        Processor(new Feedback(StaticFeedbackToConsole), 2);
        var p = new Program();
        Processor(new Feedback(p.FeedbackToConsole), 3);
        var fb1 = new Feedback(StaticFeedbackToConsole);
        var fb2 = new Feedback(p.FeedbackToConsole);
        var fbChain = default(Feedback);
        fbChain = (Feedback)Delegate.Combine(fbChain, fb1);
        fbChain = fbChain += fb2;
        Processor(fbChain, 4); //вызов цепочки методов делегата
        Processor(StaticFeedbackToConsole, 5); //неявное создание делегата
```

Допускается определять делегаты с модификаторами параметров ref и out.

```csharp
internal delegate string Feedback(out int val1, ref int val2, int val3);
```

Поддерживается ковариантность и контравариантность при привязке метода к делегату. 

- Ковариантность означает, что метод может возвратить тип производный(конкретный) от типа, возвращаемого делегатом.

- Контравариантность означает, что метод может принимать параметр, который может быть более универсальным (базовым).

- Инвариантность означает, что метод возвращает и принимает только заданный изначально тип.

Пример:

```csharp
internal delegate object MoveDelegate(FileStream stream);
// метод подходящий по инвариантности
    private static string MoveTest(Stream stream)
    {
        return "Test";
    }
// использование
    var md = new MoveDelegate(MoveTest);
```

## Тонкости делегатов

Определение в коде делегата заставляет компилятор C# на самом деле создавать класс делегата, содержащий конструктор, метод, прототип которого указан в исходном коде, методы, обеспечивающие асинхронный обратный вызов. Этот класс (как и любой класс делегата) будет являтся потомком класса System.MulticastDelegate.

Так как делегаты по сути являются классами, их можно объявить в любой области, где можно объявить класс.

Важнейшие закрытые поля делегата MulticastDelegate:

_target - Тип System.Object - Когда делегат является оболочкой статического метода, это поле содержит null. Когда делегат является оболочкой экземплярного метода, поле ссылается на объект, с которым будет работать метод (this).

_methodPtr - Тип System.IntPtr - Внутреннее целочисленное значение, используемое CLR для идентификации метода обратного вызова.

_invocationList - Тип System.Object - Обычно содержит null, но может ссылаться на массив делегатов при построении из них цепочки.

В конструктор передается ссылка на объект и целое число, ссылающееся на метод обратного вызова.

Каждый раз при вызове делегата следует совершить проверку, что его значение не равно null.

## Цепочки делегатов

Цепочкой называется коллекция делегатов, дающая возможность вызывать все методы, представленные этими делегатами.

Открытый статический метод Combine класса Delegate добавляет в цепочку делегатов новый.

Когда происходит добавление нового делегата в цепочку, происходит установка в поле _invocationList ссылки на
массив делегатов.

Когда метод Invoke вызывается для делегата, этот делегат обнаруживает, что значение поля _invocationList отлично от null. Это приводит к выполнению цикла, перебирающего все элементы массива, вызывая для них метод, оболочкой которого служит этот делегат.

Чтоб упростить разработку, C# предоставляет перегруженные версии операторов += и -= для экземпляров делегатов. Эти операторы вызывают методы Combine и Remove. 

Цепочки делегатов имеют недостатки - возвращается значение только из последнего вызванного метода, выполнение делегата надолго приостанавливается при возникновении исключения.

Можно напрямую работать с массивом делегатов:

```csharp
Delegate[] arrayOfDelegates = status.GetInvocationList();
// вызов полученных делегатов
foreach (GetStatus getStatus in arrayOfDelegates) {
...
}
```

## Обобщенные делегаты

В пространстве имен System определено несколько обобщенных делегатов, представляющие методы, которые могут принимать до 16 параметров.

Делегаты Action для функций без возвращаемого значения, Func - с возвращаемым значением, позволяют функции обратного вызова вернуть значение. Делегат типа Predicate способен указывать на любой метод, который возвращает bool и принимает единственный параметр.

```csharp
public delegate void Action();
public delegate void Action<T>(T obj);
public delegate void Action<T1, T2>(T1 arg1, T2 arg2);
...
public delegate void Action<T1, ..., T16>(T1 arg1, ..., T16 arg2);
public delegate void Func<TResult>();
public delegate void Func<T, TResult>(T arg);
public delegate void Func<T1, T2, TResult>(T1 arg1, T2 arg2);
...
public delegate void Func<T1, ..., T16, TResult>(T1 arg1, ..., T16 arg2);
public delegate bool Predicate<T>(Т obj);
```

Вместо представления собственных делегатов рекомендуется по возможности использовать уже определенные обобщенные делегаты. Обобщенные делегаты поддерживают ковариантность и контравариантность.

## Упрощенный синтаксис работы с делегатами

Компилятор C# поддерживает упрощенный синтаксис при работе с делегатами:

```csharp
button1.Click += new EventHander(button1_Click);
// равносильно
button1.Click += button1_Click;
```

Можно не указывать создание делегата - компилятор сам догадается и вставит нужный код за разработчика.

```csharp
ThreadPool.QueueUserWorkItem(new WaitCallback(SomeAsyncTask), 5);
// равносильно
ThreadPool.QueueUserWorkItem(SomeAsyncTask, 5);
// метод
private static void SomeAsyncTask(Object o)
{
    Console.WriteLine(o);
}
```

Можно использовать анонимную функцию, а не использовать отдельный метод обратного вызова:

```csharp
ThreadPool.QueueUserWorkItem(delegate (object? obj) { Console.WriteLine(obj); }, 5);
```

Можно не определять отдельный метод обратного вызова, а сразу вставлять код (лямбда-выражения):

```csharp
ThreadPool.QueueUserWorkItem(obj => Console.WriteLine(obj), 5);
```

Онаружив лямбда-выражение, компилятор C# сам автоматически создаст закрытый метод, называемый анонимной функцией. Обычно создается закрытый статический метод. Но если у метода есть ссылки на члены экземпляра, то создается экземплярный метод.

Имена параметров, передаваемых лямбда-функции следует указать слева от стрелки. Параметры лямбда-выражения могут быть явно или неявно типизированными.

```csharp
Func<string> f = () => "Test";
Func<int, string> f2 = (int x) => x.ToString();
Func<int, string> f3 = x => x.ToString();
Func<int, int, string> f4 = (x1, x2) =>
{
    var sum = x1 + x2;
    return sum.ToString();
};
```

Можно не создавать обертку для локальных переменных при передаче их лямбде-функции, а сразу на них ссылаться в теле лямбда-функции. Компилятор сам создаст временный вспомогательный класс для передачи значений из метода в лямбда-функцию.

В лямбда-функциях можно использовать ключевое слово static и отбрасывание.

```csharp
var numbers = list.FindAll(static i => (i % 2) == 0);
```









