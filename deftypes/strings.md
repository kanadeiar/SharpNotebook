# Строки

System.String - неизменяемый упорядоченный набор символов, ссылочный тип, прямой потомок object. Реализует несколько интерфейсов для удобства.

Относится к примитивным типам. Не может создаваться использованием оператора new. Компилятор помещает литеральные строки в метаданные модуля, откуда они загружаются и используются во время выполнения. В CLR объекты string создаются по специальной схеме.

```csharp
string s = "Test string";
```

Для вставки специальных символов, как конец строки, возврат каретки, забой, в C# используются управляющие последовательности. 

```csharp
string s = "Test\r\nstring";
string s = "Test" + Environment.NewLine + "string";
```

Конкатенация строк объединяет литеральные строки в одну на этапе компиляции. Конкатенация других строк - на этапе выполнения.

```csharp
string s = "Test " + "my " + "string";
```

Можно использовать символ буквальных строк с использованием признака буквальных строк @:

```csharp
string path = "C:\\Windows\\System32";
string path = @"C:\Windows\System32";
```

### Неизменяемость строк

Все строки типа string - неизменяемы. Если выполняется много операций над строками, то в куче создается много объектов string. Благодаря неизменяемости отпадает проблема синхронизации потоков при работе со строками. Тип string является запечатанным, тесно интегрирован в среду CLR.

Для того, чтоб уменьшить расход памяти используется интернирование одинаковых строк.

### Сравнение строк

Наиболее часто выполняющаяся операция над строкамия в целях определения равны ли они и для сортировки.

Методы сравнения объектов строк == и != переопределены, чтоб сравнить содержимое строк, а не ссылки. Операции равенства C# выполняют в отношении объектов string посимвольную проверку равенства с учетом регистра и нечувствительную к культуре.

Нужно использовать один из методов, определенных в типе string:

```csharp
bool Equals(string value, StringComparsion comparsionType)
static bool Equals(string a, string b, StringComparsion comparsionType)
static int Compare(string strA, string strB, StringComparsion comparsionType)
static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture)
static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options)
static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparsion comparsionType)
static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture)
static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options)
bool StartsWith(string value, StringComparsion comparsionType)
bool StartsWith(string value, bool ignoreCase, CultureInfo culture)
bool EndWith(string value, StringComparsion comparsionType)
bool EndWith(string value, bool ignoreCase, CultureInfo culture)
```

При сортировке следует учитывать регистр символов. В параметре StringComparsion передается тип сравнения.

Когда строки используются внутри программы для решеня внутренних задач, то для таких задач следует использовать флаг Ordinal или OrdinalIgnoreCase. Это самый быстрый способ сравнения.

Когда нужно сравнить строки с учетом лингвистических особенностей, нужно использовать флаг CurrectCulture или CurrentCultureIgnoreCase. Это самый медленный способ сранения.

Сравнение строк в верхнем регистре оптимизировано в фреймворке - используем ToUpperInvariant.

Следует явно указывать, как выполнять сравнение строк, так код будет проще читать.

Объект CultureInfo следует использовать когда нужно использовать региональные стандарты при сортировке строк:

### Интернирование строк

При порядковом сравнении CLR быстро проверяет равенство количества символов, и только если длина одинакова - проводится посимвольное сравнение. При сравнении с учётом региональных стандартов - посимвольно сравнивать даже если длины строк разные.

В CLR поддерживается механизм интернирования строк. При инициализации CLR создает внутреннююю хеш-таблицу, в которой ключами являются строки, а значениями - ссылки на строковые объекты в управляемой куче.

Метод Intern ищет string во внутренней хеш-таблице. При обнарушении возвращается ссылка на объект, иначе - создается копия и добавляется во внутреннюю хеш-таблицу, затем вертается ссылка на объект.

Метод IsInterned получает параметр string и ищет его во внутреннеей хеш-таблице. При удачном поиске - вертает ссылку на объект, иначе - null.

По умолчаию при загрузке сборки CLR интернирует все литеральные строки.

### Символы в строке

Когда нужно проверять отдельные символы в строке, то нужно применять один из определенных в типе string экземплярных методов. 

Методы копирования строк:

Clone() - экземплярный - возвращает ссылку на тот же самый объект.

Copy() - статический - возвращает новую строку - дубликат заданной строки.

CopyTo() - экземплярный - копирует группу символов в массив символов.

Substring() - экземплярный - возвращает новую строку, как часть исходной.

ToString() - экземплярный - возвращает ссылку на тот-же объект (this).

Все методы возвращают новую строку, изменить существующую строку нельзя.

### Тип изменяемых строк

Для динамических операций со строками и символами нужно использовать специальный тип StringBuilder, это подобие общедоступного конструктора строк string. 

У типа StringBuilder предусмотрено поле со ссылкой на массив структур char. Методами этого типа можно манипулировать этой строкой. При увеличении строки тип автоматически выделит память для нового, большего по размеру массива, скопирует символы и приступает к работе с новым массивом. Метод ToString возвращает неизменяемую строку string.

Объект создается как класс:

```csharp
var sb = new StringBuilder();
```

У этого типа несколько конструкторов, в которых можно задавать параметры:

- Максимальная емкость - int - максимальное количество символов, размещаемых в строке. 

- Емкость - int - показывает размер массива. При добавлении символов и превышении этого значения, размер увеличивается вдвое, а затем символы копируются из исходного в новый. 

- Массив символов - char[] - можно инициализировать этот массив символов, передавая string как параметр.

StringBuilder выделяет память для новых объектов только в двух случаях: при динамическом построении строк, когда размер превышает емкость и при вызове метода ToString. 

Большинство методов StringBuilder возвращают ссылку на тот-же объект, это позволяет построить цепочки операций друг за другом.

```csharp
var sb = new StringBuilder();
sb.AppendFormat("{0} {1}", "Test", "Name").Replace(" ", "-");
var s = sb.ToString().ToUpper();
sb.Length = 0;
sb.Append(s).Insert(2, "Have");
s = sb.ToString();
Console.WriteLine(s);
```

## Строковое представление объекта

Для получения представления любого объекта в виде строки предназначен виртуальный экземплярный метод ToString().

Реализация ToString типа object возвращает имя объекта. Все базовые типы имеют переопределенный метод ToString, реализация которого возвращает строку с учетом региональных стандартов.

Тип может предложить вызывающей программе выбор форматирования и региональных стандартов, все базовые типы это делают. Многие типы поддерживают множество форматов.

```csharp
var price = 123.54M;
var s = price.ToString("C", new CultureInfo("vi-VN"));
MessageBox.Show(s);
var s = price.ToString("C", CultureInfo.InvariantCulture);
MessageBox.Show(s);
```

### Форматирование строкового вывода

Внутри метода Format для каждого объекта вызывается метод ToString, получающий его строковое представление. Чтобы расширить стандартное форматирование объекта, нужно добавить внутрь фигурных скобок строку форматирования.

```csharp
var s = string.Format("On {0:D}, {1} is {2:E} years old.",
new DateTime(2012, 4, 22, 14, 35, 5), "Aidan", 9);
Console.WriteLine(s);
```

### Интерполяция строк

Можно использовать альтернативный синтаксис формирования строки, позволяющий напрямую внедрять в строку переменные:

```csharp
string greeting2 = $"Hello {name.ToUpper()} you are {age} years old.";
```

### Дословные строки

Если добавить к строковому литералу префикс @, то будет создана так называемая дословная строка. Такая возможность наиболее полезна при работе со строками, представляющими пути к каталогам и сетевым ресурсам.

```csharp
Console.WriteLine(@"С:\MyApp\bin\Debug");
//дословная и интерполированная
string myLongString2 = $@"This is a very
    very
        long string with {interp}";
```

## Получение объекта посредством разбора строки

Любой тип, способный разобрать строку, имеет открытый статический метод Parse. Он получает в параметре строку string, а на выходе - объект. Все числовые типы именю как минимум один метод Parse. 

Пример разбора строки типом int:

```csharp
int x = int.Parse("123", NumberStyles.None, null);
int x = int.Parse(" 123", NumberStyles.AllowLeadingWhite, null);
int x = int.Parse("1A", NumberStyles.HexNumber, null);
```

Для удобства у многих типов есть множество перегруженных версий методов Parse. Для требующих высокой производительности случаев в Microsoft создали методы TryParse для всех простых типов данных. 

```csharp
if (int.TryParse("123", out var value))
{
    Console.WriteLine(value);
}
```

## Кодировки

В CLR все символы представлены 16-разрядными кодами Юникода, а строки состоят только из 16-разрядных символов Юникода. Если кодировка явно не указана, все эти типы по умолчанию используют код UTF-8.

UTF-16 кодирует каждый 16-разрядный символ в 2 байта. При этом символы остаются, как были, и сжатия данных не происходит.

UTF-8 кодирует некоторые символы одним байтом, другие — двумя байтами, третьи — тремя, а некоторые — четырьмя.

Непопулярные:

UTF-32 кодирует все символы в 4 байта. Эта кодировка используется для создания простого алгоритма прохода символов, в котором не требуется разбираться с символами, состоящими из переменного числа байтов.

UTF-7 обычно используется в старых системах, где под символ отводится 7 разрядов.

ASCII кодирует 16-разрядные символы в ASCII-символы; то есть любой 16-разрядный символ со значением меньше 0x0080 переводится в одиночный байт. Символы со значением больше 0x007F не поддаются этому преобразованию, и значение символа теряется.

```csharp
string s = "Пример строки";
var encoding = Encoding.UTF8;
var encBytes = encoding.GetBytes(s);
Console.WriteLine("Encoded: " + BitConverter.ToString(encBytes));
var decoded = encoding.GetString(encBytes);
Console.WriteLine("Decoded: " + decoded);
```

## Защищенные строки

Для решения задач хранения секретных данных в памяти служит тип SecureString. При создании этого типа его код выделяет блок неуправляемой памяти, который содержит зашифрованную строку. При проведении операций над этой строкой строка расшифровывается и затем снова зашифровывается.


