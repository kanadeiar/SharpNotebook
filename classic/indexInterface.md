# Интерфейсы

В языке C# интерфейсный тип представляет собой именованный набор абстрактных членов. А абстрактные тедоты являются протоколом без реализации. Интерфейс выражает поведение, которое заданный класс или структура может поддерживать. Класс или структура может реализовывать сколько угодно интерфейсов и поддерживать множество линий поведения.

>Все имена интерфейсов нужно начинать с заглавной буквы I - такое соглашение.

В отличие от абстрактного класса интерфейсные типы могут содержать только определения членов. Полиморфный интерфейс абстрактного класса поддерживается только призводными типами от базового. А полиморфный интерфейс может быть реализован любым классом либо структурой, в любой иерархии и внутри любого пространства имен или сборки.

## Определение

В отличие от классов для интерфейсов никода не задается базовый класс. Для членов интерфейса никогда не указываются модификаторы доступа (так как все они неявно открытые и абстрактные).

Интерфейс - это протокол и реализация для него не предоставляется - за нее отвечает поддерживающая его класс или структура. В интерфейсе позволяется определять любое количество прототипов как методов, так и свойств.

Пример определения простейшего специального интерфейса:
```csharp
interface ISample
{
    //неявно открытый и абстрактный
    int GetNumberOfSample();
    //свойства
    int propTest { get; set; }
    int propSet { set; }
    int protGet { set; }
}
```
Интерфейсы не привносят ничего особого до тех пор, пока не будут реализованы классом или структурой.

Многие стандартные интерфейсы уже определены у различных типов платформы .NET. Интерфейс .NET под названием ICloneable из пространства имен System реализован очень многими типами. Такие типы можно обработать полиморфным образом последством этого интерфейсного типа:
```csharp
int[] abc = {10, 20};
object theClone = abc.Clone();
```

## Реализация

При расширении функциональности класса путем поддержки интерфейса к его определению добавляется после указания базового класса, если он есть, через запятую список нужных интерфейсов.

Примеры различных определений с интерфейсом:
```csharp
public class Sampl : ISample
{ /* code */ }
public class SamplCl : object, ISample
{ /* code */ }
public class SamplPo : Base, ISample, ICloneable
{ /* code */ }
public struct SamplSt : ISample, ICloneable
{ /* code */ }
```
Поддерживающий реализацию класс или структура должны либо не иметь возможности выборочно решать, какие члены он будет реализовать, либо реализовать все члены интерфейса.

Пример реализации интерфейса различными связанными классами:
```csharp
interface IWork
{
    int Work { get; } //все должны работать
}
public abstract class Person
{
    public int Money { get; set; } = 0;
    public abstract void GiveBonus(int num);

}
class Manager : Person, IWork
{
    public override void GiveBonus(int num)
    {
        Money += num * 10;
    }
    public int Work => 100; //очень много работает
}
class Worker : Person, IWork
{
    public override void GiveBonus(int num)
    {
        Money += num / 10;
    }
    public virtual int Work => 50; //так себе работает
}
class AsiaWorker : Worker
{
    public sealed override void GiveBonus(int num)
    {
        base.GiveBonus(num / 100); //гастарбайтерам еще меньше бонусов
    }
    public override int Work => 0; //совсем не работает
}
```


![Интерфейс](../img/interface.png) 

Иерархия вместе с интерфейсами.

# Использование членов интерфейсов

Если члены интерфейса не реализованы явно, то к членам интерфейса можно обращатся напрямую на уровне объекта. Пример:
```csharp
Worker worker = new Worker();
int work = worker.Work;
```
Однако если тип не поддерживает интерфейсом, то генерируется исключение InvalidCastException. Пример обработки:
```csharp
Freedom freedom = new Freedom();
try
{
    int work = ((ISample) freedom).Work(); //у бомжа совcем нет свойства работать!!!
}
catch (InvalidCastException ex)
{
    WriteLine(ex.Message);
}
```

Но так лучше не делать, есть способы определить поддерживается ли интерфейс объектом или нет до обращения к членам интерфейса, реализованным в объекте.

Используя ключевое слово as можно определить, трактуется ли объект как указанный интерфейс, и если да то возвращается ссылка на интересующий интерфейс, а если нет, то ссылка на null. И перед продолжением нужно проверить результат на null:
```csharp
Worker worker = new Worker();
IWork work = worker as IWork;

if (work != null)
    WriteLine($"Работа: {work.Work}");
else
    WriteLine("Это не работник!");
```

Можно еще и проверять используя ключевое слово is. Если интересующий объект не совместим с указанным, то возвращается значение false, если же совместим с интерфейсом - true, то можно безопасно обращаться к его членам. Тут уже без проверки на null:
```csharp
Person[] persons = { new Manager(), new Worker(), new AsiaWorker() };
foreach (var item in persons)
{
    if (item is IWork work)
        WriteLine($"Work = {work.Work}");
    else
        WriteLine($"It is no work!");
    WriteLine($"Money = {item.Money}$");
}
```

# Интерфейсы в определениях методов

Интерфейсы можно использовать как параметры в методах. Так как интерфейсы - это типы, то можно строить методы, которые принимают интерфесы в качестве параметров.

Пример добавления еще одного специфического интерфейса в иерархию классов:
```csharp
interface IBoss
{
    int Coffee(); //только элите можно пить кофе
}
```
И лишь избранным их всей иерархиии реализовать новый интерфейс:
```csharp
class Boss : Person, ICofee
{
    public void GiveCoffee()
    {
        WriteLine("Ammm Cofee!");
    }
    public override void GiveBonus(int num)
    {
        Money *= 9999; //гребет все деньги компании
    }
}
```

![Интерфейс](../img/interfaceAdvance.png) 

Та-же иерархия с дополнительным интерфейсом.





