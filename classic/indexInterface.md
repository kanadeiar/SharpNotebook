# Интерфейсы

В языке C# интерфейсный тип представляет собой именованный набор абстрактных членов. А абстрактные тедоты являются протоколом без реализации. Интерфейс выражает поведение, которое заданный класс или структура может поддерживать. Класс или структура может реализовывать сколько угодно интерфейсов и поддерживать множество линий поведения.

>Все имена интерфейсов нужно начинать с заглавной буквы I - такое соглашение.

В отличие от абстрактного класса интерфейсные типы могут содержать только определения членов. Полиморфный интерфейс абстрактного класса поддерживается только призводными типами от базового. А полиморфный интерфейс может быть реализован любым классом либо структурой, в любой иерархии и внутри любого пространства имен или сборки.

## Определение

В отличие от классов для интерфейсов никода не задается базовый класс. Для членов интерфейса никогда не указываются модификаторы доступа (так как все они неявно открытые и абстрактные).

Интерфейс - это протокол и реализация для него не предоставляется - за нее отвечает поддерживающая его класс или структура. В интерфейсе позволяется определять любое количество прототипов как методов, так и свойств.

Пример определения простейшего специального интерфейса:
```csharp
interface ISample
{
    //неявно открытый и абстрактный
    int GetNumberOfSample();
    //свойства
    int propTest { get; set; }
    int propSet { set; }
    int protGet { set; }
}
```
Интерфейсы не привносят ничего особого до тех пор, пока не будут реализованы классом или структурой.

Многие стандартные интерфейсы уже определены у различных типов платформы .NET. Интерфейс .NET под названием ICloneable из пространства имен System реализован очень многими типами. Такие типы можно обработать полиморфным образом последством этого интерфейсного типа:
```csharp
int[] abc = {10, 20};
object theClone = abc.Clone();
```

## Реализация

При расширении функциональности класса путем поддержки интерфейса к его определению добавляется после указания базового класса, если он есть, через запятую список нужных интерфейсов.

Примеры различных определений с интерфейсом:
```csharp
public class Sampl : ISample
{ /* code */ }
public class SamplCl : object, ISample
{ /* code */ }
public class SamplPo : Base, ISample, ICloneable
{ /* code */ }
public struct SamplSt : ISample, ICloneable
{ /* code */ }
```
Поддерживающий реализацию класс или структура должны либо не иметь возможности выборочно решать, какие члены он будет реализовать, либо реализовать все члены интерфейса.

Пример реализации интерфейса различными связанными классами:
```csharp
interface IWork
{
    int Work { get; } //все должны работать
}
public abstract class Person
{
    public int Money { get; set; } = 0;
    public abstract void GiveBonus(int num);

}
class Manager : Person, IWork
{
    public override void GiveBonus(int num)
    {
        Money += num * 10;
    }
    public int Work => 100; //очень много работает
}
class Worker : Person, IWork
{
    public override void GiveBonus(int num)
    {
        Money += num / 10;
    }
    public virtual int Work => 50; //так себе работает
}
class AsiaWorker : Worker
{
    public sealed override void GiveBonus(int num)
    {
        base.GiveBonus(num / 100); //гастарбайтерам еще меньше бонусов
    }
    public override int Work => 0; //совсем не работает
}
```

![Интерфейс](../img/interface.png) 

# Использование членов интерфейсов






