# Наследование (является, имеет, включает)

Базовая идея наследования в том, что новые классы могут создаватся с применением существующих классов как оправной точки. 

Существуют следующие методики построения:

- [X] наследование

- [X] включение

- [X] вложение

## Модель наследование - "является"

Здесь один из классов - производный является (или наследует) базовый класс. Это позволяет строить новые определения классов, которые расширяют функциональность существующих классов.

Пример базового класса:
```csharp
class Pet
{
    public readonly int minAge = 18;
    public string Name { get; set; }
    private int age;
    public int Age
    {
        get => age;
        set => age = (value >= minAge) ? value : minAge;
    }
}
```
Существующий класс, который будет служить основой для нового класса, называется базовым классом, суперклассом или родительским классом. Расширяющие классы называются производные или дочерними классами. Пример производного класса:
```csharp
class Cat : Pet
{
    public void TestMethod()
    {
        Age = 25;
    }
}
```
В языке C# нельзя делать множественное наследование. Допускается только один непосредственный базовый класс. Создать тип класса, который был бы производный от нескольких базовых классов невозможно. Вместо этого платформа .NET позволяет классу или структуре реализовать любое количество дискретных интерфейсов. Класс может поддерживать несколько линий поведения избегая сложностей множественного наследования.

Интерфейс может наследоваться от нескольких интерфейсов. Но класс может наследоваться только от одного класса. И класс может реализовать множество интерфейсов.

Класс может быть может быть запечатанным, для этого он должен быть помечен ключевым словом sealed, которое предотвращает создание производных классов от этого класса.

Пример запечатанного класса:
```csharp
sealed class Cat : Pet
{
}
```
После того, как отношение "является" установлено, классы производные от базового наследуют все открытые члены базового класса. Пример:
```csharp
class Person
{
    public string Name { get; set; } = "noname";
    public int Age { get; set; }
}
class Manager : Person
{
    public int Money { get; set; }
}
class Worker : Person
{
    public int Health { get; set; }
}
```
Пример использования - доступны члены базового класса:
```csharp
Manager man = new Manager();
man.Name = "Kamal";
man.Age = 32;
man.Money = 2334;
```
Для оптимизаци создания объектов производного класса необходимо корректно реализовать конструкторы подкласса, чтоб они явно вызывали подходящий спец конструктор базового класса вместо стандартного конструктора.

Ключевое слово base ссылается на сигнатуру конструктора базового класса и необходимость передачи данных конструктору родительского класса. Пример организации создания производного класса на основе базового с применением ключевого слова base:
```csharp
class Person
{
    public string Name { get; set; } = "noname";
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
class Manager : Person
{
    public int Money { get; set; }
    public Manager(string name, int age, int money) : base(name, age)
    {
        Money = money;
    }
}
class Worker : Person
{
    public double Health { get; set; }
    public Worker(string name, int age, double health) : base(name, age)
    {
        Health = health;
    }
}
```
Использование:
```csharp
Manager man = new Manager("And", 22, 22);
Worker work = new Worker("Calus", 18, 33.2);
```
Язык C# предоставляет дополнительное ключевое слово для определения доступности членов protected для определения защищенных членов базового класса, которые будут доступны наследнику. Тогда производным классам не придется обращатся к данным косвенно, используя открытые методы и свойства. Однако определяя защищенные члены создается уровень доверия между родительским и дочерним классом. А недобросовестный дочерний класс может нарушить инкапсуляцию.

Пример:
```csharp
class Person
{
    protected string name;
    protected int age;
}
class Rogue : Person
{
    public void Hack()
    {
        name = "Hack";
        age = 999;
    }
}
```
Когда определенная ветвь в цепочке наследования классов нуждается в отсечении - то есть дальнейшее ее расширение нужно запретить. Для запрета используется ключевое слово sealed:
```csharp
sealed class Rogue : Person
{
    public void Hack()
    {
        name = "Hack";
        age = 999;
    }
}
```

## Модель включения "имеет"

Здесь отношение "имеет" или модель включения/делегации или агрегация. Это действие по добавлению во включающий класс открытых членов, которые работают с функциональностью содержащегося внутри объекта. Класс имеет в своем составе объект другого класса. Открытие доступа к функциональности содержащегося объекта внешнему миру требует делегации. Делегация - это действие по добавлению во включающий класс открытых членов, которые работают с функциональностью содержащегося внутри объекта.

Пример простой:
```csharp
class House
{ 
}
class Person
{
    // каждый в своем составе имеет объект этот
    protected House house = new House();
}
```
Можно открывать доступ к включенному объекту с применением специального свойства и использовать его функциональность:
```csharp
class House
{
    public int Size { get; set; } = 12;
    public int CalculateOptimalSize()
    {
        return Size * Size;
    }
}
class Person
{
    // каждый в своем составе имеет объект этот
    protected House house = new House();
    public int CalcOptimalSize()
    {
        return house.CalculateOptimalSize();
    }
    public House House
    {
        get => house;
        set => house = value;
    }
}
```
Использование:
```csharp
Person person = new Person();
int size = person.CalcOptimalSize();
int size2 = person.House.Size;
```

## Модель вложения

В языке C# допускается определять тип (перечисление, класс, интерфейс, структуру или делегат) прямо внутри класса или структуры. В этом случае вложенный тип - член охватывающего типа, и им можно манипулировать как любым другим членом (полем, свойством, методом или событием).

Пример:
```csharp
class Person
{
    public class Kind { }
    private class Lover { }
}
```
Особенности вложенных типов:

- вложнные типы позволяют получить полный контроль над уровнем доступа внутреннеготипа, так как они закрытые.

- так как вложенный тип яляется членом включающего класса, он может иметь доступ к закрытым членам этого включающего класса.

- вложенный типа полезен как вспомогательный для внешнего класса и не нужен для использования вне класса.

Можно обращатся к вложенному типу:
```csharp
Person.Kind kind = new Person.Kind();
```




