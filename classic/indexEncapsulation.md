# Инкапсуляция

## Тип класса

Класс - определяемый пользоватлем тип, состоящий из полей данных (переменные) и членов, которые оперируют полями данных (конструкторы, свойства, методы, события). Набор полей данных класса представляет состояние экземлпяра класса (объекта). 

Простейшее возможное объявление класса:
```csharp
class Sample
{ }
```
Класс с объявленными полями данных:
```csharp
class Sample
{
    public string name;
    public int age;
}
```
> Поля могут быть объявленными закрытыми private, защищенными protected, публичными public.

Класс с добавленными методами:
```csharp
class Sample
{
    public string name;
    public int age;
    public void PrintStat() => WriteLine($"{name} - {age}");
    public void AddAge(int delta) => age += delta;
}
```
Использование этого класса:
```csharp
Sample amp = new Sample();
amp.name = "And";
amp.age = 18;
amp.AddAge(10);
amp.PrintStat(); //And - 28
```

## Размещение новых объектов с помощью new

Объекты должны размещатся в памяти с применением ключевого слова new. Первый оператор объявляет ссылку на определенный объект типа Sample. Ссылка будет указывать на действительный объект после ее явного присваивания.

## Конструкторы

Конструкторы позволяют устанавливать состояние объекта в момент его создания. Конструктор - это специальный метод класса, который вызывается при создании объекта с применением ключевого слова new. Имя конструктора всегда совпадает с именени класса. Каждый класс C# снабжается бесплатным стандартным конструтором, который в случае необходимости может быть переопределен. 

Пример переопределения стандартного конструктора:
```csharp
public Sample()
{
    name = "one";
    age = 1;
}
```

Помимо стандартного конструктора в классах могут определется специальные дополнительные конструкторы. 
```csharp
public Sample(string name, int age)
{
    this.name = name;
    this.age = age;
}
```
>Таким образом конструктор перегружен, появляется несколько способов создания объекта в время объеялвения.

Пример использования:
```csharp
Sample amp2 = new Sample("And", 14);
```
Конструктор можно описывать сжатым до выражения:
```csharp
public Sample(string name) => this.name = name;
```
Если не определен специальный конструктор, то компилятор C# срабжает класс стандартным конструктором, давая возможность пользователю размещать в памяти экземпляр необходимого класса с набором полей данных, которые установлены в корректные стандартные значения.

При этом как только определяется специальный уникальный конструктор, то компилятор стандартный конструктор удаляется и становится недоступным.

>Следовательно если нужно позволить создавать экземпляр класса как с помощью стандартного, так и специального конструктора, то необходимо явно переопределить стандартный конструктор.

Пример класса:
```csharp
class Sample
{
    public string name;
    public int age;
    
    public Sample() { }
    
    public Sample(string name) => this.name = name;

}
```

## Ключевое слово this

В языке C# имеется ключевое слово this, которое позволяет обращатся к текущему экземпляру класса. Одно из применений - устарнение неоднозначности при обращении к полям класса. Пример:
```csharp
public void SetName(string name)
{
    this.name = name;
}
```

Другое из применений - проектирование класса с использованием приема, который называется построением цепочки конструкторов. Совершенный подход предполагает назначение одного из констркторов главным и выполнение необходимой логики и проверок внутри него, а остальные через ключевое слово this будут передавать входные аргументы и необходимые параметры главному конструтору.

Пример построения такого класса:
```csharp
class Sample
{
    public string name;
    public int age;
    public Sample() {}
    public Sample(int age) : this("", age) {}
    public Sample(string name) : this(name, 0) {}
    public Sample(string name, int age) //главный конструктор
    {
        this.name = name;
        if (age > 99)
        {
            age = 99;
        }
        this.age = age;
    }
}
```
Очень важно то, что как только конструктор передал аргументы выделеннному главному (и главный сделал свою работу), первоначально вызванный конструктор продолжит выполнение всех оставшихся операторов кода.

Логика констркторов:

- Создается объект путем вызова конструктора, принимающего аргументы.

- Этот констрктор передает полученные данные главному конструктору и предоставляет начальные данные ему.

- Главный констрктор присваивает входные данные полям данных объекта.

- Управление возвращается первоначально вызванному конструктору, который выполняет оставшиеся операторы кода.

Можно применять необязательные аргументы:
```csharp
public Sample(string name = "", int age = 0) //конструктор единственный
{
    this.name = name;
    if (age > 99)
    {
        age = 99;
    }
    this.age = age;
}
```
Использование данного конструктора:
```csharp
Sample s1 = new Sample();
Sample s2 = new Sample("Тест");
Sample s3 = new Sample(age:20);
```

## Ключевое слово static

Член класса помеченный ключевым словом static должен вызыватся на уровне класса, а не через переменную со ссылкой на объект.

Статические члены класса = это элементы, для обращения к которым не нужно создавать экземпляр класса, они общие. Статические члены продвигают отдельный элемент на уровень класса вместо уровня объектов. 

Это ключевое слово может применяться:

- к данным класса

- к методам класса

- к свойствам класса

- к конструктору

- к полному определению класса

- в сочетании с ключевым словом using.

При определении статических полей данных класса выделенная под них память разделяется всеми объектами этой категории. Пример:
```csharp
class Person
{
    public int Balance;
    public static double CreditRate = 10.0; //между всеми одинаковое значение
}
```
Статические методы могут взаимодействовать со статическими данными:
```csharp
class Person
{
    public int Balance;
    public static double CreditRate = 10.0; //между всеми одинаковое значение
    public static void SetRate(double rate)
    {
        CreditRate = rate;
    }
    public static double GetRate => CreditRate;
}
```
>Обращение на нестатические члены внутри реализации статического члена приводит к ошибке! Так же как и применение ключевого слова this внутри статического метода, так как оно предполагает объект.

Возможно определять статический конструктор, который дает возможность безопасно устанавливать значения статических данных.

Пример:
```csharp
class Person
{
    public int Balance;
    public static double CreditRate; //между всеми одинаковое значение
    static Person() //статический конструктор
    {
        CreditRate = 9.0;
    }
}
```
Статический конструктор представляет собой спец конструктор для инициализации значений статических данных, если значения не известны на этапе компиляции. Среда CLR всегда все статические конструкторы вызывает перед первым использованием и затем не вызывает их заново для данного экземпляра класса.

Особенности статического конструктора:

- в классе может быть определен только один статический конструктор, его перегружать нельзя.

- статический конструктор не имеет модификатора доступа и не принимает параметры.

- статический конструктор выполняется только один раз вне зависимости от количества создаваемых объектов этого класса.

- конструктор вызывается когда создается экземпляр класса или перед доступом к первому статическому члену.

- статический конструктор выполняется перед любым конструктором уровня экземпляра.

Возможно определять статичкский класс. Такой класс нельзя создавать с использованием ключевого слова new, он может содержать только статические члены и поля данных. Такой класс не нуждается в выделении памяти. Определение статического класса:
```csharp
static class MyUtils
{
    private static string name = "User";
    public static void PrintHello()
    {
        WriteLine("Hello " + name + "!");
    }
}
```
Статические члены статических классов можно импортировать с помощью ключевого слова using. Пример импорта статических членов:
```csharp
using static System.Console;
```
Использование:
```csharp
WriteLine("Hello!");
```
>Следует ограничивать применение такого импорта во избежание неоднозначностей в коде.

## Модификаторы доступа

В языке C# типы (классы, интерфейсы, структуры, перечисления и делегаты) и их члены (свойства, методы, конструкторы и поля) описываются с использованием модификаторов, устанавливающими видимостью элементов для других частей приложения.

Модификаторы доступа C#
```csharp
Модификатор         Применение                  Смысл
public              Типы или члены типов        Не имеют ограничений доступа, доступен из внешних сборок
private             Члены типов или вложенные   Могут быть доступны только классу, где определены
protected           Члены типов или вложенные   Могут использоватся классом, который их определяет и любым дочерним классам.
internal            Типы или члены типов        Доступны только в рамках текущей сборки.
protected internal  Члены типов или вложенные   Такой элемент будет доступен внутри сборки, внутри определяющего класса и для всех наследников
```
По умолчанию все типы в языке C# устанавливаются как internal, а члены типов являются закрытыми private. 

То есть этот код:
```csharp
class MyClass
{
    MyClass() {}
}
```
Равносилен этому:
```csharp
internal class MyClass
{
    private MyClass() {}
}
```
А для того чтобы тип и его члены были доступны везде нужно сделать так:
```csharp
public class MyClass
{
    public MyClass() {}
}
```

Модификаторы доступа могут применятся к вложенному типу. Вложенный тип - это тип, объявленный внутри области видимости класса или структуры.
```csharp
public class MyClass
{
    private class MiniClass { }
}
```

## Принципы инкапсуляции

Данные класса не должны быть доступны напрямую через его экземпляр, данные класса должны быть закрытыми. Если нужно получить доступ к данным, то нужно получать его косвенно, используя открытые члены.

Инкапсуляция предусматривает вмето открытых полей определение закрытых данных, управление которыми осуществляется с применением одного из двух:

- пары открытх методово доступа и изменения.

- открытого свойства.

Хорошо инкапсулированный класс должен защищать свои данные и скрывать подробности своего функционирования от внешнего мира.

>Члены класса, которые определяют состояние объекта, не должны быть публичными, однако нормально иметь открытые константы и открытые поля, допускающе только чтение.

Пример традиционного подхода:
```csharp
class Sample
{
    private string name;
    public string GetName()
    {
        return name;
    }
    public void SetName(string name)
    {
        this.name = name;
    }
}
```
Использование:
```csharp
Sample sample = new Sample();
sample.SetName("and");
string name = sample.GetName();
```

В языке C# лучше использовать свойства для доступа к закрытым полям. Свойства - упрощенное представление настоящих методов доступа и изменения. Пример класса со свойствами:
```csharp
class Sample
{
    private string name;
    public string Name
    {
        get { return name; }
        set { name = value; }
    }
}
```
Использование:
```csharp
Sample sample = new Sample();
sample.Name = "and";
string name = sample.Name;
```
Методы свойства get & set могут записываться в виде членов, сжатых до выражений. Пример:
```csharp
class Sample
{
    private string name;
    public string Name
    {
        get => name;
        set => name = value;
    }
}
```
Для получение и установки значения внутри класса нужно всегда применять свойства. Пример с конструктором:
```csharp
class Sample
{
    private string name;
    public string Name
    {
        get => name;
        set => name = value;
    }

    public Sample(string name)
    {
        Name = name;
    }
}
```
Могут быть свойства только для чтения и только для записи. Пример:
```csharp
class Sample
{
    private string name;
    public string Name => name;
    public string SetName
    {
        set => name = value;
    }
}
```
Может быть статическое свойство:
```csharp
class Sample
{
    private string name;
    public string Name => name;
    public string SetName
    {
        set => name = value;
    }
    private static int count = 1;
    public static int Count
    {
        get => count;
        set => count = value;
    }
}
```
Использование:
```csharp
Sample.Count = 10;
int count = Sample.Count;
```

## Автоматические свойства

Доступно вместо полного написания свойства и приватного поля данных использовать синтаксис автоматических свойств. Это свойство перекладывает работу по определению закрытых полей и связанных свойств на компилятор. Пример класса:
```csharp
class Sample
{
    public string Name { get; set; }
}
```
Можно определять автоматическое свойство только для чтения:
```csharp
class Sample
{
    public string Name { get; }
}
```
>Можно написать prop и два раза нажать таб - среда сгенерирует начальный код автоматического свойства.

Автоматическим свойствам присваиваются стандартные значения - булевской переменной - false, а для числовых данных - 0. Однако для переменной дригого класса - null.

Нужно, если требуется, устанавливать первоначальные значения в такие свойства. Пример:
```csharp
class Sample
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Sample()
    {
        Name = "noname";
        Age = 18;
    }
}
```
Однако лучше присваивать начальные значения автоматическим свойствам прямо при объявлении этого свойства.
```csharp
class Sample
{
    public string Name { get; set; } = "default";
    public int Age { get; set; } = 18;
}
```

## Синтаксис иницаиализации объектов

Для упрощения процесса создания и подготовки объекта в C# предлагается синтаксис инициализации объектов. Этот прием позволяет создавать новый объект и присвоение начальных значений свойствам и открытым полям при создании этого объекта. Инициализатор объекта - это переменные в усатых скобках {}.

Пример класса и создание объекта на его основе:
```csharp
class Sample
{
    public string Name { get; set; }
    public int Age { get; set; }
}
//создание объекта
Sample sample = new Sample {Name = "alex", Age = 24};
```
При использовании этого синтаксиса допускается вызывать стандартный или специальный конструтор, определенный в классе:
```csharp
class Sample
{
    public string Name { get; set; }
    public int Age { get; set; }
    public Sample(string name)
    {
        Name = name;
    }
}
//создание объекта
Sample sample = new Sample("alex") {Name = "Andrei", Age = 24};
```
При создании объекта можно вызвать любой конструктор, определенный в классе, при этом значения, записанные в скобках будут установлены в приоритете.

Синтаксиси инициализации объектов позволяет создавать объекты класса, содержаещго в своем составе другие классы:
```csharp
class Sample
{
    public MyClass MyVar = new MyClass();
    public class MyClass
    {
        public int Value { get; set; }
    }
}
//создание объекта
Sample sam = new Sample
{
    MyVar = new Sample.MyClass {Value = 10}
};
```

## Константные поля

В языке C# 8 доступна работа с константными полями, которые после первоначальной установки больше не изменяются. Нужно использовать ключевое слово const. Пример:
```csharp
class Sample
{
    public const double PI = 3.14;
}
//обращение к полю
double PI = Sample.PI;
```
Константные поля являются неявно статическими.

Есть еще поля, доступные только для чтения и онт может быть присвоены во время выполнения только внутри внутри конструктора, и больше нигде:
```csharp
class Sample
{
    public const double PI = 3.14;
    public readonly double PI2;
    public Sample()
    {
        PI2 = 3.14;
    }
}
//обращение к полям
double PI = Sample.PI;
Sample sample = new Sample();
double PI2 = sample.PI2;
```
Можно также определить статическое поле, доступное только для чтения на уровне класса, и значение ему устанавливать в статическом конструкторе:
```csharp
class Sample
{
    public static readonly double PI;
    static Sample()
    {
        PI = 3.14;
    }
}
```
## Частичные классы

В языке C# можно разносить код класса по нескольким файлам для отеделения например стереотипного кода от более полезных и интереных членов. Нужно ко всем определениям класса добавить ключевое слово partial.

Пример такого класса:
Файл Sample.cs
```csharp
partial class Sample
{
}
```
Файл Sample.Data.cs
```csharp
partial class Sample
{
}
```

    
