# Инкапсуляция

## Тип класса

Класс - определяемый пользоватлем тип, состоящий из полей данных (переменные) и членов, которые оперируют полями данных (конструкторы, свойства, методы, события). Набор полей данных класса представляет состояние экземлпяра класса (объекта). 

Простейшее возможное объявление класса:
```csharp
class Sample
{ }
```
Класс с объявленными полями данных:
```csharp
class Sample
{
    public string name;
    public int age;
}
```
> Поля могут быть объявленными закрытыми private, защищенными protected, публичными public.

Класс с добавленными методами:
```csharp
class Sample
{
    public string name;
    public int age;
    public void PrintStat() => WriteLine($"{name} - {age}");
    public void AddAge(int delta) => age += delta;
}
```
Использование этого класса:
```csharp
Sample amp = new Sample();
amp.name = "And";
amp.age = 18;
amp.AddAge(10);
amp.PrintStat(); //And - 28
```

## Размещение новых объектов с помощью new

Объекты должны размещатся в памяти с применением ключевого слова new. Первый оператор объявляет ссылку на определенный объект типа Sample. Ссылка будет указывать на действительный объект после ее явного присваивания.

## Конструкторы

Конструкторы позволяют устанавливать состояние объекта в момент его создания. Конструктор - это специальный метод класса, который вызывается при создании объекта с применением ключевого слова new. Имя конструктора всегда совпадает с именени класса. Каждый класс C# снабжается бесплатным стандартным конструтором, который в случае необходимости может быть переопределен. 

Пример переопределения стандартного конструктора:
```csharp
public Sample()
{
    name = "one";
    age = 1;
}
```

Помимо стандартного конструктора в классах могут определется специальные дополнительные конструкторы. 
```csharp
public Sample(string name, int age)
{
    this.name = name;
    this.age = age;
}
```
>Таким образом конструктор перегружен, появляется несколько способов создания объекта в время объеялвения.

Пример использования:
```csharp
Sample amp2 = new Sample("And", 14);
```
Конструктор можно описывать сжатым до выражения:
```csharp
public Sample(string name) => this.name = name;
```
Если не определен специальный конструктор, то компилятор C# срабжает класс стандартным конструктором, давая возможность пользователю размещать в памяти экземпляр необходимого класса с набором полей данных, которые установлены в корректные стандартные значения.

При этом как только определяется специальный уникальный конструктор, то компилятор стандартный конструктор удаляется и становится недоступным.

>Следовательно если нужно позволить создавать экземпляр класса как с помощью стандартного, так и специального конструктора, то необходимо явно переопределить стандартный конструктор.

Пример класса:
```csharp
class Sample
{
    public string name;
    public int age;
    
    public Sample() { }
    
    public Sample(string name) => this.name = name;

}
```

## Ключевое слово this

В языке C# имеется ключевое слово this, которое позволяет обращатся к текущему экземпляру класса. Одно из применений - устарнение неоднозначности при обращении к полям класса. Пример:
```csharp
public void SetName(string name)
{
    this.name = name;
}
```

Другое из применений - проектирование класса с использованием приема, который называется построением цепочки конструкторов. Совершенный подход предполагает назначение одного из констркторов главным и выполнение необходимой логики и проверок внутри него, а остальные через ключевое слово this будут передавать входные аргументы и необходимые параметры главному конструтору.

Пример построения такого класса:
```csharp
class Sample
{
    public string name;
    public int age;
    public Sample() {}
    public Sample(int age) : this("", age) {}
    public Sample(string name) : this(name, 0) {}
    public Sample(string name, int age) //главный конструктор
    {
        this.name = name;
        if (age > 99)
        {
            age = 99;
        }
        this.age = age;
    }
}
```
Очень важно то, что как только конструктор передал аргументы выделеннному главному (и главный сделал свою работу), первоначально вызванный конструктор продолжит выполнение всех оставшихся операторов кода.

Логика констркторов:

- Создается объект путем вызова конструктора, принимающего аргументы.

- Этот констрктор передает полученные данные главному конструктору и предоставляет начальные данные ему.

- Главный констрктор присваивает входные данные полям данных объекта.

- Управление возвращается первоначально вызванному конструктору, который выполняет оставшиеся операторы кода.

Можно применять необязательные аргументы:
```csharp
public Sample(string name = "", int age = 0) //конструктор единственный
{
    this.name = name;
    if (age > 99)
    {
        age = 99;
    }
    this.age = age;
}
```
Использование данного конструктора:
```csharp
Sample s1 = new Sample();
Sample s2 = new Sample("Тест");
Sample s3 = new Sample(age:20);
```

## Ключевое слово static

Член класса помеченный ключевым словом static должен вызыватся на уровне класса, а не через переменную со ссылкой на объект.

Статические члены класса = это элементы, для обращения к которым не нужно создавать экземпляр класса, они общие. Статические члены продвигают отдельный элемент на уровень класса вместо уровня объектов. 

Это ключевое слово может применяться:

- к данным класса

- к методам класса

- к свойствам класса

- к конструктору

- к полному определению класса

- в сочетании с ключевым словом using.

При определении статических полей данных класса выделенная под них память разделяется всеми объектами этой категории. Пример:
```csharp
class Person
{
    public int Balance;
    public static double CreditRate = 10.0; //между всеми одинаковое значение
}
```
Статические методы могут взаимодействовать со статическими данными:
```csharp
class Person
{
    public int Balance;
    public static double CreditRate = 10.0; //между всеми одинаковое значение
    public static void SetRate(double rate)
    {
        CreditRate = rate;
    }
    public static double GetRate => CreditRate;
}
```
>Обращение на нестатические члены внутри реализации статического члена приводит к ошибке! Так же как и применение ключевого слова this внутри статического метода, так как оно предполагает объект.

Возможно определять статический конструктор, который дает возможность безопасно устанавливать значения статических данных.

Пример:
```csharp
class Person
{
    public int Balance;
    public static double CreditRate; //между всеми одинаковое значение
    static Person() //статический конструктор
    {
        CreditRate = 9.0;
    }
}
```
Статический конструктор представляет собой спец конструктор для инициализации значений статических данных, если значения не известны на этапе компиляции. Среда CLR всегда все статические конструкторы вызывает перед первым использованием и затем не вызывает их заново для данного экземпляра класса.

Особенности статического конструктора:

- в классе может быть определен только один статический конструктор, его перегружать нельзя.

- статический конструктор не имеет модификатора доступа и не принимает параметры.

- статический конструктор выполняется только один раз вне зависимости от количества создаваемых объектов этого класса.

- конструктор вызывается когда создается экземпляр класса или перед доступом к первому статическому члену.

- статический конструктор выполняется перед любым конструктором уровня экземпляра.

Возможно определять статичкский класс. Такой класс нельзя создавать с использованием ключевого слова new, он может содержать только статические члены и поля данных. Такой класс не нуждается в выделении памяти. Определение статического класса:
```csharp
static class MyUtils
{
    private static string name = "User";
    public static void PrintHello()
    {
        WriteLine("Hello " + name + "!");
    }
}
```
Статические члены статических классов можно импортировать с помощью ключевого слова using. Пример импорта статических членов:
```csharp
using static System.Console;
```
Использование:
```csharp
WriteLine("Hello!");
```
>Следует ограничивать применение такого импорта во избежание неоднозначностей в коде.

## Модификаторы доступа

В языке C# типы (классы, интерфейсы, структуры, перечисления и делегаты) и их члены (свойства, методы, конструкторы и поля) описываются с использованием модификаторов, устанавливающими видимостью элементов для других частей приложения.

Модификаторы доступа C#
```csharp
Модификатор         Применение                  Смысл
public              Типы или члены типов        Не имеют ограничений доступа, доступен из внешних сборок
private             Члены типов или вложенные   Могут быть доступны только классу, где определены
protected           Члены типов или вложенные   Могут использоватся классом, который их определяет и любым дочерним классам.
internal            Типы или члены типов        Доступны только в рамках текущей сборки.
protected internal  Члены типов или вложенные   Такой элемент будет доступен внутри сборки, внутри определяющего класса и для всех наследников
```
По умолчанию все типы в языке C# устанавливаются как internal, а члены типов являются закрытыми private. 

То есть этот код:
```csharp
class MyClass
{
    MyClass() {}
}
```
Равносилен этому:
```csharp
internal class MyClass
{
    private MyClass() {}
}
```
А для того чтобы тип и его члены были доступны везде нужно сделать так:
```csharp
public class MyClass
{
    public MyClass() {}
}
```

Модификаторы доступа могут применятся к вложенному типу. Вложенный тип - это тип, объявленный внутри области видимости класса или структуры.
```csharp
public class MyClass
{
    private class MiniClass { }
}
```

## Принципы инкапсуляции



