# Обобщения

## Обобщенные методы
В языке C# есть возможность создания собственных обобщенных методов и специальных обобщенных типов. Построение специальных обобщенных методов представляет собой более развитую версию традиционной перегрузки методов. Перегрузка - действие по определению нескольких версий одного метода, которые отличаются друг от друга количеством или типами параметров.

Пример обобщенного метода:
```csharp
static void Swap<T>(ref T a, ref T b)
{
    T temp = a;
    a = b;
    b = temp;
}
```
Пример использования:
```csharp
int a = 10, b = 30;
Swap<int>(ref a, ref b);
string s1 = "one", s2 = "two";
Swap<string>(ref s1, ref s2);
```
Выведение параметра типа. При указании использования обобщенного метода можно и опускать указатие типа <>. Однако этот параметр необходимо каждый раз указывать, чтобы обозначить, что этот метод является обобщенным. Кроме того, это работает если метод принимает хотя бы один параметр, а методы могут быть без параметров.

Пример:
```csharp
static void Displ<T>()
{
    WriteLine($"{typeof(T)} - {typeof(T).BaseType}");
}
//использование
Displ<int>();
Displ<string>();
```
>Вызовы обобщенных методов нужно оставлять с оставленными <> типами заполнителей, так делать Swap(ref a, ref b); НЕНУЖНО!!!.

## Обобщенные структуры и классы
Построение обобщенной структуры и метода идентиченен.

Определение структуры:
```csharp
public struct MyPnt<T>
{
    public T XVal { get; set; }
    public MyPnt(T xval)
    {
        XVal = xval;
    }
    public override string ToString() => $"{XVal}";
    public void ResetMyPnt()
    {
        XVal = default(T);
    }
}
```
Здесь ключевое слово default используется для установки значения в стандартное значение. Т.е. числовые типы = 0, ссылочные типы - null, поля структур устанавливаются в 0 (типы значений) и в null (ссылочные типы).
Применение структуры:
```csharp
MyPnt<int> ip = new MyPnt<int>(10);
MyPnt<double> dp = new MyPnt<double>(5.5);
WriteLine($"{ip.XVal} {dp.XVal}");
ip.ResetMyPnt();
dp.ResetMyPnt();
WriteLine($"{ip.XVal} {dp.XVal}");
```

## Ограничение параметров типа
Платформа .NET позволяет использовать ключевое слово where для определения особых требований к отдельному парамутру типа.

С помощью ключевого слова this можно добавлять набор ограничений к конкретному параметру типа, которые компилятор проверит на этапе компиляции. Возможные ограничения:
```csharp
Ограничение                 Описание
where T : struct            Параметр типа <T> должен иметь класс System.ValueType в своей цепочке наследования (т.е. должен быть струтурой)
where T : class             Параметр типа <T> не должен иметь класс System.ValueType в своей цепочке наследования
where T : new()             Параметр типа <T> должен иметь стандартный конструктор. 
where T : ИмяБазКласса      Параметр типа <T> должен быть производным от класса, указанного как ИмяБазКласса
where T : ИмяИнтерфейса     Параметр типа <T> должен реализовать интерфейс, указанный как имя интерфейса. 
where T : unmanaged         Параметр типа <T> не может быть ссылочным типом и содержать члены ссылочного типа
where T : notnull           Параметр типа <T> 
```
>Можно задавать список из нескольсих интерфейсов, разделяя их запятыми.

Примеры использования:

```csharp
//класс является производным от object, в то время как содерж. в нем элементы должны иметь стандартный конструктор
public class MyGenClass<T> where T : new()
{
}
```
Конструкция where указывает параметр типа, подлежащий ограничению.
```csharp
//класс является производным от object, в то время как содерж. в нем элементы
//должны относится к классу, реализующему интерфейс IDrawable и поддерживать стандартный конструтор
public class MyGenClass<T> where T : class, IDrawable, new()
{
}
```
Для обобщенной коллекции с несколькими параметрами типа можно указывать уникальный набор ограничений для каждого параметра.
```csharp
//тип <T> должен расширять SomeBaseClass и иметь стандартный конструтор,
//в то время как тип <K> должен быть стукруторй и реализовывать обобщенный интерфейс IComparable
public class MyGenClass<T, K> where T : SomeBaseClass, new() where K : struct, IComparable<K>
{
}
```
Ключевое слово where допускается применять в обобщенных методах
```csharp
static void SwapStr<T>(ref T a, ref T b) where T : struct
{
    T temp = a;
    a = b;
    b = temp;
}
```
>В приведенном выше методе менять местами объкты string не допускается, т.к. это ссылочный тип.
