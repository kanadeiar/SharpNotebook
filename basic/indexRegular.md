# Регулярные выражения

В среде .NET встроен мощный инструмент для работы со строками, основанный на регулярныйх выражениях. Он применяется когда обычных методов для работы со строками не хватает. Регулярные выражения находятся в пространстве имен System.Text.RegularExpressions.

Сайт работы с регулярными выражениями: http://www.regexpal.com/ [перейти на него](http://www.regexpal.com/). 

Регулярные выражения обеспечивают:

1. Поиск в тексте по заданному шаблону.

2. Редактирование текста.

3. Замену всех одинаковых слов в сроке синонимичными или их удаление.

4. Выделение из строки необходимой части. 

5. Проверку соответствия строки заданному шаблону. Например, правильно ли введен email, телефон.

6. Извлечение из строки всех входящих подстрок, соответствующих шаблону регулярного выражения.

7. Формирование итоговых отчётов по результатам работы с текстом.

Пример определения регулярного выражения:
```csharp
Regex reg = new Regex(<тут ставить шаблон>);
```
Дополнительный параметр конструктора - опции поиска.

Регулярное выражение записывается в виде строкового литерала, причём перед строкой необходимо ставить символ @, который говорит о том, что строку нужно будет рассматривать и в том случае, если она будет занимать несколько строчек на экране. Однако символ @ можно не ставить, если в качестве шаблона используется шаблон без метасимволов.

Замечание. Если нужно найти какой-то символ, который является метасимволом, например, точку, можно это сделать, защитив ее обратным слэшем. То есть просто точка означает любой одиночный символ, а \. означает просто точку.

Примеры регулярных выражений:
```csharp
слово rus                                   @rus или rus
номер телефона в формате xxx-xx-xx 	        @\d\d\d-\d\d-\d\d или  @\d{3}(-\d\d){2}
номер автомобиля, etc: D123AF42RUS          @[A-Z]\d{3}[A-Z]{2}\d{2,3}RUS
адрес почты email                           @[A-Za-z]+[\.A-Za-z0-9_-]*[A-Za-z0-9]+@[A-Za-z0-9]+\.[A-Za-z]{2,6}
логин                                       @^[a-z][a-z\d]{1,9}$
```

## Некоторые метасимволы регулярных выражений
```csharp
Символ          Значение                Пример
[...]           Любой из символов       [a-z]
[^...]          Любой из символов       [^0-9]
.               Любой символ, кроме перевода строки или другого разделителя Unicode-строки
\w              Любой текстовый символ, не являющийся пробелом, символом табуляции и т.п.
\W              Любой символ, не являющийся текстовым символом
\s              Любой пробельный символ из набора Unicode
\S              Любой непробельный символ из набора Unicode. Обратите внимание, что символы \w и \S — это не одно и то же
\d              Любые ASCII-цифры. Эквивалентно [0-9]
\D              Любой символ, отличный от ASCII-цифр. Эквивалентно [^0-9]

{n,m}           Соответствует предшествующему шаблону, повторенному не менее n и не более m раз     s{2,4}
{n,}            Соответствует предшествующему шаблону, повторенному n или более раз s{1,}
{n}             Соответствует в точности n экземплярам предшествующего шаблона      s{2}
?               Соответствует нулю или одному экземпляру предшествующего шаблона; предшествующий шаблон является необязательным         Эквивалентно {0,1}
+               Соответствует одному или более экземплярам предшествующего шаблона      Эквивалентно {1,}
*               Соответствует нулю или более экземплярам предшествующего шаблона        Эквивалентно {0,}

|               Соответствует либо подвыражению слева, либо подвыражению справа (аналог логической операции ИЛИ)
(...)           Группирует элементы в единое целое, которое может использоваться с символами *, +, ?, | и т.п.; также запоминает символы, соответствующие этой группе для использования в последующих ссылках
(?:...)         Только группировка: группирует элементы в единое целое, но не запоминает символы, соответствующие этой группе

^               Соответствует началу строкового выражения или началу строки при многострочном поиске            ^Hello
$               Соответствует концу строкового выражения или концу строки при многострочном поиске              Hello$
\b              Соответствует границе слова, то есть соответствует позиции между символом \w и символом \W или между символом \w и началом или концом строки            \b(my)\b
\B              Соответствует позиции, не являющейся границей слов      \B(ld)\b
```

## Дополнительный параметр конструктора - опции поиска.
```csharp
Член                    Описание
Compiled                Регулярное выражение компилируется в сборку, улучшая выполнение
CultureInvariant        Предписывает игнорировать национальные установки строки.
ExplicitCapture         Модифицирует способ поиска соответствия, обеспечивая только буквальное соответствие.
IgnoreCase              Игнорирует регистр символов во входной строке.
IgnorePatternWhitespace Удаляет из строки не защищенные управляющими символами пробелы и разрешает комментарии, начинающиеся со знака фунта или хеша.
Multiline               Изменяет значение символов ^ и $ так, что они применяются к началу и концу каждой строки, а не только к началу и концу всего входного текста.
RightToLeft             Предписывает читать входную строку справа налево вместо направления по умолчанию — слева направо (удобно для некоторых азиатских и других языков, которые читаются в таком направлении).
Singleline              Специфицирует однострочный режим, в котором точка (.) символизирует соответствие любому символу.
```

Пример простого использования - проверка на соответствие строки формату:
```csharp
string s = "222.222.2222";
Regex regex = new Regex(@"[2|3]{3}\.[0-9]{3}\.\d{4}");
if (regex.IsMatch(s))
{
    Console.WriteLine("Строка соответствует формату!");
}
```
Еще простой пример:
```csharp
string email = "test@mail.ru";
string pattern = @"^(?("")(""[^""]+?""@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`\{\}\|~\w])*)(?<=[0-9a-z])@))" +
    @"(?(\[)(\[(\d{1,3}\.){3}\d{1,3}\])|(([0-9a-z][-\w]*[0-9a-z]*\.)+[a-z0-9]{2,17}))$";
if (Regex.IsMatch(email,pattern,RegexOptions.IgnoreCase))
{
    Console.WriteLine("Адрес электронной почты соответствует формату!");
}
```

Пример замены одного другим в строке с использованием регулярного выражения:
```csharp
string s = "    Мама    мыла    раму.     ";
string pattern = @"\s+"; //что заменить
string target = " "; //на что заменить
Regex regex = new Regex(pattern);
string result = regex.Replace(s, target);
Console.WriteLine($"Результат без лишних пробелов: '{result}'");
```

Пример нахождения всех слов, удовлетворяющих формату:
```csharp
string s = "Беспример примерыч, тупогубенький пример, у примера губа бела примерно примерная";
Regex regex = new Regex(@"пример(\w*)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
MatchCollection matches = regex.Matches(s);
if (matches.Count > 0)
{
    foreach (Match match in matches)
        Console.WriteLine(match.Value);
}
else
{
    Console.WriteLine("Совпадений не найдено");
}
```

Пример извлечения данных из строки с помощью регулярного выражения:
```csharp
string s = "12345  Тестов тест  Тестович авыаыв авыа Проба регулярки  3  шт.  1,99";
Regex regex = new Regex(@"^(?<id>\d+)\s+(?<description>.+)\s+(?<count>\d+)  шт\.\s+(?<number>\d+(,\d+)?)$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
var match = regex.Match(s);
if (match.Success)
{
    var id = int.Parse(match.Groups["id"].Value);
    var description = match.Groups["description"].Value;
    var count = int.Parse(match.Groups["count"].Value);
    var number = decimal.Parse(match.Groups["number"].Value);
    Console.WriteLine($"Результат: {id} '{description}' {count} {number}");
}
```

