# Объекты

## Структуры

В языке C# имеется составной тип данных, называется он структурой. Может в своем составе содержать обычные переменные и методы. Хорошо подходят для атомарных сущностей. Типы, которые могут содержать любое количество полей данных и членов, действующих на таких полях.
>Структуру можно считать легковесным типом классов, он поддерживает инкапсуляцию, но не может применяться для построения семейства взаимосвязанных классов. Когда нет потребности в наследовании, нужно применять структуры.

Структура:
```csharp
struct MyStruct
{
    public int a;
    MyStruct(int a) //конструктор
    {
        this.a = a;
    }
    public MyStruct Plus(MyStruct p) //метод
    {
        MyStruct y;
        y.a = a + p.a;
        return y;
    }
    public string ToString() //перегруженный метод получения строкового заначения
    {
        return $"<<a = {a}>>";
    }
}
```
Структуры не поддерживают один из основных принципов ООП - наследование. Назначение - объединить в себе небольшой объем данных.

Использование:
```csharp
MyStruct mys = MyStruct(1);
```

## Кортежи

Кортежи - легковесные структуры данных, содержащие множество полей. Кортежи используют тип данных ValueTurple, сберегая значительный объем памяти. Тип данных ValueTurple создает различные структуры на основе количества свойств для кортежа. Кроме этого каждому свойству кортежа можно назначать специфическое имя, что значительно повышает удобство работы с ним.
```csharp
(string, int) values1 = ("1", 4);
var values2 = ("1", 5);
```
>Для работы с кортежами понадобится установить NuGet пакет System.ValueTuple.

По умолчанию компилятор назначает каждому элементу кортежа имя ItemX.
```csharp
WriteLine(values1.Item1);
WriteLine(values1.Item2);
```
Каждому элементу кортежа можно назначить свое имя:
```csharp
(string Fisrt, int Second) values1 = ("1", 4);
var values2 = (First : "1", Second : 5);
```
Теперь можно обращаться как по имени так и способом по умолчанию.
```csharp
WriteLine(values1.Fisrt);
WriteLine(values1.Second);
WriteLine(values1.Item1);
WriteLine(values1.Item2);
```
>Специальные имена однако, существуют только на этапе компиляции, не доступны во время исполнения с использованием рефлексии.

В версии C# 7.1 появилась возможность выводить имена свойств кортежей при определенных обстоятельствах.
```csharp
var myCort = new {one = "super", two = 5};
var myTwoCort = (myCort.two, myCort.one);
WriteLine($"{myTwoCort.one} {myTwoCort.two}");

int count = 5;
string label = "Colors used in the map";
var pair = (count, label);
```

Кортежи удобно применять как вертаемое значение от методов:
```csharp
static (string a, int b) getTuple()
{
    return ("one", 5);
}
```
Вызов такого метода (второй вызов - деконструирование кортежа, с целью применения по одному):
```csharp
var myData = getTuple();
WriteLine(myData.a);
WriteLine(myData.b);
var (on, tw) = getTuple();
WriteLine(on);
WriteLine(tw);
```

Использование отбрасывания с кортежами - когда одна из переменных не нужна - нужно вставить пустым заполнителем _:
```csharp
var (one, _) = getTuple(); 
WriteLine($"{one}");
```

Кортежи применяются для деконструирования специальных типов. Пример такого типа:
```csharp
struct Super
{
    public int a;
    public bool b;
    public (int aC, bool bC) Deconstruct() => (a, b);
}
```
Применение:
```csharp
Super super = new Super {a = 10, b = true};
var (aVal, bVal) = super.Deconstruct();
WriteLine(aVal);
WriteLine(bVal);
```
Начиная с версии C# 7.3 типы кортежей поддерживают операторы == и !=.
```csharp
var left = (a: 5, b: 10);
var right = (a: 5, b: 10);
Console.WriteLine(left == right); // displays 'true'
```


## Объекты 

Класс - это будущий объект. В классе, как и в структуре, мы поисываем будущий объект. Для создания объекта нужно сначало объявить переменную - ссылку на объект, а потом попросить выделить место в памяти для объекта. Все объееты относятся к ссылочным типам данных. 

Объект создается в два этапа - сначала создается ссылка на объект, а затем идет инициализация, то есть создается объект в куче. За освобождение памяти можно не беспокоится - об этом позаботится автоматический сборщик мусора.

Объявление класса:
```csharp
class MyClass
{
}
```

Создание объекта класса MyClass:
```csharp
MyClass myObj = new MyClass();
```

## Статические и нестатические поля класса 

Статическое поле принадлежит классу, или всем объектам класса.
Нестатическое поле принадлежит только объекту класса, для доступа к нему нужно создавать объект.
```csharp
MyClass.stat_variable = 10;
MyClass myclass = new MyClass();
myclass.variable = 20;
Console.WriteLine($"{MyClass.stat_variable} {myclass.variable}"); // 10 20
ReadKey();
```


# Продвинутое

## Перегрузка операций

