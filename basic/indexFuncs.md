# Методы (функции, модификаторы и расширяющие методы)

Функции и методы - технически это одно и тоже, только методы принадлежат классу, а функции - нет. Метод описывается внутри класса. Что какое класс написано в другом разделе, не здесь. Методы можно объявлять статическими, тогда он принадлежит классу, а для его вызова не нужно создавать объект класса.

То есть просто статический метод и есть "функция". Может вызыватся напрямую, не создавая экземпляра класса.

```csharp
модификаторы  тип вертаемого   имя     параметры
    public static void MyFunc(str string)
    {
        ...         тело метода
    }  
```

## Вызов метода.
Круглые скобки после названия - это значит метод.
```csharp
class My Class
{
    static void MyFunc() //вызываемый метод
    {
        Console.ReadKey();
    }
    static void Main()
    {
        MyFunc(); //вызов
    }    
}
```
## Вертаемое значение функции (метода).
Вместо void поставить тип - тогда через return можно вертать значения.
```csharp
static int MyFunc()
{
    return 1;
}
```
Вызов:
```csharp
    int i = MyFunc();
```
## Вертаемые значения и параметры, сжатые до выражения
В языке C# 6 появились члены, сжатые до выражений, которые сокращают синтаксис написания однострочных методов.
```csharp
static int Add(int x, int y) => x + y; //лямбда - операция
```

## Модификаторы параметров методов
```csharp
Монификатор параметра       Смысл
(отсутствует)               Передается по значению, т.е. вызываемый метод получает копию исходных данных.
out                         Выходным параметрам должны присваиваться значения внутри вызваемого метода, следовательно, они передаются по ссылке.
ref                         Передача по ссылке. Значение может быть необязательно изменено в вызываемом методе, так как данные передаются по ссылке.
in                          Аргументы in не могут быть изменены вызывающим методом.
params                      Переменное количество параметров как единственный логический параметр. В конструкции метода в параметрах должен стоять на последнем месте.
```
## Модификатор передачи по ссылке ref
Передача параметра в метод по ссылке - ref. Ссылочные параметры необходимы, когда нужно методу разрешить манипулировать с различными элементами данных и изменять из значения, которые есть вы вызывающем коде. Ссылочные параметры должны быть инициализованы перед предачей методу, так как нужно передавать ссылку на существующее значение.
```csharp
static void PlusPlus(ref int a)
{
    a++;
}
```
## Модификатор ссылки выходных out
Передача по ссылке параметра без опязательной первоначальной инициализации - out. Переменным в таком методе всегда должны быть присвоены допустимые значения.
```csharp
static void PlusPlus(out int a)
{
    a = 1;
}
```
Начиная с версии C# 7 больше нет нужны объявлять параметры out до их применения. 

Пример:
```csharp
PlusPlus(out int a)
```
>Отбрасывание можно применять подставляя вместо парметров "_". Его можно применять с парметром out, кортежами, сопоставлении с образцом.
```csharp
PlusPlus(out int _)
```
> Можно применять, например, если нужно проверить что строка имеет допустимый формат
## Модификатор params
В языке C# поддерживаются массивы параметров с использованием ключевого слова params, которое позволяет передавать методу переменное количество идентично типизированных параметров (или классов, связанных одним наследованием) в виде единственного логического параметра. Плюс аргументы, помеченные ключевым словом этим могут обрабатываться, когда вызывающий код передает типизированный массив или список параметров через запятую.

C# требует чтобы параметр params был только один и был последний в списке параметров.

Пример сумма элементов:
```csharp
static int Calc(params int[] vals)
{
    int sum = 0;
    if (vals.Length == 0)
        return sum;
    foreach (int el in vals)
    {
        sum += el;
    }
    return sum;
}
```
Пример вызова:
```csharp
//список параметров через запятую
int suu = Calc(1, 4, 6, 8);
//в параметрах - массив
int[] data = { 1, 2, 3};
int stt = Calc(data);
//без параметров - ноль
int srr = Calc();
```
## Необязательные параметры
В методах могут быть необязательные параметры, это позволяет вызывать метод, опуская ненужные аргументы, при условии, что подходят указанные для них стандартные значения.

Пример:
```csharp
static void Data(int one, int two = 1)
{
    Console.WriteLine(one);
    Console.WriteLine(two);
}
```
Теперь вызов может быть двух видов:
```csharp
Data(2,3);
Data(2);
```
>Необязательные параметры должны всегда помещатся в конец сигнатуры метода, во избежание неоднозначности.
## Именованные параметры
Полезным средством C# являются именованные параметры. Именованные аргументы позволяют вызывать метод с указанием значений парметров в желаемом порядке. Вместо передачи по позициям можно указывать имя каждого аргумента : значение.

Пример:
```csharp
Data(one: 2, two: 3);
Data(two: 3, one: 1);
```
Пример смешанного вида:
```csharp
Data(2, two: 3);
```

## Перегрузка методов.
Методы с одинаковыми именами, но разными параметрами являются перегруженными методами.
```csharp
static void Pause()                    
{
    Console.ReadKey();
}
static void Pause(int i)   
{
    Console.WriteLine("fdddfffggffg" + i.ToString());
    Console.ReadKey();
}
static void Pause(string s)
{
    Console.WriteLine(s);
    Console.ReadKey();
}
```
## Локальные функции
Одно из клевых фич языка C# 7 является возможность создания методов (проще назвать локальную функцию) внутри методов. Новое средство официально носит название "локальные функции", хотя так же и остается локальным методом внутри метода.

Пример:
```csharp
PrintBox();
void PrintBox() => WriteLine("Box");
```
Улучшение в C# 8. Модификатор static. Можно добавлять ключевое слово statiс для гарании что локальная функция не захватывает и не ссылается на переменные в области ее видимости.
```csharp
int var = 25;
PrintBox(45);
static void PrintBox(int var) => WriteLine($"Box {var}"); // Box 45
```
            
## Процедурное программирование.
Программирование, при котором все выполняемые операторы собираются в подпрограммы, в более крупные еденицы кода.
Исходный код:
```csharp
static void Main()
{
    Console.WriteLine("Введите вещественное число a:");
    double a = double.Parse(ReadLine());
    a = Math.Pow(a, 3);
    Console.WriteLine($"a в степени 3 равено {a}");
    ReadKey();
}
```
Можно выделить операции ввода чисел, логической обработки и вывода.
```csharp
static double InputDouble()
{
    Console.WriteLine("Введите вещественное число a:");
    return double.Parse(ReadLine());
}
static double CalcPowThreee(double a)
{
    a = Math.Pow(a, 3);
}
static void WriteDoubleToConsole(double a)
{
    Console.WriteLine($"a в степени 3 равено {a}");
}
static void Main()
{
    double a = InputDouble();
    a = CalcPowThreee(a);
    WriteDoubleToConsole(a);
    ReadKey();
}
```
>Взаимозаменяемые функции можно заменять другими. Умение представить программу в виде подпрограмм является очень важным умением программиста.








# Продвинутое

## Расширяющие методы

В языке C# есть концепция расширяющих методов, которая позволяет добавлять новые метод или свойства к классу либо структуе, не модифицируя исходный код. Можно модифицировать типы, не создавая подклассов и не изменяя код типа напрямую. Но однако новая функциональность будет доступна только тогда, когда есть ссылка на расширяющие методы.

Расширяющие методы должны быть статическими и определены внутри статического класса.

Все расширяющие методы должны помечатся ключевым словом this в качестве модификатора первого параметра заданного метода.

>Каждый расширяющий метод может иметь множество параметров, но только первый параметр разрешено помечать посредством this. Доп параметры будут трактоватся как нормальные входные параметры.

Пример статического класса с определениями расширяющих методов:
```csharp
static class MyExtentions
{
    public static int AddTwo(this int i) //расширяющий метод
    {
        return i += 2;
    }
    public static int AddX(this int i, int x) //расширяющий метод с параметром
    {
        return i += x;
    }
}
```
Использование:
```csharp
int myInt = 1234;
myInt.AddTwo();
myInt.AddX(12);
```
В языке C# можно расширять классы новой функциональностью через расширени интерфейса, который этот класс реализует. То есть если класс реализует интерфейс IEnumerable<T> и мы его расширим, то класс получит новые члены.

Пример расширяющего класса - расширяет интерфейс IEnumerable<T>:
```csharp
static class MyExtentions
{
    public static void WriteNBeep(this System.Collections.IEnumerable iterator)
    {
        foreach (var item in iterator)
        {
            WriteLine(item);
            Beep(500, 500);
        }
    }
}
```
Пример использования:
```csharp
//реализует интерфейс IEnumerable
List<int> myInts = new List<int> { 10, 11, 12, 1, 5 };
myInts.WriteNBeep();
ReadKey();
```
Пример расширения - добавление элементов в коллекцию:
```csharp
public static class MyExtensions
{
    public static T AddTo<T>(this T self, ICollection<T> coll)
    {
        coll.Add(self);
        return self;
    }
}
//использование
    var list = new List<int>();
    list.Add(1);
    10.AddTo(list).AddTo(list);
    foreach (var el in list)
        Console.Write($"{el} ");
```
Пример - перевод строки в логический тип данных, если не сможет сконвертировать, то вернет ложь:
```csharp
public static class MyExtensions
{
    public static bool TryBool(this string self)
    {
        return Boolean.TryParse(self, out var res) && res;
    }
}
//использование
    bool b = "True".TryBool();
    Console.WriteLine($"{b}");
```
Пример - проверка что существует элемент среди множества
```csharp
public static class MyExtensions
{
    public static bool IsOneOf<T>(this T self, params T[] elems)
    {
        return elems.Contains(self);
    }
}
//использование
    var arr = new[] {1,2,5,6};
    bool b2 = 2.IsOneOf(arr);
    Console.WriteLine($"{b2}");
```







## Ссылочные локальные переменые и возвращаемые ссылочные значения
В языке C# в версии 7 появилась возможность применнения и возвращения ссылок на переменные, определенные где угодно. 

Например когда интересует не значение в массиве, а именно ссылка на позицию в массиве. Новые возможности позволяют легко так делать. Вместо return нужно ставить return ref.

Пример метода:
```csharp
public static ref string Sample(string[] strArr, int ind)
{
    return ref strArr[ind]; //вертает ссылку на позицию в массиве, а не хранящееся в ней значение
}
```
Пример вызова метода:
```csharp
ref var retVal = ref Sample(strArr, 0);
```
После этого любые изменения значения приведут к изменению и в массиве.

Но:
> Результаты стандартного метода не могут присваиваться локальной переменной ref.
> Локальную переменную внутри метода ref нельзя возвращать как локальную переменную ref.
> Это не работает с асинхронными методами.

В C# дополнительно появился модификатор ref readonly, который запрещает изменять полученное значение по ссылке.
```csharp
public static ref readonly string Sample(string[] strArr, int ind) //модификатор ссылка на значение которое только для чтения
{
    return ref strArr[ind]; //вертает ссылку на позицию в массиве, а не хранящееся в ней значение
}

ref readonly var retVal = ref Sample(strArr, 0);
```



