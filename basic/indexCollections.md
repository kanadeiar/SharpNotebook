# Коллекции

Хотя базовые массивы могут быть удобны для управления небольшими объектами дланных фиксированного размера, есть немало случаев, когда требуются более гибкие структуры данных, такие как динамически расширающийся и сокращающийся контейнер или контейнер, который может хранить только объекты, удовлетворящий заданному критерию (базовый класс, интерфейс). Обычный массив имеет фиксированный размер.
>Изменение размера массива с помощью обобщенного метода Resize()<T> копирует данные в новый объект массива и уже его вертает
    
Классы коллекций поставляемые в нескольких пространствах имен, таких как System.Collections и System.Collections.Generic, помогают преодолель эти ограничения. Классы коллекций построены с возможностью динамического изменения своих размеров на лету по мере вставки либо удаления из них элементов.

Класс коллекций может принадлежать одному из двух классов:

- Необобщенные коллекции System.Collections.

- Обобщенные коллекции System.Collections.Generic.

Признаком обобщенного элемента является наличие "параметра типа", обозначаемого с помощью угловых скобок (например List<T>).

## Необобщенные коллекции
Для работы с этими коллекциями требуется подключить пространство имен System.Collections.

Некоторые полезные классы это этого пространства имен System.Collections.
```csharp
Класс       Описание, некоторые реализуемые интерфейсы
ArrayList   Коллекция с динамически изменяемым размером, выдающая объекты в последовательном порядке
            Интерфейсы - IList, ICollection, IEnumerable, ICloneable
BitArray    Управляет компактным массивом битовых значений, которые булевские (1 и 0)
            Интерфейсы - ICollection, IEnumerable, ICloneable
Hashtable   Коллекция пар "Ключ - значение", основанная на основе хеш-кода ключа
            Интерфейсы - IDictionary, ICollection, IEnumerable, ICloneable
Queue       Стандартная очередь объектов, работающую по принципу FIFO (первый вошел - первый вышел)
            Интерфейсы - ICollection, IEnumerable, ICloneable
SortedList  Коллекция пар "ключ - значение", отсортированная по ключу и доступных по индексу
            Интерфейсы - IDictionary, ICollection, IEnumerable, ICloneable
Stack       Представляет собой стек из объектов по принципу LIFO (последний вошел - первый вышел), поддерживается функциональноть заталкивания и выталкивания, а также считывания
            Интерфейсы - ICollection, IEnumerable, ICloneable
```
Описание основных интерфейсов:
```csharp
Интерфейс   Описание
ICollection Определяет характеристики (размер, перечисление и безопасность к потокам) для всех необобщенных типов коллекций
ICloneable  Возвращает копию самого себя
IDictionary Позволяет необобщенной коллекции представлять свое содержимое в виде пар "ключ-значение"
IEnumerable Объект, реализующий интерфейс Ienumerator
IEnumerator Делает возможной итерацию в стиле foreach по элементам коллекции
Ilist       Обеспевивает поведение добавления, удаления и индексиврования элементов в последовательном списке объектов
```

Пример:
```csharp
ArrayList list = new ArrayList();
list.AddRange(new string[] {"1", "bool", "affff", "one"} );
Console.WriteLine(list.Count);
list.Add("third");
list.Sort();
foreach (var v in list) 
    Console.WriteLine(v);
```

Элементы класса c реализованным интерфейсом IEnumerator<T>, могут быть перебраны без foreach, напрямую методами:
```csharp
IEnumerator<int> inum=posNums.GetEnumerator();
while (inum.MoveNext()) Console.WriteLine(inum.Current);
```

>Такие коллекции следует ограниченно применять в приложениях, так как состоят из ссылки на объекты общего для всех типа object и за типом содержахися элементов в списке приходится ОЧЕНЬ БДИТЕЛЬНО следить программисту.

## Специальные коллекции System.Collection.Specialized
В загашнике библиотек .NET есть специальные коллекции:
```csharp
Класс               Описание
HybridDictionary    Реализует интерфейс IDictionary за счет применения ListDictionary, пока коллекция мала и переключается на Hashtable, когда коллекция вырастет
ListDictionary      Удобен, когда необходимо управлять небольшим количеством элементов, которые могут изменяться со времнем
StringCollection    Оптимальный способ для управления крупными коллекциями строковых данных
```
>Кроме этого есть еще два: System.Collections.ObjectModel - для обобщений и System.Collections.Concurrent - для многопоточности.

Применение необобщенных коллекций может привести к ряду проблем:

- код может быть с низкой производительностью, особщенно на числовых данных. Причина - применение простого механизма упаковки/распаковки для простых типов.

- большинство классов не являются безопасными в отношении типов, т.к. они были созданы для работы с Sysyem.Object, и могут содержать рядом все что угодно. Из этого возникает необходимость создания специальных классов - надстроек над стандартной коллекцией.


## Параметры обобщенных типов
Пара угловых скобок с буквой или другой лексемой внутри - параметры типа, но можно проще - заполнители. Конструкция <T> - можно ее читать как "типа T". То есть IEnumerable<T> - перечисление типа T.
    
Параметры типа для обобщенных классов и структур.
```csharp
List<int> listI = new List<int>();
```
Параметры типа для обобщенных членов.
```csharp
int[] arr = {10, 1, 5, 7};
Array.Sort<int>(arr);
```
Параметры типов для обобщенных интерфейсов.
```csharp
public class MyClass : IComparable<MyClass>
{
    public int Id { get; set; }
    int IComparable<MyClass>.CompareTo(MyClass obj)
    {
        if (this.Id > obj.Id)
            return 1;
        if (this.Id < obj.Id)
            return -1;
        else
            return 0;
    }
}
```


## Обобщенные коллекции
Для работы с этими коллекциями требуется подключить пространство имен System.Collections.Generic, в этом же пространстве имен содержатся средства обобщения. 

Вместо построения уникальных классов, которые могут хранить объекты людей, автомобилей, и целые числа, можно задействовать класс обобщенных коллекций и указать тип хранимых элементов. Обобщенным образом могут быть записаны только классы, структуры, интерфейса и делегаты, но не перечисления. 

Вот преимущества обобщенных контейнеров по сравнению с их необобщенными аналогами:

- Обобщения обеспечивают лучшую производительность, т.к. лишены накладных расходов по упаковке/распаковке, когда хранят типы значений.

- обобщения безопасны к типам, потому что могут содеражть только объекты указанного типа.

- обобщения значительно сокращают потребность в специальных типах коллекций, поскольку при создании обобщенного контейнера указывается "вид типа".

Некоторые полезные классы это этого пространства имен System.Collections.Generic
```csharp
Класс                   Описание, некоторые реализуемые интерфейсы
Dictionary<TKey,TValue> Обобщенная коллекция ключей и значений
                        Интерфейсы - ICollection<T>, IDictionary<TKey,TValue> IEnumerable<T>
LinkedList<T>           Двусвязный список
                        Интерфейсы - ICollection<T>, IEnumerable<T>
List<T>                 Последовательный список элементов с динамически изменяемым размером
                        Интерфейсы - ICollection<T>, IEnumerable<T>, IList<T>
Queue<T>                Обобщенная реализация списка, механизм FIFO - первый вошел - первый вышел
                        Интерфейсы - ICollection, IEnumerable<T>
SortedDictionary        Обобщенная реализация сортированного множества пар "Ключ-значение"
<TKey,TValue>           Интерфейсы - ICollection<T>, IDictionary<TKey,TValue> IEnumerable<T>
SortedSet<T>            Коллекция объектов, поддерживаемых в сортированном порядке без дубликатов
                        Интерфейсы - ICollection<T>, IEnumerable<T>, ISet<T>
Stack<T>                Обобщенная реализация списка, механизм LIFO - последний вошел - первый вышел
                        Интерфейсы - ICollection, IEnumerable<T>
```

Описание основных интерфейсов:
```csharp
Интерфейс               Описание
ICollection<T>          Определяет характеристики (размер, перечисление и безопасность к потокам) для всех необобщенных типов коллекций
IComparer<T>            Определяет способ сравнения объектов
IDictionary<TKey,TValue>Позволяет необобщенной коллекции представлять свое содержимое в виде пар "ключ-значение"
IEnumerable<T>          Объект, реализующий интерфейс IEnumerator<T>
IEnumerator<T>          Делает возможной итерацию в стиле foreach по элементам коллекции
Ilist<T>                Обеспевивает поведение добавления, удаления и индексиврования элементов в последовательном списке объектов
ISet<T>                 Предоставляет базовый интерфейс для абстракции множеств
```

## Инициализация коллекций
Синтаксис инициализации коллекций позволяет наполнять многие контейнеры элементами с применением синтаксиса, похожего на тот, который используется для наполнения базовых массивов.
```csharp
int[] myArr = {0, 1, 2}; //стандартный массив
List<int> myList = new List<int> {1, 2, 3, 5}; //обобщенный List<>
ArrayList myArrList = new ArrayList {1, 3, 4, 2}; //необобщенный с числовыми данными
```
Синтаксис инициализации коллекции смешанный с синтаксисом структур и классов.
```csharp
List<Toy> myToys = new List<Toy>
{
    new Toy { X = 1 },
    new Toy { X = 5 },
};
foreach (Toy el in myToys)
{
    WriteLine(el);
}
```

## Класс List<T>
Использование:
```csharp
static void Use()
{
    List<Per> pers = new List<Per>
    {
        new Per {X = 1},
        new Per(),
    };
    WriteLine(pers.Count);
    pers.Insert(1,new Per {X = 99});
    Per[] arrPers = pers.ToArray();
    foreach (var el in arrPers)
        WriteLine(el.X);
}
```

## Класс Stack<T>
Механизм работы - последний вошел - первым вышел (LIFO). В нем определены Push() и Pop().
    
Использование:
```csharp
static void UseStack()
{
    Stack<Per> stack = new Stack<Per>();
    stack.Push(new Per{X = 1});
    stack.Push(new Per(1));
    WriteLine($"First is = {stack.Peek().X}");
    WriteLine($"Pop 1 = {stack.Pop().X}");
    WriteLine($"Pop 2 = {stack.Pop().X}");
    //стек пуст
}
```

## Класс Queue<T>
Механизм работы - первый вошел - первый вышел (FIFO). Dequeue() Удаляет и возвращает объект из начала. Enqueue() добавляет объект в конец. Peek() возвращает объект из начала, не удаляя его.
    
Использование:
```csharp
static void UseQueue()
{
    Queue<Per> queue = new Queue<Per>();
    queue.Enqueue(new Per(1));
    queue.Enqueue(new Per{X = 1});
    WriteLine($"Peek = {queue.Peek().X}");
    WriteLine($"Deq 1 = {queue.Dequeue().X}");
    WriteLine($"Deq 2 = {queue.Dequeue().X}");
    //очередь пуста
}
```

## Класс SortedSet<T>
Этот класс полезен тем, что при вставке или удалении элементов он автоматически сортирует элементы в наборе. Но классу нужно сообщить, как должны элементы будут отсортированы путем передачи конструктору в качестве аргумента объекта, который реализует интерфейс IComparer<T>.

Использование:
```csharp
class SortInt : IComparer<Per>
{
    public int Compare(Per per1, Per per2)
    {
        return per1.X.CompareTo(per2.X);
    }
}
static void UseSortedSet()
{
    SortedSet<Per> setPer = new SortedSet<Per>(new SortInt())
    {
        new Per {X = 4},
        new Per(1),
        new Per(9),
    };
    setPer.Add(new Per(-100));
    setPer.Add(new Per {X = 900});
    foreach (var el in setPer)
        WriteLine(el.X);
}
```

## Класс Dictionary<TKey, TValue>
Эта обобщенная коллекция позволяет хранить любое количество объектов, на которые можно ссылаться через уникальный ключ. То есть вместо получение элемента из List<T> по числовому идентификатору нужно применять какой-либо другой ключ. Допускается заполнять коллекцию с использованием синтаксиса инициализации коллеций. При создании объекта в качестве аргументов передаются тип ключа(TKey) и тип внутренних объектов (TValue).

Использование:
```csharp
private static void UseDict()
{
    Dictionary<string, Per> dicts = new Dictionary<string, Per>
    {
        {"one", new Per(1)},
        {"two", new Per{X = 5}},
    };
    WriteLine($"one => {dicts["one"].X}");
    WriteLine($"two => {dicts["two"].X}");
}
```
Еще пример:
```csharp
var dict = new Dictionary<char, string>
{
    ['r']="Roman",
    ['i']="Ivan",
    ['v']="Victor",
};
//еще пример
var dict = new Dictionary<char, string>
{
    {'r',"Roman"},
    {'i',"Ivan"},
    {'v',"Victor"},
};
```




# Продвинутое

## Класс ObservableCollection<T>
Этот класс удобен своей возможностью информировать внешние объекты, когда его содержимое каким-то образом изменяется. Он поддерживает событие по имени CollectionChanged. Указанное событие будет инициироватся каждый раз, когда вставляется новый элемент, удаляется, перемещается, модифицируется вся коллекция целиком.
    
Использование:
```csharp
private static void UseObserv()
{
    ObservableCollection<Per> pers = new ObservableCollection<Per>
    {
        new Per(1),
        new Per {X = 3},
    };
    pers.CollectionChanged += pers_CollChanged;
    pers.Add(new Per(6));
    pers.RemoveAt(0);
}

static void pers_CollChanged(object sender, 
    NotifyCollectionChangedEventArgs e)
{
    WriteLine($"\nActions = {e.Action}");
    if (e.Action == NotifyCollectionChangedAction.Add)
    {
        Write("New Items:");
        foreach (var el in e.NewItems)
        {
            Write($"{el.ToString()} ");
        }
    }
    if (e.Action == NotifyCollectionChangedAction.Remove)
    {
        Write("Deleted Items:");
        foreach (var el in e.OldItems)
        {
            Write($"{el.ToString()} ");
        }
    }
}
```




