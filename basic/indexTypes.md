# Тип данных

В C# переменные делятная на значимые и ссылочные. Значимые хранят значения, а ссылочные - ссылки на ячейки, в которых уже содержатся значения.

Значимая переменная хранит значение определенного типа, например 5.

Переменная ссылочного типа содержит ссылку на значение в общей памяти, которая называется "Куча". По этой ссылке хранятся данные.

При обозначении переменной можно использовать как тип .NET, так и псевдоним C#.

## Целочисленные типы:

Тип       Разрядность в битах        Диапазон представленных чисел

byte      8                          0 — 255                    Есть совместимость c CLS

sbyte     8                          -128 — 127

short     16                         -32 768 — 32 767           Есть совместимость c CLS

ushort    16                         0 — 65 535

int       32                         -2 147 483 648 — 2 147 483 647     Есть совместимость c CLS

unit      32                          0 — 4 294 967 295

long      64                         -9 223 372 036 854 775 808 — 9 223 372 036 854 775 807 Есть совместимость c CLS

ulong     64                         0 — 18 446 744 073 709 551 615

## Вещественные типы:

float           32 бита     диапазон значение от 5E-45 до  3,4E+38      Есть совместимость c CLS

double          64 бита     диапазон значений от 5E-324 до 1,7E+308     Есть совместимость c CLS

## Точный вещественный тип:

decimal     128 бит      Диапазон значений от 1Е-28 до 7.9Е+28      Есть совместимость c CLS

## Символы:
Char - Совместимость с CLS - System.Char  - от U+0000 до U+ffff   -  16 бит

Представлены 16 - разрядным кодом Unicode. Для работы с этим типом лужит класс Char.

## Строки:
String - Есть совместимость c CLS - Sytem.String - ограничен объемом памяти - набор символов Unicode.

Строка в C# является ссылкой на массив символов char. Представлены классом string или String.

Разбор значений из строковых данных.
```csharp
bool b = bool.Parse("True");
```

## Логический тип:

bool - Совместимость с CLS - System.Boolean - true или false

В переменной этого типа хранится значение "Истина" или "Ложь".

## Базовый тип 

Object - Есть совместимость c CLS - может хранится любой тип данных - базовый класс для всех типов мира .NET

## Числовые литералы 

По умолчанию число с плавающей точкой трактуется как double. Чтобы объявить значение типа float, применяйте суффикс f или F к неформатированному числовому значению (5.3F), а чтобы объявить значение типа decimal, применяйте суффикс m или м к числу с плавающей точкой (300.5М). И, наконец, неформатированные целые числа по умолчанию относятся к типу int. Чтобы получить значение типа long, понадобится снабдить его суффиксом 1 или L (4L).

В версии C# 7 введен новый литерал двоичных значений, для, например битовых масок:
```csharp
int i = 0b0001_0000; //это число 16
```

В версии C# 7 введен разделить групп цифр в виде символа подчеркивания (_) для типов данных int, long, decimal, double.
```csharp
long i = 123_345_789L;
```

## Значение переменной по умолчанию
Все внутренние типы данных поддерживают стандартный конструктор. Это средство позволяет создавать переменную, используя ключевое слово new.
```csharp
int mylnt = new int();
```
переменные типа DateTime устанавливаются в 1/1/0001 12:00:00 AM;

объектные ссылки (включая переменные типа string) устанавливаются в null.

Литерал default является новым средством в версии C# 7.1, которое позволяет присваивать переменной стандартное значение ее типа данных.
```csharp
int mylnt = default;
```
## Неявно типизированные переменные:

Тип для переменной выводит компилятор на этапе компиляции в общий промежуточный код. Когда вы поступаете подобным образом, компилятор будет автоматически выводить лежащий в основе тип данных на основе начального значения, используемого для инициализации локального элемента данных

```csharp
var a = 999;
var myBool = bool;
var myString = "Time";
```
С использованием ключевого слова var связаны разнообразные ограничения. Прежде всего, неявная типизация применима только к локальным переменным внутри области видимости метода или свойства. Использовать ключевое слово var для определения возвращаемых значений, параметров или данных полей в специальном типе не допускается.

Неявная типизация локальных переменных дает в результате строго типизированные данные.

## Преобразование типов

Существует неявное и явное преобразование типов при вычислении выражений. Явное приведение - от стремным к крутым. Принудительное (явное) приведение - от более крутых к стремным.

```csharp
long a = 10000000;
int b = (int)a; //явное преобразование типов
a = b; //неявное преобразование типов
int b = Convert.toInt32(a); //преобразование типа - лучше всего использовать
int b = int.Parse("123"); //парсинг строки
```

## Сужение и расширение типов
Из-за того, что максимальное значение для типа short (32 767) гораздо меньше максимального значения для типа int (2 147 483 647), компилятор неявно расширяет каждое значение short до типа int. Формально термин расширение используется для определения неявного восходящего приведения, которое не вызывает потерю данных.

Из-за того, что язык C# создавался с расчетом на безопасность в отношении типов, будет получена ошибка на этапе компиляции если сделать обратную операцию - из типа long в тип int.

Если нужно проинформировать компилятор о том, что вы готовы мириться с возможной потерей данных из-за сужающей операции, тогда потребуется применить явное приведение.
```csharp
long a = 10000000;
int b = (int)a; //преобразование типа - сужение
long c = b; //преобразование типа - расширение
```





# Продвинутое

## Иерархия классов для типов данных

Object базовый класс для Type, String, Array, Exception, Delegate и ValueType. 

А ValueType является базым классом для Boolean, Uint16, Int16, Decimal, Byte, Char, Void, DateTime, Single, Int64, SByte и пр. базовые типы., перечисления и структуры.

Так как в Object определены базовые ToString(), Equals(), GetHashCode(), общие для всех типов из библиотеки .NET. Многие числовые типы являются производыми от ValueType, и в свою очередь размещаются в стеке, имеют ограниченное время жизни и эффективны. Другие же типы, напрямую производные от Object, размещаются не в стеке, а в куче, с автоматической сборкой мусора.

## Члены числовых типов данных

Все члены числовых типов данных поддерживают свойства MaxValue и MinValue, это максимальное и минимальное значение. В дополнение к этим свойствам, каждый тип может иметь свои индивидуальные свойства - так, double - бесконечная малая (эпсилон) и бесконечно большие. 

## Члены булевского типа

Имеет свойства TrueString и FalseString, выделяют строки True & False.

## Члены символьного типа

Текстовые данные - это System.String & System.Char оба основаны на Unicode. string - непрерывное множество символов, а char - одиночный символ. У типа данных Char имеется очень большой набор свойств для определения является ли данный символ цифрой, букровй, знаком пунктуации и т.п.
```csharp
char.IsDigit('a');
char.IsLetter('Hello There', 5);
char.IsPunctuation('?');
```

Разбор значений из строковых данных продвинутым спомобом:
```csharp
if (bool.TryParse("True", out bool b)) //не вызывает исключение если не может разорбать значение
{
    Console.WriteLine($"Значение b = {b}");
}
else
{
    Console.WriteLine("Неудача преобраования типа");
}
```
## Члены дато временного типа

Тип DateTime содержит данные, содержащие значение даты (год, месяц, день) и времени. Структура TimeSpan - позволяет работать с типом даты времени различным спообом.
```csharp
DateTime dt = new DateTime(2019, 1, 1); - год месяц день
dt.Day   dt.DayOfWeek - текущий день и день недели
TimeSpan ts = new TimeSpan(2, 20, 0); - часы минуты секунды
ts.Substract(new TimeSpan(0, 15, 0)); - прибавить 15 минут
```

## Тип огромного числового значения
Для работы с этим типом необходимо добавить ссылку на сборку System.Numerics.dll. 

Пример использования:
```csharp
using System.Numerics;

BigInteger bi = BigInteger.Parse("999999999999999999999999999999999999999999");
bi.IsEven - оно четное или нет, bi.IsPowerOfTwo - степерь 2 или нет
bi = BigInteger.Multiply(bi, BigInteger.Parse("99999999999999999999999999999999"))
```

## Преобразование типов с применением ключевого слова checked
К счастью, язык C# предоставляет ключевое слово checked. Когда оператор (или блок операторов) помещен в контекст checked, компилятор C# выпускает дополнительные инструкции CIL, обеспечивающие проверку условий переполнения, которые могут возникать при сложении, умножении, вычитании или делении двух значений числовых типов.

Если происходит переполнение, тогда во время выполнения генерируется исключение
System.OverflowException.
```csharp
try
{
    byte sum = checked ( (byte)Add(bl, b2) );
    Console.WriteLine("sum = {0}", sum);
}
catch (OverflowException ex)
{
    Console.WriteLine(ex.Message);
}
```
Можно делать проверку переполнения для целого блока кода:
```csharp
checked
{
    byte sum = (byte) Add (bl, b2);
    Console.WriteLine("sum = {0}", sum);
}
```


