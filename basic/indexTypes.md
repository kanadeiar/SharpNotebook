# Тип данных (Преобразование типов и null-операции)

В C# переменные делятная на значимые и ссылочные. Значимые хранят значения, а ссылочные - ссылки на ячейки, в которых уже содержатся значения.

Значимая переменная хранит значение определенного типа, например 5.

Переменная ссылочного типа содержит ссылку на значение в общей памяти, которая называется "Куча". По этой ссылке хранятся данные.

>При обозначении переменной можно использовать как тип .NET, так и псевдоним C#.

## Целочисленные типы:

Тип       Разрядность в битах        Диапазон представленных чисел

byte      8                          0 — 255                    Есть совместимость c CLS

sbyte     8                          -128 — 127

short     16                         -32 768 — 32 767           Есть совместимость c CLS

ushort    16                         0 — 65 535

int       32                         -2 147 483 648 — 2 147 483 647     Есть совместимость c CLS

unit      32                          0 — 4 294 967 295

long      64                         -9 223 372 036 854 775 808 — 9 223 372 036 854 775 807 Есть совместимость c CLS

ulong     64                         0 — 18 446 744 073 709 551 615

## Вещественные типы:

float           32 бита     диапазон значение от 5E-45 до  3,4E+38      Есть совместимость c CLS

double          64 бита     диапазон значений от 5E-324 до 1,7E+308     Есть совместимость c CLS

## Точный вещественный тип:

decimal     128 бит      Диапазон значений от 1Е-28 до 7.9Е+28      Есть совместимость c CLS

## Символы:
Char - Совместимость с CLS - System.Char  - от U+0000 до U+ffff   -  16 бит

Представлены 16 - разрядным кодом Unicode. Для работы с этим типом лужит класс Char.

## Строки:
String - Есть совместимость c CLS - Sytem.String - ограничен объемом памяти - набор символов Unicode.

Строка в C# является ссылкой на массив символов char. Представлены классом string или String.

Разбор значений из строковых данных.
```csharp
bool b = bool.Parse("True");
```

## Логический тип:

bool - Совместимость с CLS - System.Boolean - true или false

В переменной этого типа хранится значение "Истина" или "Ложь".

## Базовый тип 

Object - Есть совместимость c CLS - может хранится любой тип данных - базовый класс для всех типов мира .NET

## Числовые литералы 

По умолчанию число с плавающей точкой трактуется как double. Чтобы объявить значение типа float, применяйте суффикс f или F к неформатированному числовому значению (5.3F), а чтобы объявить значение типа decimal, применяйте суффикс m или м к числу с плавающей точкой (300.5М). И, наконец, неформатированные целые числа по умолчанию относятся к типу int. Чтобы получить значение типа long, понадобится снабдить его суффиксом 1 или L (4L).

В версии C# 7 введен новый литерал двоичных значений, для, например битовых масок:
```csharp
int i = 0b0001_0000; //это число 16
```

В версии C# 7 введен разделить групп цифр в виде символа подчеркивания (_) для типов данных int, long, decimal, double.
```csharp
long i = 123_345_789L;
```

## Значение переменной по умолчанию
Все внутренние типы данных поддерживают стандартный конструктор. Это средство позволяет создавать переменную, используя ключевое слово new.
```csharp
int mylnt = new int();
```
>переменные типа DateTime устанавливаются в 1/1/0001 12:00:00 AM;

>объектные ссылки (включая переменные типа string) устанавливаются в null.

Литерал default является новым средством в версии C# 7.1, которое позволяет присваивать переменной стандартное значение ее типа данных.
```csharp
int mylnt = default;
```

## Преобразование типов

Существует неявное и явное преобразование типов при вычислении выражений. Явное приведение - от стремным к крутым. Принудительное (явное) приведение - от более крутых к стремным.

```csharp
long a = 10000000;
int b = (int)a; //явное преобразование типов
a = b; //неявное преобразование типов
int b = Convert.toInt32(a); //преобразование типа - лучше всего использовать
int b = int.Parse("123"); //парсинг строки
```

## Сужение и расширение типов
Из-за того, что максимальное значение для типа short (32 767) гораздо меньше максимального значения для типа int (2 147 483 647), компилятор неявно расширяет каждое значение short до типа int. Формально термин расширение используется для определения неявного восходящего приведения, которое не вызывает потерю данных.

Из-за того, что язык C# создавался с расчетом на безопасность в отношении типов, будет получена ошибка на этапе компиляции если сделать обратную операцию - из типа long в тип int.

Если нужно проинформировать компилятор о том, что вы готовы мириться с возможной потерей данных из-за сужающей операции, тогда потребуется применить явное приведение.
```csharp
long a = 10000000;
int b = (int)a; //преобразование типа - сужение
long c = b; //преобразование типа - расширение
```

## Анонимный тип и неявно типизированные переменные:

Тип для переменной выводит компилятор на этапе компиляции в общий промежуточный код. Когда вы поступаете подобным образом, компилятор будет автоматически выводить лежащий в основе тип данных на основе начального значения, используемого для инициализации локального элемента данных

```csharp
var a = 999;
var myBool = bool;
var myString = "Time";
```
С использованием ключевого слова var связаны разнообразные ограничения. Прежде всего, неявная типизация применима только к локальным переменным внутри области видимости метода или свойства. Использовать ключевое слово var для определения возвращаемых значений, параметров или данных полей в специальном типе не допускается.

Неявная типизация локальных переменных дает в результате строго типизированные данные.

Определение и использование анонимного типа:
```csharp
static void Sample(int one, int two)
{
    var sampl = new {One = one, Two = two};
    WriteLine($"Sample = {sampl.One} {sampl.Two}");
    WriteLine($"To Str = \"{sampl.ToString()}\"");
}
static void Main()
{
    Sample(10, 12);
    var sampl2 = new {One = 12, Two = 32};
    WriteLine($"Sampl2 = {sampl2.One} {sampl2.Two}");
    ReadKey();
}
```
Все анонимные типы автоматом наследуются от System.Object и потому поддерживают все члены, предоставленные этим базовым классом. Анонимные типы позволяют быстро моделировать форму данных с очень малыми накладными расходами, который поддерживает доступ к данным через свойства. Каждая пара "имя-значение" - свойство, доступное только для чтения.

>Реализация ToString() просто строит строку из пар "имя-значение".

Простая проверка значений идентичных анонимных типов Equals() возвращает true - причина - сгенерированный компилятором метод при проверке эквивалентрости применяет сементику на основе значений.

Другая проверка операцией == возвращает false - причина - анонимные типы не получают перегруженных версий операций провеки равенства (== & !=), поэтому проверяются ссылки, а не значения, поддерживаемые значениями.

>Компилятор будет генерировать новое определение класса, только когда анонимный тип содержит уникальные имена свойств, и если вы объявите идентичные анонимные типы внутри сборки, то компилятор генерирует единственное определение анонимного типа.

Разрешается создавать анонимные типы, которые состоят из других анонимных типов. Пример:
```csharp
var samplevar = new {Time = DateTime.Now, Items = new {One = 1, Two = 2}};
```
Особенности анонимных типов:

- контроль над именами анонимных типов отсутствует.

- анонимные типы всегда расширяют System.Object.

- поля и свойства анонимного типа всегда допускают только чтение.

- анонимные типы не могут поддерживать события, спец методы, спец операции или спец переопределения.

- анонимные типы всегда неявно запечатаны.

- экземпляры анонимных типов всегда создаются с применением стандартных конструкторов.







# Продвинутое

## Преобразование между связанными типами данных

Когда типы данных связаны классическим наследованием то преобразование можно осуществлять вверх и вниз по иерархии классов. Производный класс всегда может быть приведен к базовому классу. Однако, если нужно сохраниь объект базового класса в переменной производного класса, то нужно выполнить явное приведение:
```csharp
class Base { }
class Derived : Base { }
//использование:
Base myBase;
myBase = new Derived(); //неявное
Derived myDeriv = (Derived)myBase; //явное
```
## Специальные процедуры преобразования
В языке C# предусмотреты два ключевых слова для управления тем, как типы должны реагировать на попытку преобразования:

explicit - явное преобразование

implicit - неявное преобразование

Пример класса:
```csharp
class DoubleVal
{
    public double Val { get; set; }
}
class IntVal
{
    public int Val { get; set; }
    //явное преобразование типа
    public static explicit operator IntVal(DoubleVal v1)
    {
        return new IntVal { Val = Convert.ToInt32(v1.Val) };
    }
}
```
Использование:
```csharp
DoubleVal dv = new DoubleVal { Val = 1.5 };
IntVal iv = (IntVal)dv; //явное приведение типа
```
Возможно явное преобразование типа относительно стандартного типа, такого как int.
Пример класса:
```csharp
class IntVal
{
    public int Val { get; set; }
    //явное преобразование типа
    public static explicit operator IntVal(int val)
    {
        return new IntVal { Val = val };
    }
    public static explicit operator int(IntVal val) => val.Val;
}
```
Использование:
```csharp
IntVal iv = (IntVal)10; //явное приведение типа
int side = (int)iv;
```

Насчет неявного преобразования. Не допускается определять одновременно функции явного и неявного преобразования. Но когда тип определяет процедуру неявного преобразования, вызывающий код может использовать явное преобразование.

Пример класса:
```csharp
class DoubleVal
{
    public double Val { get; set; }
    //неявное преобразование типа
    public static implicit operator DoubleVal(IntVal v1)
    {
        return new DoubleVal { Val = v1.Val };
    }
}
```
Использование:
```csharp
IntVal iv = new IntVal { Val = 19 }; //явное приведение типа
DoubleVal dv = iv;
DoubleVal dv2 = (DoubleVal)iv;
```


## Типы значений и ссылочные типы

Типы значений (структура) наследуются от класса System.ValueType и размещаются в стеке, поэтому имеют ограниченное время жизни.
```csharp
static void Sample()
{
    int i = 0;  // на самом деле - структура
    Point p = new Point(); //это - тип структуры
} //здесь i & p покидают стек
```
Когда переменная одного типа значений присваивается переменной другого типа значения, выполняется почленное копирование полей данных. По контрасту с типами значений, когда операция присваивания применяется к перемнным ссылочных типов (экземпляров классов) происходит перенаправление на то, на что ссылочная переменная указывает в памяи.

По умолчанию, если тип значения содержит другие ссылочные типы, то присваиваение проиводит к копированию ссылок. И в результата получаются две независимые структуры, каждая из которых содержит ссылку, указывающую на один и тот же объект в памяти. Для глубокого копирования - реализовать интерфейс ICloneable.

При передаче ссылочных типов по значению метод получает копию ссылки на объект из вызывающего кода. В методе становится возможным изменение данных состояния этого объекта, нельзя лишь переустанавливать саму эту ссылку.
```csharp
static void Sample(Person p)
{
    p.Age = 9;
    p = new Person("Nooo", 99); //это измепнение вызывающий код не увидит
}
```
При передаче ссылочных типов по ссылке (ref) вызываемый метод не только может изменять состояние объекта, но и переопределять сслыку так, чтобы она указывала на новый объект.
```csharp
static void Sample(ref Person p)
{
    p.Age = 66;
    p = new Person("Nooo", 99); //изменение ссылки в вызывающем коде
}
```
>Если ссылочный тип передается по ссылке, тогда вызываемый код может изменять значниея данных состояния объекта, а также объект на который указывает ссылка
>Если ссылочный тип передается по значния, то вызываемый код может изменять значения данных состояния объекта, но не оъект, на который указывает ссылка

## Отличия типов:
```csharp
Вопрос                      
Где размещаются объекты?        У значимого типа - В стеке
                                У ссылочного типа - В управляемой куче
Как представлена переменная?    У значимого типа - Являются локальными копиями
                                У ссылочного типа - Указывают на память, занимаемую размещенным экземпляром
Какой базовый тип?              У значимого типа - Неявно расширает System.Value
                                У ссылочного типа - производный от любого типа (кроме System.Value) незапечатанного.
Может быть базовым для других?  Значимые типы - нет, всегда запечатаны, наследовать нелья
                                Ссылочные типы - да, но если ток не запечатан
Поведение при передаче пар-ров? Значимые типы - передача по значению - передается локальная копия
                                Для ссылочных типов - ссылка копируется по значнию
Переопределить Finalize()       Значимые типы - нет
                                Ссылочные типы - косвенно
Определить конструкторы?        Значимые типы - да, но стандартный конструтор зарезервирован, все спец конструкторы должны иметь аргументы
                                Ссылочные типы - Конечно!
Когда переменные уничтожаются?  Значимые типы - при покидании области видимости, в которой они определены
                                Ссылочные типы - когда подвергается сборке мусора
```
Оба типа могут реализовывать интерфейсы и могут поддерживать любое количество полей, методов, перегруженных операций, констант, свойств, событий.

## Типы, допускающие null
Типам занчений не может быть присвоено значение null (true или false). 
```csharp
bool b = null; //так нельзя
```
Язык C# поддерживает концепцию типов данных, допускающих null (true, false, null). Для этого необходимо после типа данных поставить вопросительный знак.
```csharp
bool? b = null; //так можно
```
В языке C# знак вопроса после типа представляет собой сокращение создания экземпляра обобщенноо типа стурктуры System.Nullable<>.  
```csharp
Nullable<bool> b = null; //так можно
```
>Данные типы могут быть полезны при взаимодействии с базами данных, потому что столбцы в таблицах данных могут быть намеренно оставлены пустыми (неопределенными)
```csharp
if (i.HasValue)
    b = i.Value
if (i != null)
    b = i.Value
```
## Операция объединения с null
Любая переменная, которая может именть значение null, ссылочного или переменная типа, допускающего null, может использоватся с операцией ?? языка C#, которая называется операцией объединения c null. Позволяет присваивать значение типу если извлеченное значение на самом деле равно null.

Пример:
```csharp
string s = null;
int? i = null;
string s2 = s ?? "is null"; //присваивает "is null"
int i2 = i ?? -99; //присваивает -99
```
Что эквивалентно этому коду:
```csharp
int? i = null;
if (!i.HasValue)
    i2 = i;
else
    i2 = -99;
```
## null-условная операция
Стандартная проверка значения на предмет null:
```csharp
if (args != null)
{
    WriteLine($"Len = {args.Length}");
}
```
C применением null-условной операции:
```csharp
WriteLine($"Len = {args?.Length}"); //ставится пустое значение
WriteLine($"Len = {args?.Length ?? 0}"); //ставится ноль
```
Нововвведение в языке C# 8 - объединение операции присваивания с значением null. В C# 8.0 появился оператор присваивания объединения со значением NULL ??=. Оператор ??= можно использовать для присваивания значения правого операнда левому операнду только в том случае, если левый операнд принимает значение null.
```csharp
int? i = null;
i ??= 17;
WriteLine(i); //17
```

## Иерархия классов для типов данных

Object базовый класс для Type, String, Array, Exception, Delegate и ValueType. 

А ValueType является базым классом для Boolean, Uint16, Int16, Decimal, Byte, Char, Void, DateTime, Single, Int64, SByte и пр. базовые типы., перечисления и структуры.

Так как в Object определены базовые ToString(), Equals(), GetHashCode(), общие для всех типов из библиотеки .NET. Многие числовые типы являются производыми от ValueType, и в свою очередь размещаются в стеке, имеют ограниченное время жизни и эффективны. Другие же типы, напрямую производные от Object, размещаются не в стеке, а в куче, с автоматической сборкой мусора.

## Члены числовых типов данных

Все члены числовых типов данных поддерживают свойства MaxValue и MinValue, это максимальное и минимальное значение. В дополнение к этим свойствам, каждый тип может иметь свои индивидуальные свойства - так, double - бесконечная малая (эпсилон) и бесконечно большие. 

## Члены булевского типа

Имеет свойства TrueString и FalseString, выделяют строки True & False.

## Члены символьного типа

Текстовые данные - это System.String & System.Char оба основаны на Unicode. string - непрерывное множество символов, а char - одиночный символ. У типа данных Char имеется очень большой набор свойств для определения является ли данный символ цифрой, букровй, знаком пунктуации и т.п.
```csharp
char.IsDigit('a');
char.IsLetter('Hello There', 5);
char.IsPunctuation('?');
```

Разбор значений из строковых данных продвинутым спомобом:
```csharp
if (bool.TryParse("True", out bool b)) //не вызывает исключение если не может разорбать значение
{
    Console.WriteLine($"Значение b = {b}");
}
else
{
    Console.WriteLine("Неудача преобраования типа");
}
```
## Члены дато временного типа

Тип DateTime содержит данные, содержащие значение даты (год, месяц, день) и времени. Структура TimeSpan - позволяет работать с типом даты времени различным спообом.
```csharp
DateTime dt = new DateTime(2019, 1, 1); - год месяц день
dt.Day   dt.DayOfWeek - текущий день и день недели
TimeSpan ts = new TimeSpan(2, 20, 0); - часы минуты секунды
ts.Substract(new TimeSpan(0, 15, 0)); - прибавить 15 минут
```

## Тип огромного числового значения
Для работы с этим типом необходимо добавить ссылку на сборку System.Numerics.dll. 

Пример использования:
```csharp
using System.Numerics;

BigInteger bi = BigInteger.Parse("999999999999999999999999999999999999999999");
bi.IsEven - оно четное или нет, bi.IsPowerOfTwo - степерь 2 или нет
bi = BigInteger.Multiply(bi, BigInteger.Parse("99999999999999999999999999999999"))
```

## Преобразование типов с применением ключевого слова checked
К счастью, язык C# предоставляет ключевое слово checked. Когда оператор (или блок операторов) помещен в контекст checked, компилятор C# выпускает дополнительные инструкции CIL, обеспечивающие проверку условий переполнения, которые могут возникать при сложении, умножении, вычитании или делении двух значений числовых типов.

Если происходит переполнение, тогда во время выполнения генерируется исключение
System.OverflowException.
```csharp
try
{
    byte sum = checked ( (byte)Add(bl, b2) );
    Console.WriteLine("sum = {0}", sum);
}
catch (OverflowException ex)
{
    Console.WriteLine(ex.Message);
}
```
Можно делать проверку переполнения для целого блока кода:
```csharp
checked
{
    byte sum = (byte) Add (bl, b2);
    Console.WriteLine("sum = {0}", sum);
}
```


