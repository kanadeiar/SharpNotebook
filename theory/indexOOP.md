# ООП

Все объектно-ориентированне языки должны поддерживать три основных принципа ООП:

- инкапсуляция. Сокрытие деталей внутренней реализации объектов.

- наследование. Многократное повторное использования кода.

- полиморфизм. Трактовка связанных объектов в сходной манере.

## Инкапсуляция.

Это способность языка скрывать излишние детали реализации от пользователя объекта. Класс скрывает внутренние детали оперирования с данными, этот принцип ООП упрощает задачи кодирования. Не нужно беспокоится о строках кода, которые работают за кулисами.

С этим понятием связана идея защита данных. В идеале все поля данных должны быть с ключевым словом private и protected. И в итоге внешний код должен обращатся к этим полям вежливо, через открытые члены, а открытые поля данных могут быть повреждены.
```csharp
MyClass obj = new MyClass();
obj.Open();
obj.Close();
```

## Наследование.

Этот принцип языка отражает возможность языка разрешать построение определений новых классов на основе кода существующих. Это позволяет расширять поведение базового класса за счет наследования его основной функциональности производным классом.

Описание классов: класс Кошка является Питомцем, которая является объектом. Между ними устанавливается отношение явлется (is a). Это и есть наследование.

Класс питомцев определяет небольшое количество членов, общих для всех питомцев. Класс Кошка наследует основную функциональность, определяемую классами Питомцев и объекта, вдобавок к этому сам определяет дополнительные детали, характерные для кошек.
```csharp
public class Pet
{ }
public class Cat : Pet
{ }
```

## Полиморфизм

Еще один принцип ООП - полиморфизм, это черта обозначает способность языка трактовать связанные объекты в сходной манере. Базовый класс может определеять набор членов, которые доступны всем наследникам. Этот полиморфный интерфейс конструируется с применением любого количества виртуальных или абстрактных членов.

Виртуальный член - член базового класса, реализацию которого можно изменять в производном классе.

Абстрактный член - член базового класса, который предоставляет только сигнатуру, но не реализацию.

Абстрактный член обязательно должен быть переопределен в производном классе.

Пример: так как и кошка и собака унаследованы от класса питомцы, они имеют разную реализацию метода подачи голоса. Кошка - мяукает, а собака - гавкает.

Пример классов:
```csharp
public class Pet
{
    virtual public void Print()
    { }
}
public class Cat : Pet
{
    public override void Print()
    {
        WriteLine("Мяу");
    }
}

public class Dog : Pet
{
    public override void Print()
    {
        WriteLine("Гав");
    }
}
```
Использование:
```csharp
Pet pet1 = new Cat();
Pet pet2 = new Dog();
pet1.Print(); //мяу
pet2.Print(); //гав
```

## Композиция

Еще одна форма повторного использования кода - включения/делегации называемая имеет (has a) или агрегация. Отношение имеет позволяет одному классу определять переменную-член другого класса и открывать доступ к его функциональности пользователю объекта. 

Пример - класс кошка имеет хвост и открывает к нему доступ:
```csharp
public class Cat
{
    private Tail tail = new Tail();
    public class Tail
    { }
}
```

