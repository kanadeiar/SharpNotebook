# Примитивная синхронизация потоков

Синхронизация позволяет предотвратить повреждение общих данных при одновременном доступе к этим данным разных потоков.

Синхронизация потоков влечет за собой много проблем:

- программировать код синхронизации крайне утомительно и при этом легко допустить ошибку.

- снижение производительности.

- при блокировании в каждый момент времени допускается доступ к ресурсам только одного потока.

Синхронизация потоков имеет столько нежелательных последствий, что приложения следует проектировать так, чтобы она применялась как можно реже. Избегать общих данных — например, статических полей. По возможности работать со значимыми типами, потому что они всегда копируются, и каждый поток в итоге работает с собственной копией. Нет ничего страшного в одновременном доступе разных потоков к общим данным, если эти данные предназначены только для чтения.

Многие из конструкций синхронизации потоков в CLR являются всего лишь объектно-ориентированными оболочками классов, построенных на базе конструкций синхронизации потоков Win32.

## Безопасность потоков библиотеки BCL

Библиотека BCL разработки Microsoft гарантирует безопасность в отношении потоков всех статических методов.

Библиотека BCL не гарантирует безопасности в отношении потоков экземплярным методам, так как введение в них блокирующего кода слишком сильно сказывается на производительности.

Собственные библиотеки классов рекомендуется строить по этому паттерну — то есть все статические методы следует сделать безопасными в отношении потоков, а экземплярные методы — нет.

Если целью экземплярного метода является координирование потоков, его тоже следует сделать безопасным в отношении потоков.

## Пользовательский режим и режим ядра

По возможности нужно задействовать конструкции пользовательского режима, так как они значительно быстрее и используют для координации потоков специальные директивы процессора. Координация происходит на аппаратном уровне, пул не создает дополнительных потоков для восполнения загрузки процессора. Блокировка на очень короткое время.

Поток, который пытается, но не может получить некоторый ресурс, начинает циклически существовать в пользовательском режиме.

Если поток, использующий в данный момент конструкцию, не освободит ее, ожидающий конструкции поток может оказаться заблокированным навсегда. В этом случае в пользовательском режиме поток бесконечно исполняется процессором; этот вариант блокировки называется активной (живой) блокировкой (livelock), зависание.

Примитивные конструкции уровня ядра предоставляются самой операционной системой Windows и требуют от потоков приложения вызова функций, реализованных в ядре.

Переход потока между пользовательским режимом и режимом ядра требует значительных затрат ресурсов, поэтому конструкций режима ядра крайне желательно избегать. Однако и у них есть свои достоинства. Если один поток использует конструкцию режима ядра для получения доступа к ресурсу, с которым уже работает другой поток, Windows блокирует его, чтобы не тратить понапрасну время процессора. А затем, когда ресурс становится доступным, блокировка снимается, и поток получает доступ к ресурсу.

Ядро операционной системы Windows может остановить выполнение потока, чтобы он перестал впустую расходовать ресурсы процессора.

Если в режиме ядра поток блокируется навсегда, этот тип блокировки называется взаимной (мертвой) блокировкой (deadlock).

## Пользовательский режим

CLR гарантирует атомарность чтения и записи следующих типов данных: bool, Char, (s)byte, (u)short, (u)int, (U)IntPtr, float и ссылочных типов. Все байты переменной читаются или записываются одновременно. При этом посторонние потоки не увидят переменную в промежуточном состоянии.

Примитивные конструкций синхронизации потоков пользовательского режима делятся на:

- Volatile. Выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения ИЛИ записи.

- Interlocked. Выполняют для переменной, содержащей данные простого типа, атомарную операцию чтения И записи.

### Volatile

Каждый метод выполняет либо атомарное чтение, либо атомарную запись.

В процессе оптимизации кода компилятором C#, JIT-компилятором и процессором гарантируется сохранение его назначения. Однако при переходе к многопоточной конфигурации ситуация может измениться.

Класс System.Threading.Volatile содержит два статических метода. Это специальные методы, отключающие оптимизации, обычно выполняемые компилятором C#, JIT-компилятором и собственно процессором.

```csharp
public sealed class Volatile {
    public static void Write(ref int location, int value);
    public static int Read(ref int location);
}
```

- Метод Volatile.Write заставляет записать значение в параметр location непосредственно в момент обращения. Более ранние загрузки и сохранения программы должны происходить до вызова этого метода.

- Метод Volatile.Read заставляет считать значение параметра address непосредственно в момент обращения. Более поздние загрузки и сохранения программы должны происходить после вызова этого метода.

При взаимодействии потоков друг с другом через общую память записывайте последнее значение методом Volatile.Write, а первое значение читайте методом Volatile.Read.

Пример использования:

```csharp
class Threads
{
    private int _value1 = 0;
    private int _value2 = 0;
    public void Thread1()
    {
        _value2 = 10;
        Volatile.Write(ref _value1, 1); 
    }
    public void Thread2()
    {
        if (Volatile.Read(ref _value1) == 1)
            Console.WriteLine(_value2);
    }
}
```

Но что здесь происходит на самом деле? Для метода Thread1 вызов метода Volatile.Write гарантирует, что все записи в переменные будут завершены до записи значения 1 в переменную _value1. Так как операция _value2 = 10 расположена до вызова метода Volatile.Write, она сначала должна завершиться.

Вызов метода Volatile.Read для метода Thread2 гарантирует, что значения всех переменных будут прочитаны после значения переменной _value1.

Для упрощения работы с этими методами класса Volative в C# было введено ключевое слово volatile, применяемое к статическим или экземплярным полям типов bool, (s)byte, (u)short, (u)int, (U)IntPtr, float и char. Также оно применяется к ссылочным типам и любым перечислимым полям, если в основе последних лежит тип (s)byte, (u)short или (u)int. JIT-компилятор гарантирует, что доступ к полям, помеченным данным ключевым словом, будет происходить в режиме волатильного чтения или записи. 

Ключевое слово volatile запрещает компилятору C# и JIT-компилятору кэшировать содержимое поля в регистры процессора. Это гарантирует, что при всех операциях чтения и записи манипуляции будут производиться непосредственно с памятью.

Неоптимизированный код определенно занимает больше места и медленней работает с памятью. Поля volatile несовместимы со спецификацией CLS.

Переделанный пример с этим ключевым словом:

```csharp
class Threads
{
    private volatile int _value1 = 0;
    private int _value2 = 0;
    public void Thread1()
    {
        _value2 = 10;
        _value1 = 1;
    }
    public void Thread2()
    {
        if (_value1 == 1)
            Console.WriteLine(_value2);
    }
}
```

### Interlocked

Каждый из статических методов класса System.Threading.Interlocked выполняет как атомарное чтение, так и атомарную запись. Кроме того, все методы класса Interlocked ставят барьер в памяти, то есть любая запись переменной перед вызовом метода класса Interlocked выполняется до этого метода, а все чтения переменных после вызова метода выполняются после него.

```csharp
public static class Interlocked {
    public static int Increment(ref int location);
    public static int Decrement(ref int location);
    public static int Add(ref int location, int value);
    // Int32 old = location; location = value; return old;
    public static int Exchange(ref int location, int value);
    // Int32 old = location;
    // if (location == comparand) location = value;
    // return old;
    public static int CompareExchange(ref int location, int value, int comparand);
}
```

Есть перегруженные версии таких методов для long. Есть методы для object, float, double. Есть обобщенные методы для типа class.

Пример синхронизации с использованием System.Threading.Interlocked:

```csharp
Interlocked.Increment(ref intVal); //увеличение на 1
Interlocked.Exchange(ref intVal, 55); //установка заданного значения
Interlocked.CompareExchange(ref intVal, 99, 0); //присвоить 99, если равно 0
```

### Цикличное блокирование

При возникновении необходимости атомарного манипулирования набором полей объекта потребуется предотвратить проникновение всех потоков кроме одного в область кода, управляющую полями. Interlocked-методы позволяют выполнить блокирование в рамках синхронизации потоков.

```csharp
struct SimpleLock
{
    private int _resourceInUse; // 0=false (по умолчанию), 1=true

    public void Enter()
    {
        while (true)
        {
            // Всегда указывать, что ресурс используется.
            // Если поток переводит его из свободного состояния, то вернуть управление
            if (Interlocked.Exchange(ref _resourceInUse, 1) == 0) return;
            // Основной код работы с ресурсом
        }
    }
    public void Leave()
    {
        // Пометка ресурса как свободный
        Volatile.Write(ref _resourceInUse, 0);
    }
}
```

### Задержка

Суть задержки в том, чтобы иметь поток, умеющий заставить ресурс на время приостановить исполнение этого потока, чтобы другой поток, обладающий в данный момент ресурсом, завершился и освободил место. Для этого структура SpinWait вызывает методы Sleep, Yield и SpinWait класса Thread.

```csharp
public static void Sleep(Int32 millisecondsTimeout);
public static void Sleep(TimeSpan timeout);
```

Поток заставляет метод приостановить работу на указанное время. Вызов метода Sleep позволяет потоку добровольно убрать напоминание о времени своего исполнения. Система забирает поток у планировщика примерно на указанное время.

Поток может также попросить Windows запланировать для текущего процессора другой поток, вызвав метод Yield класса Thread

```csharp
public static Boolean Yield();
```

Поток может остановиться сам, дав гиперпотоковому процессору возможность переключиться на другие потоки, вызывая метод SpinWait класса Thread.

```csharp
public static void SpinWait(Int32 iterations);
```

### Универсальный Interlocked-паттерн

Можно использовать хорошо известный шаблон, позволяющий методом Interlocked.CompareExchange атомарно выполнять любые операции со значениями типа Int32. А так как существуют перегруженные версии этого метода для типов Int64, Single, Double, Object, а также для обобщенного ссылочного типа, шаблон может работать и со всеми этими типами.

Пример атомарного метода:

```csharp
public static int Max(ref int target, int value)
{
    int currentVal = value, startVal, desiredVal;
    do
    {
        startVal = currentVal;
        desiredVal = Math.Max(startVal, value);
        // if (target == startVal) target = desiredVal
        currentVal = Interlocked.CompareExchange(ref target, desiredVal, startVal);
    } while (startVal != currentVal);
    return desiredVal;
}
//использование
var value1 = 10;
var value2 = 20;
var max = Max(ref value1, value2);
```

Пример обобщенного метода:

```csharp
delegate int Morpher<in TArg, TResult>(int startVal, TArg arg, out TResult morthResult);
static TResult Morph<TArg, TResult>(ref int target, TArg arg, Morpher<TArg, TResult> morpher)
{
    TResult result;
    int currentVal = target, startVal, desiredVal;
    do
    {
        startVal = currentVal;
        desiredVal = morpher(startVal, arg, out result);
        // if (target == startVal) target = desiredVal
        currentVal = Interlocked.CompareExchange(ref target, desiredVal, startVal);
    } while (startVal != currentVal);
    return result;
}
// использование
var target = 1; // переменная которой требуется потокобезопасность
var val = Morph<int, int>(ref target, 20,
    static (int sv, int a, out int r) => { r = Math.Max(sv, a); return r; });
Console.WriteLine(target);
```

## Режим ядра

Для синхронизации потоков в Windows существует несколько конструкций режима ядра. Они работают намного медленнее конструкций пользовательского режима.

Преимущества конструкций уровня режима ядра:

- Если конструкция режима ядра выявляет конкуренцию за ресурс, Windows блокирует проигравший поток, останавливая зацикливание, которое ведет к напрасному расходованию ресурсов процессора.

- Конструкции режима ядра могут осуществлять взаимную синхронизацию неуправляемых и управляемых потоков.

- Конструкции режима ядра умеют синхронизировать потоки различных процессов, запущенных на одной машине.

- Конструкции режима ядра можно наделить атрибутами безопасности, ограничивая несанкционированный доступ к ним.

- Поток можно заблокировать, пока не станут доступны все конструкции режима ядра или пока не станет доступна хотя бы одна такая конструкция.

- Поток можно заблокировать конструкцией режима ядра, указав время ожидания; если за указанное время поток не получит доступа к нужному ему ресурсу, он будет разблокирован и сможет выполнять другие задания.

К примитивным конструкциям синхронизации потоков в режиме ядра относятся события (events) и семафоры (semaphores). На основе них строятся уже более сложные конструкции.

В пространстве имен System.Threading существует абстрактный базовый класс WaitHandle. Он играет роль оболочки для дескриптора ядра Windows.

Метод WaitOne класса WaitHandle блокирует текущий поток до активизации объектом ядра. Он вызывает Win32-функцию WaitForSingleObjectEx. Значение true возвращается, если объект был активизирован. Если же время ожидания истекло, возвращается значение false.

Статический метод WaitAll класса WaitHandle заставляет вызывающий поток ждать активизации всех объектов ядра, указанных в массиве WaitHandle[]. Если все объекты были активизированы, возвращается значение true, в случае же истечения времени ожидания возвращается значение false. Данный метод вызывает Win32-функцию WaitForMultipleObjectsEx, передавая параметру bWaitAll значение TRUE.

Статический метод WaitAny класса WaitHandle заставляет вызывающий поток ждать активизации любого из объектов ядра, указанных в массиве WaitHandle[]. Возвращенное значение типа Int32 является индексом активизированного элемента массива. Если в процессе ожидания сигнала не поступило, возвращается значение WaitHandle.WaitTimeout. Данный метод вызывает Win32-функцию WaitForMultipleObjectsEx, передавая параметру bWaitAll значение FALSE.

Метод Dispose закрывает дескриптор объекта ядра. Во внутренней реализации эти методы вызывают функцию Win32 CloseHandle. Вызывать Dispose в коде можно только в том случае, если абсолютно уверен, что объект ядра не используется другими потоками.

Конструкции режима ядра часто используются для создания приложений, которые в любой момент времени могут существовать только в одном экземпляре.

Пример:

```csharp
internal partial class Program
{
    private static void Main(string[] args)
    {
        bool createdNew;
        // Пытаемся создать объект ядра с указанным именем
        using (new Semaphore(0, 1, "SimpleConsole", out createdNew))
        {
            if (createdNew)
            {
                Console.WriteLine("Нажмите любую кнопку ...");
                var _ = Console.Read();
            }
            else
            {
                // завершение работы
            }
        }
    }
}
```

### События

События (events) представляют собой переменные типа bool, находящиеся под управлением ядра. Ожидающий события поток блокируется, если оно имеет значение false, и освобождается в случае значения true. Когда событие с автосбросом имеет значение true, оно освобождает всего один заблокированный поток, так как после освобождения первого потока ядро автоматически возвращает событию значение false. Если же значение true имеет событие с ручным сбросом, оно освобождает все ожидающие этого потоки, так как в данном случае ядро не присваивает ему значение false автоматически, в коде это должно быть сделано в явном виде.

Классы событий:

```csharp
public class EventWaitHandle : WaitHandle
{
    public Boolean Set(); // Boolean присваивается true; всегда возвращает true
    public Boolean Reset(); // Boolean присваивается false; всегда возвращает true
}
public sealed class AutoResetEvent : EventWaitHandle
{
    public AutoResetEvent(Boolean initialState);
}
public sealed class ManualResetEvent : EventWaitHandle
{
    public ManualResetEvent(Boolean initialState);
}
```

При наличии нескольких потоков в режиме ожидания событие с автосбросом освобождает только один из них.

Событие с ручным сбросом снимает блокировку со всех ожидающих его потоков.

Пример блокировки ресурса в рамках синхронизации потоков:

```csharp
class SimpleWaitLock : IDisposable
{
    private readonly AutoResetEvent _avaitable;
    public SimpleWaitLock()
    {
        _avaitable = new AutoResetEvent(true);
    }
    public void Enter()
    {
        _avaitable.WaitOne();
    }
    public void Leave()
    {
        _avaitable.Reset();
    }
    public void Dispose() => _avaitable.Dispose();
}
// использование
using (SimpleWaitLock swl = new SimpleWaitLock())
{
    for (Int32 i = 0; i < iterations; i++)
    {
        swl.Enter(); x++; swl.Leave();
    }
}
```

### Семафоры

Семафоры (semaphores) также представляют собой обычные переменные типа int, управляемые ядром. Ожидающий семафора поток блокируется при значении 0 и освобождается при значениях больше 0. При снятии блокировки с ожидающего семафора потока ядро автоматически вычитает единицу из счетчика. С семафорами связано максимальное значение типа int, которое ни при каких обстоятельствах не могут превысить текущие показания счетчика.

```csharp
public sealed class Semaphore : WaitHandle
{
    public Semaphore(Int32 initialCount, Int32 maximumCount);
    public Int32 Release(); // Вызывает Release(1);
                            // возвращает предыдущее значение счетчика
    public Int32 Release(Int32 releaseCount); // Возвращает предыдущее
                                              // значение счетчика
}
```

При наличии нескольких потоков, ожидающих семафора, его появление снимает блокировку с потоков releaseCount (здесь releaseCount — это аргумент, переданный методу Release класса Semaphore).

Пример блокировки ресурса в рамках синхронизации потоков:

```csharp
class SimpleWaitLock : IDisposable
{
    private Semaphore _avaitable;
    public SimpleWaitLock(int maximumThreads)
    {
        _avaitable = new Semaphore(maximumThreads, maximumThreads);
    }
    public void Enter()
    {
        _avaitable.WaitOne();
    }
    public void Leave()
    {
        _avaitable.Release();
    }
    public void Dispose() => _avaitable.Dispose();
}
```

### Мьютексы

Мьютекс (mutex) предоставляет взаимно исключающую блокировку. Он функционирует аналогично объекту AutoResetEvent (или объекту Semaphore со значением счетчика 1), так как все три конструкции за один раз освобождают всего один ожидающий поток.

```csharp
public sealed class Mutex : WaitHandle {
    public Mutex();
    public void ReleaseMutex();
}
```

Мьютексы снабжены дополнительной логикой, что делает их более сложными по сравнению с другими конструкциями. 

Объекты Mutex сохраняют информацию о том, какие потоки ими владеют. Для этого они запрашивают идентификатор потока (int).

Объекты Mutex управляют рекурсивным счетчиком, указывающим, сколько раз поток-владелец уже владел объектом. Если поток владеет мьютексом в настоящий момент и ожидает его еще раз, рекурсивный счетчик увеличивается на единицу, и потоку разрешается продолжить выполнение. При вызове потоком метода ReleaseMutex рекурсивный счетчик уменьшается на единицу. И только после того, как его значение достигнет 0, владельцем мьютекса может стать другой поток.

Объекту Mutex требуется дополнительная память для хранения идентификатора потока и рекурсивного счетчика. И главное, код объекта Mutex должен управлять этой информацией, что тормозит блокировку.








