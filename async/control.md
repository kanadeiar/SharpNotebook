# Асинхронное управление

Приложения с графическим интерфейсом перестают реагировать на действия пользователя на время блокировки потока.

В ситуации, когда количество потоков значительно превосходит количество ядер процессора, операционная система прибегнет к частым переключениям контекста, что значительно снизит производительность.

Асинхронный ввод-вывод кроме минимального использования ресурсов и уменьшения количества переключений контекста предоставляет более быструю работу сборщика мусора вследствии уменьшения числа потоков, в случае набора асинхронных операций ввода-вывода время их завершения определяется самой медленной из выполняемых операций и отзывчивый интерфейс в графических приложениях.

## Асинхронные функции

Асинхронные функции позволяют писать приложения, выполняющие множество операций при помощи небольшого количества потоков. Вместе с пулом потоков они дают возможность эффективно задействовать все процессоры в системе. Разработанная модель программирования задействует объекты Task и асинхронные функции языка C#. 

В C# есть ключевые слова async и await для упрощения процесса написания асинхронного кода. Компилятор будет самостоятельно генерировать большой объем кода, связанного с потоками из пространств System.Threading и System.Theading.Tasks.

Ключевое слово async помечает метод, лямбда-выражение или анонимный метод должен вызываться в асинхронной манере автоматически. При вызове async ключевое слово await будет автоматически приостанавливать текущий поток, пока задача не завершится, давая возможность вызывающему потоку продолжить свою работу.

Асинхронный метод должен быть помечен async и иметь в своем коде хотя бы один await, иначе он будет скомпилирован в итоге для синхронного выполнения.

Когда применяются ключевые слова async и await, компилятор будет самостоятельно генерировать большой объем кода, связанного с потоками, с использованием многочисленных членов из пространств имен System.Threading и System.Threading.Tasks.

Ключевое слово async языка C# применяется для указания на то, что метод, лямбда-выражение или анонимный метод должен вызываться в асинхронной манере автоматически.

Для асинхронных функций действует ряд ограничений:

- Конструкторы, методы доступа свойств и методы доступа событий не могут быть преобразованы в асинхронные функции.

- Асинхронная функция не может иметь параметры out и ref.

- Оператор await не может использоваться в блоке catch, finally или unsafe.

- Не допускается установление блокировки, поддерживающей владение потоком или рекурсию, до операции await, и ее снятие после оператора await. Это ограничение объясняется тем, что один поток может выполнить код до await, а другой поток может выполнить код после await. При использовании await с командой C# lock компилятор выдает сообщение об ошибке.

- В выражениях запросов оператор await может использоваться только в первом выражении коллекции условия from или в выражении коллекции условия join.


Простой пример:

```csharp
static async Task<string> WorkAsync()
{
    return await Task.Run(async () =>
    {
        await Task.Delay(1000);
        return "Все нормально";
    });
}
// использование
private static async Task Main(string[] args)
{
    var message = await WorkAsync();
    Console.WriteLine($"Сообщение: {message}");
}
```

Пример использования асинхронных методов с одним входным параметром:

```csharp
static void MyWork()
{
    Thread.Sleep(3_000);
    Console.WriteLine("void Работа");
}
static void MyDetailWork(int x)
{
    Thread.Sleep(3_000);
    Console.WriteLine($"void Подробная работа #{x}");
}
static async void MyVoidAsync() //без возврата значения
{
    await Task.Run(async () =>
    {
        await Task.Delay(1_000);
        Console.WriteLine("void async Работа");
    });
}
static async Task MyWorkAsync(int x)
{
    await Task.Run(MyWork); //без параметра
    await Task.Run(() => MyDetailWork(x)); //с параметром
    await Task.Delay(3_0000);
    Console.WriteLine($"async Task Работа #{x}");
}
static async Task Main() //вызов в неблокирующей манере
{
    MyVoidAsync(); //еще вызов асинх метода
    MyWorkAsync(1); //вызов асинхронного метода
    Console.WriteLine("Работа #1 запущена асинхронно");
    await Task.Run(() =>
    {
        Thread.Sleep(5_000);
        Console.WriteLine("Лямбда работа");
    }); //асинхронная работа лямбда функция с ожиданием, хотя можно без, если удалить await
    Console.WriteLine("Введите что нибудь:");
    string s = Console.ReadLine();
    Console.WriteLine($"Вы ввели: {s}");
    Console.WriteLine("Старт и ожидание завершения работы #2");
    await MyWorkAsync(2); //ожидание завершения асинх метода
    Console.WriteLine("Работа #2 завершена");
    Console.WriteLine("Нажмите любую кнопку ...");
    Console.ReadKey();
}
```

Пример использования асинхронных функций с входным и возвращаемым параметром:

```csharp
static int MyFunc(int x)
{
    Thread.Sleep(3_000);
    Console.WriteLine($"int Вычисление : {x}");
    return x + 1;
}
static async Task<int> MyFuncAsync(int x)
{
    int y = await Task.Run(() => MyFunc(x));
    await Task.Delay(4_000);
    Console.WriteLine($"int async Вычисление : {y}");
    return y + 1;
}
static async Task<int> MyFuncSumAsync() //сумма асинхронная вычислений
{
    Task<int> t1 = Task<int>.Run(() => MyFunc(1));
    Task<int> t2 = Task<int>.Run(() => MyFunc(2));
    Task<int> t3 = Task<int>.Run(() => MyFunc(3));
    var res = await Task<int>.WhenAll(new[] {t1, t2, t3}); //выполнение всех задач
    return res.Sum();
}
static async Task Main() //вызов в неблокирующей манере
{
    int x = await Task<int>.Run(() => 1); //асинхронная работа - лямбда-функция с ожиданием
    Console.WriteLine("Введите что нибудь:");
    string s = Console.ReadLine();
    Console.WriteLine($"Вы ввели: {s}");
    Console.WriteLine("Старт и ожидание завершения вычислений");
    int y = await MyFuncAsync(1); //ожидание завершения асинхронного метода
    Console.WriteLine($"Вычисление завершено y = {y}");
    y = await MyFuncSumAsync();
    Console.WriteLine($"Результат вычисления асинхронного: {y}");
    Console.WriteLine("Нажмите любую кнопку ...");
    Console.ReadKey();
}
```

Пример вызова обычных функций асинхронно:

```csharp
static void MyWork()
{
    Thread.Sleep(6_000);
    Console.WriteLine("void Работа");
}
static int MyFunc(int x)
{
    Thread.Sleep(3_000);
    Console.WriteLine($"int Вычисление : {x}");
    return x + 1;
}
static async Task Main() //вызов в неблокирующей манере
{
    Task.Run(MyWork); //запуск асинхронно
    Console.WriteLine("Работа запущена асинхронно");
    Console.WriteLine("Старт и ожидание завершения вычислений");
    int y = await Task<int>.Run(() => MyFunc(1)); //ожидание завершения асинхронных вычислений
    Console.WriteLine($"Вычисление завершено y = {y}");
    Console.WriteLine("Нажмите любую кнопку ...");
    Console.ReadKey();
}
```

### Контекст баз синхронизации

В BCL определен базовый класс System.Threading.SynchronizationContext, который решает проблемы синхронизации выполнения задач в потоке.

Цель модели синхронизации, реализуемой классом SynchronizationContext, заключается в том, чтобы позволить внутренним асинхронным/синхронным операциям общеязыковой исполняющей среды вести себя надлежащим образом с различными моделями синхронизации.

При вызове await для Task используется объект SynchronizationContext вызывающего потока. Когда пул потока завершает объект Task, используется объект SynchronizationContext, обеспечивающий соответствие потоковой и прикладной модели. Таким образом, когда GUI-поток выполняет await для Task, код, следующий за оператором await, заведомо будет исполнен в GUI-потоке, что позволяет этому коду обновить элементы пользовательского интерфейса. Для приложений ASP.NET код, следующий за оператором await, заведомо выполняется в пуле потока, с которым связаны региональные стандарты и идентификационные данные клиента.

Для решения проблем взаимной блокировки классов Task и Task<TResult> в приложениях с GUI интерфейсом следует применять метод ConfigureAwait со значением false.

Пример:

```csharp
var msg = await new HttpClient().GetAsync("https://yandex.ru/").ConfigureAwait(false);
```

Вызов ConfigureAwait(false) должен быть применен к каждому объекту Task, используемому с await. Асинхронные операции могут завершаться синхронно, и когда это происходит, вызывающий поток просто продолжает выполняться без возвращения управления стороне вызова; вы никогда не знаете, какой операции потребуется игнорировать объект SynchronizationContext, поэтому необходимо приказать всем операциям игнорировать его. Это также означает, что код библиотеки классов должен быть независимым от модели приложения.

### Доступ из вторичных потоков

Элементы управления графического пользовательского интерфейса привязаны к потоку, где они были созданы. Если вторичные потоки пытаются получить доступ к элементу управления, который они напрямую не создавали, то при отладке программного обеспечения возникают ошибки времени выполнения.

Родительский класс Control в WPF определяет объект Dispatcher, который управляет рабочими элементами для потока. Указанный объект имеет метод по имени Invoke (), принимающий на входе System.Delegate. Этот метод можно вызывать внутри кода, выполняющегося во вторичных потоках, чтобы обеспечить возможность безопасного в отношении потоков обновления пользовательского интерфейса для заданного элемента управления.

Пример:

```csharp
Dispatcher?.Invoke(() =>
{
    this.Title = $"Processing {filename}";
});
```

### Одна операция

Инициирование асинхронной функции из другого потока (из обычного метода или метода графического интерфейса):

```csharp
Task.Run(async () => {
    await XxxAsync(); 
});
```

### Множество операций

Запуск множества асинхронных операций может быть произведено одновременно и одновременно можно получить результаты от всех операций:

```csharp
var task1 = Square(4);
var task2 = Square(5);
var task3 = Square(6);
var results = await Task.WhenAll(task1, task2, task3);
var sum = results.Sum();
System.Console.WriteLine("Сумма = {0}", sum);
static async Task<int> Square(int n)
{
    await Task.Delay(1000);
    return n * n;
}
```

Можно обрабатывать задачи по мере поступления решения от каждой задачи, получение результата первой завершившейся задачи:

```csharp
var tasks = new List<Task<int>>
{
    Square(4),
    Square(5),
    Square(6),
};
var sum = 0;
while (tasks.Count() > 0)
{
    var result = await Task.WhenAny(tasks);
    tasks.Remove(result);
    sum += result.Result;
}
System.Console.WriteLine("Сумма = {0}", sum);
static async Task<int> Square(int n)
{
    await Task.Delay(1000);
    return n * n;
}
```

### Дополнительные возвращаемые типы

В C# 7 доступны дополнительные возвращаемые типы притусловии, что они следуют шаблону с ключевым словом async.В качестве конкретного примера можно назвать тип ValueTask.

```csharp
private static async ValueTask<int> GetValue(int value)
{
    var result = value * 2;
    await Task.Delay(1000);
    return result;
}
```

### Расширение

Представление всех разновидностей асинхронных операций одним типом (Task) чрезвычайно полезно, потому что оно
позволяет реализовать комбинаторы (методы WhenAll и WhenAny класса Task) и другие полезные операции.

Асинхронные функции предоставляют еще одну точку расширения: компилятор вызывает GetAwaiter для операнда, использовавшегося с await. Таким образом, операнд вообще не обязан быть объектом Task; он может относиться к любому типу, содержащему метод GetAwaiter.

В библиотеке Kanadeiar.Core определен класс TaskLogger. Он позволяет выводить информацио о всех незавершенных асинхронных задачах. Такая информация чрезвычайно полезна в ходе отладки, особенно если ваше приложение «виснет» из-за некорректного запроса или отсутствия реакции сервера.

```csharp
Task.Delay(2_000).Log("2с") //отслеживание
var logs = TaskLogger.GetLogStrings().ToArray(); //получение данных логов
```

### События

Асинхронные функции обычно используют тип возвращаемого значения Task или Task<Result>, представляющий завершение конечного автомата функции. Однако также возможно определение асинхронной функции с возвращаемым типом void. Это особый случай, который поддерживается компилятором C# для упрощения очень распространенной ситуации: реализации асинхронного обработчика события.

Чтобы пользовательский интерфейс реагировал на действия пользователя, ввод-вывод должен выполняться асинхронно.

Когда асинхронная функция имеет возвращаемый тип void, компилятор генерирует код создания конечного автомата, но не создает объект Task, потому что он все равно не будет использоваться. По этой причине невозможно узнать, что конечный автомат асинхронной функции, возвращающей void, отработал до завершения.

Следует использовать в таком коде блок try-catch для перехвата ошибок от Task или Task<Result>.

### Асинхронные потоки

В C# появилась возможность создания и потребления потоков данных асинхронным образом.

Пример:

```csharp
static async IAsyncEnumerable<int> GetInts()
{
    for (var i = 0; i < 10; i++)
    {
        await Task.Delay(100);
        yield return i;
    }
}
// использование
await foreach (var e in GetInts())
{
    Console.WriteLine(e);
}
```

### Библиотека BCL

Асинхронные функции сразу видны в коде, потому что по действующим соглашениям имя метода снабжается суффиксом Async. В BCL многие типы, предоставляющие операции ввода-вывода, также предоставляют методы XxxAsync. Они использую современную модель асинхронного программирования - методы с объектами Task.

Существуют еще методы с устаревшей моделью асинхронного программирования:

- модель, использовавшая методы BeginXxx и EndXxx в сочетании с интерфейсом IAsyncResult.

- событийная модель, использовавшая методы XxxAsync (не возвращающие объекты Task) с вызовами методов обработчиков событий при завершении асинхронных операций.

Пример преобразования модели BeginXxx и EndXxx на новую асинхронную модель программирования:

```csharp
private static async Task<string?> FileReadAsync(string? path)
{
    if (!File.Exists(path))
        throw new FileNotFoundException(nameof(path));
    using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read))
    {
        var buff = new byte[fs.Length];
        return await Task.Factory.FromAsync(fs.BeginRead, fs.EndRead, buff, 0, buff.Length, TaskCreationOptions.None).ContinueWith(_ =>
            {
                using (var ms = new MemoryStream(buff))
                using (var sr = new StreamReader(ms))
                    return sr.ReadToEnd();
            });
    }
}
```

Пример преобразования событийной модели на новую асинхронную модель программирования:

```csharp
private static async Task<string> GetWebAsync(Uri uri)
{
    var wc = new System.Net.WebClient();
    var tcs = new TaskCompletionSource<string>();
    wc.DownloadStringCompleted += (s, e) =>
    {
        if (e.Cancelled) tcs.SetCanceled();
        else if (e.Error != null) tcs.SetException(e.Error);
        else tcs.SetResult(e.Result);
    };
    wc.DownloadStringAsync(uri);
    var result = await tcs.Task;
    return result;
}
```

### Исключения

Объекты Task обычно инициируют исключение AggregateException, а для получения информации о реальных исключениях следует обратиться к свойству InnerExceptions этого исключения. Однако при использовании await с Task вместо AggregateException выдается первое внутреннее исключение.

Если метод конечного автомата сталкивается с необработанным исключением, то объект Task, представляющий асинхронную функцию, завершается из-за необработанного исключения. Любой код, ожидающий завершения этого объекта Task, «увидит» это исключение. Однако асинхронная функция также может иметь возвращаемый тип void; в этом случае вызывающая сторона не может обнаружить необработанное исключение.

### Отмена операции

В языке C# есть методы для отмены асинхронной операции, в параметрах которого можно передавать время на выполнение метода и токен отмены операции.

Пример:

```csharp
var cts = new CancellationTokenSource();
var r1 = await Method(1).WaitAsync(TimeSpan.FromSeconds(5));
var r2 = await Method(2).WaitAsync(cts.Token);
var r3 = await Method(3).WaitAsync(TimeSpan.FromSeconds(5), cts.Token);
```

В библиотеке Kanadeiar.Core определен метод расширения WithCancellation, позволяющий производить отмену асинхронной операции по истечении заданного в методе интервала времени.

```csharp
await Task.Delay(10_000).WithCancellation(token); // добавление отмены операции
```










