# Асинхронный управление

Приложения с графическим интерфейсом перестают реагировать на действия пользователя на время блокировки потока.

В ситуации, когда количество потоков значительно превосходит количество ядер процессора, операционная система прибегнет к частым переключениям контекста, что значительно снизит производительность.

Асинхронный ввод-вывод кроме минимального использования ресурсов и уменьшения количества переключений контекста предоставляет более быструю работу сборщика мусора вследствии уменьшения числа потоков, в случае набора асинхронных операций ввода-вывода время их завершения определяется самой медленной из выполняемых операций и отзывчивый интерфейс в графических приложениях.

## Асинхронные функции

Асинхронные функции позволяют писать приложения, выполняющие множество операций при помощи небольшого количества потоков. Вместе с пулом потоков они дают возможность эффективно задействовать все процессоры в системе. Разработанная модель программирования задействует объекты Task и асинхронные функции языка C#. 

В C# есть ключевые слова async и await для упрощения процесса написания асинхронного кода. Компилятор будет самостоятельно генерировать большой объем кода, связанного с потоками, из пространств System.Threading и System.Theading.Tasks.

Ключевое слово async помечает метод, лямбда-выражение или анонимный метод должен вызываться в асинхронной манере автоматически. При вызове async ключевое слово await будет автоматически приостанавливать текущий поток, пока задача не завершится, давая возможность вызывающему потоку продолжить свою работу.

Асинхронный метод должен быть помечен async и иметь в своем коде хотя бы один await, иначе он будет скомпилирован в итоге для синхронного выполнения.

Для асинхронных функций действует ряд ограничений:

- Метод Main приложения не может быть преобразован в асинхронную функцию. Кроме того, конструкторы, методы доступа свойств и методы доступа событий не могут быть преобразованы в асинхронные функции.

- Асинхронная функция не может иметь параметры out и ref.

- Оператор await не может использоваться в блоке catch, finally или unsafe.

- Не допускается установление блокировки, поддерживающей владение потоком или рекурсию, до операции await, и ее снятие после оператора await. Это ограничение объясняется тем, что один поток может выполнить код до await, а другой поток может выполнить код после await. При использовании await с командой C# lock компилятор выдает сообщение об ошибке.

- В выражениях запросов оператор await может использоваться только в первом выражении коллекции условия from или в выражении коллекции условия join.

Пример использования асинхронных методов с одним входным параметром:

```csharp
static void MyWork()
{
    Thread.Sleep(3_000);
    Console.WriteLine("void Работа");
}
static void MyDetailWork(int x)
{
    Thread.Sleep(3_000);
    Console.WriteLine($"void Подробная работа #{x}");
}
static async void MyVoidAsync() //без возврата значения
{
    await Task.Run(() =>
    {
        Thread.Sleep(5_000);
        Console.WriteLine("void async Работа");
    });
}
static async Task MyWorkAsync(int x)
{
    await Task.Run(MyWork); //без параметра
    await Task.Run(() => MyDetailWork(x)); //с параметром
    Thread.Sleep(2_000);
    Console.WriteLine($"async Task Работа #{x}");
}
static async Task Main() //вызов в неблокирующей манере
{
    MyWorkAsync(1); //вызов асинхронного метода
    MyVoidAsync(); //еще вызов асинх метода
    Console.WriteLine("Работа #1 запущена асинхронно");
    await Task.Run(() =>
    {
        Thread.Sleep(5_000);
        Console.WriteLine("Лямбда работа");
    }); //асинхронная работа лямбда функция с ожиданием, хотя можно без, если удалить await
    Console.WriteLine("Введите что нибудь:");
    string s = Console.ReadLine();
    Console.WriteLine($"Вы ввели: {s}");
    Console.WriteLine("Старт и ожидание завершения работы #2");
    await MyWorkAsync(2); //ожидание завершения асинх метода
    Console.WriteLine("Работа #2 завершена");
    Console.WriteLine("Нажмите любую кнопку ...");
    Console.ReadKey();
}
```

Пример использования асинхронных функций с входным и возвращаемым параметром:

```csharp
static int MyFunc(int x)
{
    Thread.Sleep(3_000);
    Console.WriteLine($"int Вычисление : {x}");
    return x + 1;
}
static async Task<int> MyFuncAsync(int x)
{
    int y = await Task.Run(() => MyFunc(x));
    Thread.Sleep(2_000);
    Console.WriteLine($"int async Вычисление : {y}");
    return y + 1;
}
static async Task<int> MyFuncSumAsync() //сумма асинхронная вычислений
{
    Task<int> t1 = Task<int>.Run(() => MyFunc(1));
    Task<int> t2 = Task<int>.Run(() => MyFunc(2));
    Task<int> t3 = Task<int>.Run(() => MyFunc(3));
    var res = await Task<int>.WhenAll(new[] {t1, t2, t3}); //выполнение всех задач
    return res.Sum();
}
static async Task Main() //вызов в неблокирующей манере
{
    int x = await Task<int>.Run(() => 1); //асинхронная работа лямбда функция с ожиданием
    Console.WriteLine("Введите что нибудь:");
    string s = Console.ReadLine();
    Console.WriteLine($"Вы ввели: {s}");
    Console.WriteLine("Старт и ожидание завершения вычислений");
    int y = await MyFuncAsync(1); //ожидание завершения асинх метода
    Console.WriteLine($"Вычисление завершено y = {y}");
    y = await MyFuncSumAsync();
    Console.WriteLine($"Результат вычисления асинхронного: {y}");
    Console.WriteLine("Нажмите любую кнопку ...");
    Console.ReadKey();
}
```

Пример вызова обычных функций асинхронно:

```csharp
static void MyWork()
{
    Thread.Sleep(6_000);
    Console.WriteLine("void Работа");
}
static int MyFunc(int x)
{
    Thread.Sleep(3_000);
    Console.WriteLine($"int Вычисление : {x}");
    return x + 1;
}
static async Task Main() //вызов в неблокирующей манере
{
    Task.Run(MyWork); //запуск асинхронно
    Console.WriteLine("Работа запущена асинхронно");
    Console.WriteLine("Старт и ожидание завершения вычислений");
    int y = await Task<int>.Run(() => MyFunc(1)); //ожидание завершения асинх вычислений
    Console.WriteLine($"Вычисление завершено y = {y}");
    Console.WriteLine("Нажмите любую кнопку ...");
    Console.ReadKey();
}
```













