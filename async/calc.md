# Асинхронные вычисления

К вычислительным асинхронным операциям, в частности, относятся компиляция кода, проверка орфографии, проверка грамматики, пересчет электронных таблиц, перекодирование аудио- и видеоданных, создание миниатюр изображений.

## Пул потоков

Для каждого экземпляра CLR существует свой пул, используемый всеми доменами приложений, находящимися под управлением экземпляра CLR. Если в один процесс загружаются несколько экземпляров CLR, для каждого из них формируется собственный пул.

Для выполнения приложением асинхронной операции вызывается метод, размещающий соответствующий запрос в очереди пула потоков. Код пула извлекает записи из очереди и распределяет их
среди потоков из пула. Если пул пуст, создается новый поток. Как уже отмечалось, создание потока отрицательно сказывается на производительности. Однако по завершении исполнения своего задания поток не уничтожается, а возвращается в пул и ожидает следующего запроса. Поскольку поток не уничтожается, производительность не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их все с помощью одного потока. Однако если приложение создает очередь запросов быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. Такой подход позволяет обойтись при обработке запросов небольшим количеством потоков.

Когда приложение прекращает отправлять запросы в пул, появляются незанятые потоки, впустую занимающие память. Поэтому через некоторое время бездействия (различное для разных версий CLR) поток пробуждается и самоуничтожается, освобождая ресурсы.

Пул потоков позволяет найти компромисс в ситуации, когда малое количество потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами многопроцессорных систем, а также многоядерных и гиперпотоковых процессоров.

### Простые вычислительные операции

Для добавления в очередь пула потоков асинхронных вычислительных операций можно вызвать методов класса ThreadPool - QueueUserWorkItem(). Этот метод ставит «рабочий элемент» вместе с дополнительными данными состояния в очередь пула потоков и сразу возвращают управление приложению.

Пример простейшего использования пула потоков:

```csharp
static void Method(object? obj)
{
    Console.WriteLine("Данные на входе метода: {0}", obj);
    Thread.Sleep(3000);
}
// вызов
ThreadPool.QueueUserWorkItem(Method, "объект");
Thread.Sleep(5000);
```

Планировщик Windows решает, какой поток должен выполняться первым, или же планирует их для одновременного выполнения на многопроцессорном компьютере.

### Контексты исполнения потоков

С каждым потоком связан определенный контекст исполнения. Он включает в себя параметры безопасности, хоста и данные логического вызова. Когда поток исполняет код, значения параметров контекста исполнения оказывают влияние на некоторые операции. По умолчанию CLR автоматически копирует контекст исполнения самого первого потока во все вспомогательные потоки. Сбор всей информации и ее копирование во вспомогательные потоки занимает немало времени, но зато гарантируется безопасность.

Класс ExecutionContext в пространстве имен System.Threading позволяет управлять копированием контекста исполнения потока.

### Скоординированная отмена

Платформа .NET предлагает стандартный паттерн операций отмены. Этот паттерн является скоординированным (cooperative), то есть требует явной поддержки отмены операций. Для отмены длинельных вычислительных операций можно применять специальные классы CancellationTokenSource и CancellationToken.

Экземпляр CancellationToken относится к упрощенному значимому типу, так как содержит всего одно закрытое поле: ссылку на свой объект CancellationTokenSource. Цикл вычислительной операции может периодически обращаться к свойству IsCancellationRequested объекта CancellationToken, чтобы узнать, не требуется ли раннее завершение его работы, то есть прерывание операции.

Пример использования:

```csharp
static void Test(CancellationToken token, int value)
{
    var val = 0;
    for (int i = 0; i < value; i++)
    {
        if (token.IsCancellationRequested)
        {
            Console.WriteLine("Отменено");
            break;
        }
        val += i;
        Thread.Sleep(1000);
        Console.WriteLine(val);
    }
    Console.WriteLine("Готово: {0}!", val);
}
// использование токена отмены асинхронной операции
var cts = new CancellationTokenSource();
ThreadPool.QueueUserWorkItem(_ => Test(cts.Token, 100));
Console.WriteLine("Любую кнопку нажать для отмены");
Console.ReadKey();
cts.Cancel();
```

Можно создать новый объект CancellationTokenSource, связав друг с другом другие объекты CancellationTokenSource. Отмена этого нового объекта произойдет при отмене любого из входящих в его состав объектов.

Можно отменить операцию по истечении определенного времени - для этого нужно передать определенный параметр в конструктор класса отмены операций или использовать метод CancelAfter.

```csharp
var cts = new CancellationTokenSource();
cts.CancelAfter(1000);
```

## Задания

Для обхода многих ограничений и недостатков прямого использования методов пула потоков было введено понятие заданий (tasks), выполнение которых осуществляется посредством типов из пространства имен System.Threading.Tasks.

Полностью аналогичные операции постановки задачи в пул потоков, в итоге превращающиеся в одинаковый IL код:

```csharp
ThreadPool.QueueUserWorkItem(Method, 5);
new Task(Method, 5).Start();
Task.Run(() => Method(5)); //наилудший вариант
```

При желании конструктору можно передавать флаги из перечисления TaskCreationOptions, управляющие способами выполнения заданий. Элементы перечисления определяют набор флагов, которые могут комбинироваться по разрядной операцией ИЛИ.

Флаги:

None - без изменения

PreferFairness - как можно скорее поставить задание на выполнение

LongRunning - создавать потоки в пуле потоков

AttachedToParent - присоединяет задание к его родителю

DenyChildAttach - задача интерпретируется как обычная, а не дочерняя

HideScheduler - дочерние задачи будут использовать стандартный планировкик вместо родительского

### Получение результата задания

Можно дождаться завершения задания и после этого получить результат его выполнения.

Можно создать объект Task<TResult> (производный от объекта Task) и в качестве универсального аргумента TResult передать тип результата, возвращаемого вычислительной операцией. Затем остается дождаться завершения выполняющегося задания и получить результат.

Если вычислительное задание генерирует необработанное исключение, оно поглощается и сохраняется в коллекции, а потоку пула разрешается вернуться в пул. Затем при вызове метода Wait или свойства Result эти члены вбросят исключение System.AggregateException. Сам тип AggregateException инкапсулирует коллекцию исключений.

Можно ожидать завершения не только одного задания, но и массива объектов Task. Метод WaitAny блокирует вызов потоков до завершения выполнения всех объектовв массиве Task. Статический метод WaitAll класса Task блокирует вызывающий поток до завершения всех объектов Task в массиве. Отмена же метода посредством структуры CancellationToken приводит к исключению OperationCanceledException.

Для отмены задания можно воспользоваться объектом CancellationTokenSource.

Пример запуска простого метода асинхронно и получения от него результата:

```csharp
static int Sum(int values)
{
    var sum = 0;
    for (; values > 0; values--)
    {
        sum += values;
    }
    return sum;
}
// запуск и получение результата
var task = new Task<int>(x => Sum((int)x!), 100);
task.Start();
task.Wait();
Console.WriteLine("Результат: {0}", task.Result);
```

Более сложный пример с отменой операции:

```csharp
static int Sum(int values, CancellationToken? token = null)
{
    var sum = 0;
    for (; values > 0; values--)
    {
        token?.ThrowIfCancellationRequested();
        sum += values;
    }
    return sum;
}
// запуск и получение результата
CancellationTokenSource cts = new CancellationTokenSource();
var task = new Task<int>(() => Sum(100, cts.Token), cts.Token);
task.Start();
cts.Cancel();
try
{
    Console.WriteLine("Результат: {0}", task.Result);
}
catch (AggregateException ex)
{
    ex.Handle(e => e is OperationCanceledException);
    Console.WriteLine("Операция отменена");
}
```

### Запуск нового задания после предидущего

Для написания масштабируемого программного обеспечения следует избегать блокировки потоков (Wait и Result).

Пример как только задание, выполняющее метод Sum, завершится, оно инициирует выполнение следующего задания (также на основе потока из пула), которое выведет результат.

```csharp

```




