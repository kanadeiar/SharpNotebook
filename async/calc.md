# Асинхронные вычисления

К вычислительным асинхронным операциям, в частности, относятся компиляция кода, проверка орфографии, проверка грамматики, пересчет электронных таблиц, перекодирование аудио- и видеоданных, создание миниатюр изображений.

## Пул потоков

Для каждого экземпляра CLR существует свой пул, используемый всеми доменами приложений, находящимися под управлением экземпляра CLR. Если в один процесс загружаются несколько экземпляров CLR, для каждого из них формируется собственный пул.

Для выполнения приложением асинхронной операции вызывается метод, размещающий соответствующий запрос в очереди пула потоков. Код пула извлекает записи из очереди и распределяет их
среди потоков из пула. Если пул пуст, создается новый поток. Как уже отмечалось, создание потока отрицательно сказывается на производительности. Однако по завершении исполнения своего задания поток не уничтожается, а возвращается в пул и ожидает следующего запроса. Поскольку поток не уничтожается, производительность не страдает.

Когда приложение отправляет пулу много запросов, он пытается обслужить их все с помощью одного потока. Однако если приложение создает очередь запросов быстрее, чем поток из пула их обслуживает, создаются дополнительные потоки. Такой подход позволяет обойтись при обработке запросов небольшим количеством потоков.

Когда приложение прекращает отправлять запросы в пул, появляются незанятые потоки, впустую занимающие память. Поэтому через некоторое время бездействия (различное для разных версий CLR) поток пробуждается и самоуничтожается, освобождая ресурсы.

Пул потоков позволяет найти компромисс в ситуации, когда малое количество потоков экономит ресурсы, а большое позволяет воспользоваться преимуществами многопроцессорных систем, а также многоядерных и гиперпотоковых процессоров.

### Простые вычислительные операции

Для добавления в очередь пула потоков асинхронных вычислительных операций можно вызвать методов класса ThreadPool - QueueUserWorkItem(). Этот метод ставит «рабочий элемент» вместе с дополнительными данными состояния в очередь пула потоков и сразу возвращают управление приложению.

Пример простейшего использования пула потоков:

```csharp
static void Method(object? obj)
{
    Console.WriteLine("Данные на входе метода: {0}", obj);
    Thread.Sleep(3000);
}
// вызов
ThreadPool.QueueUserWorkItem(Method, "объект");
Thread.Sleep(5000);
```

Планировщик Windows решает, какой поток должен выполняться первым, или же планирует их для одновременного выполнения на многопроцессорном компьютере.

### Контексты исполнения потоков

С каждым потоком связан определенный контекст исполнения. Он включает в себя параметры безопасности, хоста и данные логического вызова. Когда поток исполняет код, значения параметров контекста исполнения оказывают влияние на некоторые операции. По умолчанию CLR автоматически копирует контекст исполнения самого первого потока во все вспомогательные потоки. Сбор всей информации и ее копирование во вспомогательные потоки занимает немало времени, но зато гарантируется безопасность.

Класс ExecutionContext в пространстве имен System.Threading позволяет управлять копированием контекста исполнения потока.

### Скоординированная отмена

Платформа .NET предлагает стандартный паттерн операций отмены. Этот паттерн является скоординированным (cooperative), то есть требует явной поддержки отмены операций. Для отмены длинельных вычислительных операций можно применять специальные классы CancellationTokenSource и CancellationToken.

Экземпляр CancellationToken относится к упрощенному значимому типу, так как содержит всего одно закрытое поле: ссылку на свой объект CancellationTokenSource. Цикл вычислительной операции может периодически обращаться к свойству IsCancellationRequested объекта CancellationToken, чтобы узнать, не требуется ли раннее завершение его работы, то есть прерывание операции.

Пример использования:

```csharp
static void Test(CancellationToken token, int value)
{
    var val = 0;
    for (int i = 0; i < value; i++)
    {
        if (token.IsCancellationRequested)
        {
            Console.WriteLine("Отменено");
            break;
        }
        val += i;
        Thread.Sleep(1000);
        Console.WriteLine(val);
    }
    Console.WriteLine("Готово: {0}!", val);
}
// использование токена отмены асинхронной операции
var cts = new CancellationTokenSource();
ThreadPool.QueueUserWorkItem(_ => Test(cts.Token, 100));
Console.WriteLine("Любую кнопку нажать для отмены");
Console.ReadKey();
cts.Cancel();
```

Можно создать новый объект CancellationTokenSource, связав друг с другом другие объекты CancellationTokenSource. Отмена этого нового объекта произойдет при отмене любого из входящих в его состав объектов.

Можно отменить операцию по истечении определенного времени - для этого нужно передать определенный параметр в конструктор класса отмены операций или использовать метод CancelAfter.

```csharp
var cts = new CancellationTokenSource();
cts.CancelAfter(1000);
```

## Задания

Для обхода многих ограничений и недостатков прямого использования методов пула потоков было введено понятие заданий (tasks), выполнение которых осуществляется посредством типов из пространства имен System.Threading.Tasks.

Аналогичные операции постановки задачи в пул потоков:

```csharp
ThreadPool.QueueUserWorkItem(Method, 5);
new Task(Method, 5).Start();
Task.Run(() => Method(5)); //наилудший вариант
```

При желании конструктору можно передавать флаги из перечисления TaskCreationOptions, управляющие способами выполнения заданий. Элементы перечисления определяют набор флагов, которые могут комбинироваться по разрядной операцией ИЛИ.

Флаги:

None - без изменения

PreferFairness - как можно скорее поставить задание на выполнение

LongRunning - создавать потоки в пуле потоков

AttachedToParent - присоединяет задание к его родителю

DenyChildAttach - задача интерпретируется как обычная, а не дочерняя

HideScheduler - дочерние задачи будут использовать стандартный планировкик вместо родительского





